/** Вопросы и ответы: id, question, answer. id — строго по порядку 1, 2, 3, … N; при добавлении/удалении пересчитывать и обновлять questionIds в BLOCKS. */
const QUESTIONS = [
  { id: 1, question: 'Python', answer: '**Python** — высокоуровневый **интерпретируемый** язык с **динамической** и **строгой типизацией**.\n\n**Интерпретируемый:** код не компилируется в машинный язык заранее; в CPython он превращается в байт-код и выполняется виртуальной машиной «на лету», без отдельного шага сборки в исполняемый файл.\n\n**Типизация:** динамическая — тип переменной определяется в runtime (одна и та же переменная может ссылаться на объекты разных типов); строгая — неявных приведений типов почти нет (например, нельзя сложить строку и число без явного преобразования).\n\n**Под капотом (CPython), по шагам:**\n1. Исходный код (.py) парсится в AST (Абстрактное синтаксическое дерево).\n2. AST компилируется в байт-код (.pyc).\n3. Байт-код выполняется виртуальной машиной (PVM).\n4. Результат — переносимость между платформами без перекомпиляции.\n\n**Сборщик мусора:** основной механизм — **подсчёт ссылок (reference counting):** у каждого объекта хранится счётчик — сколько ссылок на него указывает; при создании ссылки счётчик увеличивается, при удалении ссылки — уменьшается; когда счётчик становится 0, объект сразу освобождается. Дополнительно модуль **gc** находит циклы ссылок (A → B → C → A), где счётчики не обнуляются, и помечает такие объекты для удаления.' },
  { id: 2, question: 'Типы данных в Python', answer: 'Типы делятся на **изменяемые** и **неизменяемые**.\n\n**Изменяемые:** list, dict, set — могут изменяться после создания.\n\n**Неизменяемые:** int, float, complex, bool, str, tuple, frozenset — при изменении создаётся новый объект.' },
  { id: 3, question: 'Структуры данных в Python', answer: '**Встроенные:** список (динамический массив), кортеж (неизменяемая последовательность), словарь (хэш-таблица), множество, строка, range.\n\n**Через библиотеки или свои реализации:** стек, очередь, деревья и графы.' },
  { id: 4, question: 'Lambda-функция', answer: '**Lambda** — анонимная функция, ограниченная одним выражением.\n\nЧаще всего используется как аргумент **функций высшего порядка** (map, filter, sorted) или там, где полноценное def избыточно.\n\nПример:\n  square = lambda x: x ** 2\n  evens = filter(lambda x: x % 2 == 0, [1, 2, 3, 4])\n  sorted(users, key=lambda u: u[\'name\'])' },
  { id: 5, question: 'Генератор', answer: '**Генератор** — объект, возвращающий значения по одному по запросу (**ленивые вычисления**). Реализует протокол итератора (__iter__, __next__), при исчерпании выбрасывает **StopIteration**.\n\n**Создание:** функция с **yield** или **generator comprehension** (x for x in ...). Экономят память — не хранят всю последовательность сразу.\n\n**Методы:**\n**next(g)** / **g.__next__()** — следующее значение.\n**g.send(value)** — отправить значение в генератор (оно подставляется в выражение yield). Перед первым **send(value)** нужно «прогнать» генератор до первого yield — вызвать **send(None)** или **next(g)**; иначе некуда подставлять value.\n**g.throw(exc)** — выбросить исключение внутри генератора.\n**g.close()** — завершить генератор.\n\n**return** в теле генератора: завершает генератор; в Python 3.3+ значение после return попадает в атрибут **StopIteration.value** (при переборе через for не видно, только при ручном next).\n\nПример с yield:\n  def count_to(n):\n    for i in range(n):\n      yield i\n  g = count_to(3)\n  next(g)  # 0\n  next(g)  # 1\n\nПример generator comprehension:\n  squares = (x ** 2 for x in range(5))\n  list(squares)  # [0, 1, 4, 9, 16]' },
  { id: 6, question: 'Итератор', answer: '**Итератор** — объект, поддерживающий **протокол итерации** (__iter__, __next__).\n\nХранит текущее состояние перебора и выбрасывает **StopIteration**, когда элементы заканчиваются.\n\nПример итератора на уровне класса:\n  class CountDown:\n    def __init__(self, start):\n      self.current = start\n    def __iter__(self):\n      return self\n    def __next__(self):\n      if self.current <= 0:\n        raise StopIteration\n      value = self.current\n      self.current -= 1\n      return value\n  for x in CountDown(3):\n    print(x)  # 3, 2, 1' },
  { id: 7, question: 'List/dict comprehension', answer: '**Comprehension** — синтаксический сахар для компактного создания коллекций (list, dict, set). Повышает читаемость и часто быстрее эквивалентных циклов for.\n\n**List comprehension:**\n  [x ** 2 for x in range(5)]           # [0, 1, 4, 9, 16]\n  [x for x in nums if x % 2 == 0]     # только чётные\n  [x if x > 0 else 0 for x in nums]  # тернарный (else обязателен)\n\n**С несколькими for и if:**\n  [(i, j) for i in range(2) for j in range(2) if i != j]  # [(0,1), (1,0)]\n  [x for row in matrix for x in row]  # «развернуть» матрицу в список\n\n**Dict comprehension:**\n  {k: v * 2 for k, v in d.items()}\n  {x: x ** 2 for x in range(5) if x % 2 == 0}  # {0: 0, 2: 4, 4: 16}\n\n**Set comprehension:**\n  {abs(x) for x in [-1, 1, -2, 2]}  # {1, 2}' },
  { id: 8, question: 'Аргументы *args и **kwargs', answer: 'Используются для передачи **переменного количества аргументов**.\n\n***args** — собирает позиционные аргументы в **кортеж**.\n\n****kwargs** — именованные аргументы в **словарь**. Часто применяются в декораторах и обёртках.\n\nПримеры в функции:\n  def f(*args):\n    print(args)  # кортеж\n  f(1, 2, 3)   # (1, 2, 3)\n\n  def g(**kwargs):\n    print(kwargs)  # словарь\n  g(a=1, b=2)     # {\'a\': 1, \'b\': 2}\n\n  def h(*args, **kwargs):\n    print(args, kwargs)\n  h(1, 2, x=3)   # (1, 2) {\'x\': 3}' },
  { id: 9, question: 'Основные принципы ООП', answer: '**Абстракция** — выделение существенных свойств объекта и сокрытие деталей. Модель описывает «что» объект делает, а не «как». В коде: абстрактные классы, интерфейсы, минимальный публичный контракт.\n\n**Инкапсуляция** — скрытие внутреннего состояния и реализации; доступ только через методы (или свойства). Защита от некорректного изменения данных, возможность менять реализацию без слома клиентов. В Python: соглашение об именовании (_protected, __private), property, дескрипторы.\n\n**Наследование** — подкласс получает поля и методы базового класса, может переопределять и дополнять. Повторное использование кода и выражение иерархии «является» (is-a).\n\n**Полиморфизм** — один интерфейс (имя метода, сигнатура), разное поведение у разных типов. Вызывающий код работает с абстракцией, не зная конкретный класс. В Python — утиная типизация: важна поддержка нужных методов, а не явное наследование.\n\n**Типы атрибутов (по именованию):** **public** — без подчёркивания, открытый интерфейс. **Protected** — одно подчёркивание **_name**: соглашение «внутренний, не для внешнего кода»; доступ не запрещён, но не рекомендуется. **Private** — два подчёркивания **__name**: имя манглится в **_Class__name**, чтобы уменьшить коллизии при наследовании; извне класса обращаться неудобно (но технически возможно). Один trailing underscore (**name_**) — чтобы не конфликтовать с ключевыми словами. В Python нет жёсткой блокировки доступа, только соглашения и name mangling.' },
  { id: 10, question: 'Разница между __new__(), __init__(), __call__()', answer: '**__new__** — создаёт объект в памяти (возвращает экземпляр).\n\n**__init__** — инициализирует уже созданный объект (self уже есть).\n\n**__call__** — позволяет вызывать экземпляр класса как функцию.\n\nПример (import не нужен — всё встроено):\n  class A:\n    def __new__(cls, x):\n      obj = super().__new__(cls)\n      return obj\n    def __init__(self, x):\n      self.x = x\n    def __call__(self, y):\n      return self.x + y\n  a = A(10)   # 1) __new__(A, 10) создаёт объект, 2) __init__(a, 10) задаёт a.x = 10\n  a(5)       # 15 — вызывается __call__(a, 5), возвращает a.x + 5' },
  { id: 11, question: 'Декоратор', answer: '**Декоратор** — функция высшего порядка: принимает функцию (или класс) и возвращает новую, оборачивая исходную и расширяя её поведение. Не меняет код самой функции.\n\nСинтаксис **@decorator** над определением функции эквивалентен присваиванию: `func = decorator(func)`.\n\nЧасто используется для **логирования**, **авторизации**, **кэширования**, замеров времени, повторных попыток.\n\nПример (логирование вызова):\n  def log(f):\n    def wrap(*args, **kwargs):\n      print(\'call\', f.__name__)\n      return f(*args, **kwargs)\n    return wrap\n  @log\n  def add(a, b):\n    return a + b\n  add(1, 2)   # print \"call add\", затем 3\n\nПример (декоратор с аргументами — фабрика декораторов):\n  def repeat(n):\n    def dec(f):\n      def wrap(*a, **k):\n        for _ in range(n): f(*a, **k)\n      return wrap\n    return dec\n  @repeat(2)\n  def say(): print(\'hi\')\n  say()   # hi hi' },
  { id: 12, question: 'Дескрипторы', answer: '**Дескрипторы** — классы, управляющие доступом к атрибутам других классов. Реализуют **__get__**, **__set__** (опционально), **__delete__** (опционально). Используются в **property**, ORM и системах валидации.\n\nПример:\n  class NonNegative:\n    def __init__(self, name):\n      self.name = name\n    def __get__(self, obj, type=None):\n      return obj.__dict__.get(self.name, 0)\n    def __set__(self, obj, value):\n      if value < 0:\n        raise ValueError(\'must be >= 0\')\n      obj.__dict__[self.name] = value\n  class Product:\n    price = NonNegative(\'price\')\n  p = Product()\n  p.price = 10   # ok\n  p.price = -1   # ValueError' },
  { id: 13, question: '@staticmethod / @classmethod / @property', answer: '**@staticmethod** — метод без доступа к self и cls; вызывается как **Class.method()** или **obj.method()**. Удобен для утилит, логически привязанных к классу (валидация, форматирование).\n\n**@classmethod** — первым аргументом получает **cls** (сам класс). Может создавать экземпляры, альтернативные конструкторы; доступ к атрибутам класса и наследованию.\n\n**@property** — когда обращаешься к атрибуту как к полю (**obj.x**), вызывается метод (чтение). Можно возвращать вычисленное значение. Если добавить **@x.setter** — тот же метод вызывается при присваивании (**obj.x = value**). Без setter атрибут только для чтения.\n\nПример:\n  class C:\n    x = 0\n    @staticmethod\n    def check(v): return v > 0\n    @classmethod\n    def from_pair(cls, a, b): return cls(a + b)\n    def __init__(self, val): self.val = val\n    @property\n    def double(self): return self.val * 2\n  C.check(1)       # True\n  c = C.from_pair(1, 2)  # c.val == 3\n  c.double         # 6 (без скобок)' },
  { id: 14, question: 'Атрибут __slots__', answer: '**__slots__** — кортеж или список имён разрешённых атрибутов экземпляра. Ограничивает динамическое добавление атрибутов (только перечисленные в __slots__) и убирает **__dict__** у экземпляров, что снижает потребление памяти. Важно при большом количестве объектов.\n\n**Наследники:** если подкласс **не задаёт** свой __slots__, у его экземпляров появляется **__dict__** (можно добавлять атрибуты). Если подкласс задаёт **__slots__**, он обычно перечисляет и свои новые имена; слоты родителя наследуются, у экземпляров подкласса снова нет __dict__ (только слоты родителя + свои). Пустой **__slots__ = ()** в подклассе сохраняет слоты родителя без добавления своих и без __dict__.' },
  { id: 15, question: 'MRO', answer: '**MRO** (Method Resolution Order) — порядок, в котором Python ищет метод (или атрибут) при **множественном наследовании**: обход базовых классов слева направо по списку наследования, без повторного посещения одного класса.\n\nЗачем нужен: при «ромбе» (A → B, C → D(B, C)) однозначно решить, какой метод вызвать. Алгоритм **C3** строит линейный порядок так, что: порядок в объявлении класса сохраняется; если класс X наследует от Y, то в MRO X идёт перед Y. Гарантирует предсказуемый и устойчивый к изменениям порядок.\n\nПример:\n  class A: pass\n  class B(A): pass\n  class C(A): pass\n  class D(B, C): pass\n  print(D.__mro__)\n  # (D, B, C, A, object)\n  # поиск метода: сначала D, потом B, потом C, потом A, потом object' },
  { id: 16, question: 'Метаклассы', answer: '**Метакласс** — класс класса: объект класса является экземпляром своего метакласса. По умолчанию метакласс — **type**. При определении класса вызываются **__new__** и **__init__** метакласса (а не обычного класса). Чтобы изменить пространство имён класса (dct) до создания класса — важно переопределить **__new__**; **__init__** получает уже созданный класс и подходит для постобработки.\n\nИспользуются для **валидации** (проверка атрибутов/наследования при создании класса), **регистрации** классов (реестры, плагины), построения фреймворков (ORM, API), автоматического добавления методов или атрибутов.\n\nПример (метакласс добавляет атрибут):\n  class Meta(type):\n    def __new__(mcs, name, bases, dct):\n      dct[\'created_by\'] = \'Meta\'\n      return super().__new__(mcs, name, bases, dct)\n  class A(metaclass=Meta): pass\n  print(A.created_by)   # Meta' },
  { id: 35, question: 'Основные магические методы класса', answer: '**Дандеры** (double underscore) — специальные методы, которые вызываются операторами и встроенными функциями.\n\n**Создание и инициализация:**\n**__new__(cls, ...)** — создаёт объект в памяти; **__init__(self, ...)** — инициализирует уже созданный экземпляр.\n\n**Строковое представление:**\n**__str__(self)** — вызывается **str(obj)** и **print(obj)**; для пользователя. **__repr__(self)** — **repr(obj)** и отображение в интерпретаторе; желательно однозначное представление для отладки.\n\n**Сравнение и хэш:**\n**__eq__(self, other)** — **==**. **__ne__(self, other)** — **!=** (по умолчанию возвращает не __eq__).\n\n**__lt__(self, other)** — **<**, **__le__(self, other)** — **<=**, **__gt__(self, other)** — **>**, **__ge__(self, other)** — **>=**; используются **sorted()**, **min()**, **max()** и сравнения.\n\nДостаточно реализовать **__lt__** и **__eq__**, остальное можно получить через **functools.total_ordering**.\n\n**__hash__(self)** — **hash(obj)**; нужен для **set** и ключа **dict**; при переопределении __eq__ у неизменяемых типов обычно переопределяют и __hash__.\n\n**Коллекции и доступ:**\n**__len__(self)** — вызывается **len(obj)**; должен возвращать неотрицательное целое (размер коллекции).\n\n**__getitem__(self, key)** — **obj[key]**; чтение по ключу/индексу; для **in** и итерации по индексу используется, если нет __iter__.\n\n**__setitem__(self, key, value)** — **obj[key] = value**; запись по ключу/индексу (для изменяемых коллекций).\n\n**__iter__(self)** — вызывается **iter(obj)** и в **for**; должен возвращать итератор (объект с **__next__**). **__next__(self)** — следующий элемент; вызывается **next(iterator)**; в конце выбрасывает **StopIteration**.\n\n**Доступ к атрибутам:**\n**__getattr__(self, name)** — вызывается, когда атрибут **не найден** в обычном поиске (self.name, getattr); удобен для «ленивых» атрибутов и прокси.\n\n**__getattribute__(self, name)** — вызывается **при каждом** обращении к атрибуту (до поиска в __dict__); легко зациклить (обращение к self внутри), обычно используют **object.__getattribute__(self, name)**.\n\n**__setattr__(self, name, value)** — вызывается при **присваивании** атрибута **obj.name = value**; внутри избегать прямого self.name = ... (вызовет рекурсию), использовать **object.__setattr__(self, name, value)** или **self.__dict__[name] = value**.\n\n**Вызов и контекст:**\n**__call__(self, ...)** — вызов экземпляра как функции **obj(...)**. **__enter__(self)**, **__exit__(self, ...)** — контекстный менеджер **with obj:**.' },
  { id: 36, question: 'Геттеры, сеттеры и делитеры', answer: '**Геттер** — метод для чтения атрибута; **сеттер** — для записи; **делитер** — для удаления (del obj.attr). В Python их реализуют через **@property** и опционально **@имя.setter**, **@имя.deleter** — обращение к атрибуту выглядит как к полю (obj.x), но вызываются методы.\n\n**@property** — метод вызывается при **чтении** obj.x; можно вычислять значение, кэшировать, проверять доступ.\n\n**@x.setter** — вызывается при **присваивании** obj.x = value; удобно для валидации или побочных эффектов.\n\n**@x.deleter** — вызывается при **del obj.x**; освобождение ресурсов или сброс состояния.\n\nПример:\n  class C:\n    def __init__(self):\n      self._x = 0\n    @property\n    def x(self):\n      return self._x\n    @x.setter\n    def x(self, v):\n      if v < 0: raise ValueError(\'x >= 0\')\n      self._x = v\n    @x.deleter\n    def x(self):\n      self._x = 0\n  c = C()\n  c.x = 10\n  print(c.x)   # 10\n  del c.x\n  print(c.x)   # 0' },
  { id: 17, question: 'GIL', answer: '**GIL** (Global Interpreter Lock) — блокировка, ограничивающая одновременное выполнение байт-кода **одним потоком** в CPython.\n\n**Для чего:** избежание **race conditions** (гонок). Race condition — когда два потока одновременно читают или меняют одни и те же данные и результат зависит от порядка выполнения (данные могут испортиться). В CPython используется **подсчёт ссылок** — без GIL два потока могли бы менять счётчик одного объекта одновременно. GIL гарантирует, что байт-код выполняется только одним потоком в момент времени, защищая внутренние структуры и C-расширения.\n\nМинус: снижает эффективность **CPU-bound** задач в потоках; для параллелизма по CPU — процессы (multiprocessing) или альтернативы (PyPy, Jython).' },
  { id: 18, question: 'Поверхностная и глубокая копия', answer: '**Shallow copy** — копирует только верхний уровень (вложенные объекты — по ссылке). **Deep copy** — рекурсивно копирует все вложенные объекты.\n\nПримеры:\n  import copy\n  a = [1, [2, 3]]\n  s = copy.copy(a)      # или a.copy(), a[:]\n  d = copy.deepcopy(a)\n  s[1][0] = 99\n  print(a[1][0])       # 99 — вложенный список общий у a и s\n  d[1][0] = 100\n  print(a[1][0])       # 99 — у d свой вложенный список' },
  { id: 48, question: 'Контекстный менеджер', answer: '**Контекстный менеджер** — объект, который гарантирует **«вход»** и **«выход»** из блока кода: выделение и освобождение ресурса (файл, соединение, замок). Синтаксис **with** вызывает при входе **__enter__**, при выходе (нормальном или по исключению) — **__exit__**. Даже если внутри блока произошло исключение, **__exit__** всё равно вызывается — ресурс не «зависнет».\n\n**Использование:**\n  with open(\'file.txt\') as f:\n    data = f.read()\n  # файл закрыт после блока\n\n  with lock:\n    # только один поток здесь\n    do_work()\n  # lock отпущен\n\n**Вложенный with (несколько ресурсов):**\n  with open(\'a.txt\') as a, open(\'b.txt\') as b:\n    # оба файла открыты\n  # оба закрыты\n\n**Варианты создания:**\n\n**1. Класс с __enter__ и __exit__:**\n**__enter__(self)** — вызывается при входе в **with**; возвращаемое значение попадает в **as x**. **__exit__(self, exc_type, exc_val, exc_tb)** — вызывается при выходе из блока (нормальном или по исключению). Аргументы заполняются только если внутри **with** произошло исключение; иначе все три — **None**.\n\n**exc_type** — класс исключения (тип; то, что в **except E as e** — это E). **exc_val** — экземпляр исключения (аргумент из **raise ValueError(\'msg\')** — само исключение с сообщением). **exc_tb** — объект **traceback** (стек вызовов; полезен для логирования или повторного raise). По ним можно понять, было ли исключение и какое, и решить — логировать, подавить или пробросить дальше. Если **__exit__** возвращает **True**, исключение считается обработанным и не пробрасывается; **False** или отсутствие **return** — исключение пробрасывается дальше.\n  class Timer:\n    def __enter__(self):\n      self.start = time.perf_counter()\n      return self\n    def __exit__(self, et, ev, tb):\n      self.elapsed = time.perf_counter() - self.start\n      return False\n  with Timer() as t:\n    do_work()\n  print(t.elapsed)\n\n**2. contextlib.contextmanager (генератор):** декоратор **@contextmanager** превращает генератор в контекстный менеджер. Всё до **yield** — код «входа» (аналог __enter__); всё после **yield** — код «выхода» (аналог __exit__). Значение после **yield** попадает в **as x**.\n  from contextlib import contextmanager\n  @contextmanager\n  def managed_resource():\n    resource = acquire()   # вход\n    try:\n      yield resource\n    finally:\n      release(resource)   # выход всегда\n  with managed_resource() as r:\n    use(r)\n\n**3. contextlib.ContextDecorator:** базовый класс для контекстного менеджера, который можно использовать и как **with**, и как **декоратор** функции (весь вызов функции оборачивается в with).\n  from contextlib import ContextDecorator\n  class mycontext(ContextDecorator):\n    def __enter__(self): ...\n    def __exit__(self, *a): ...\n  @mycontext()\n  def foo(): ...\n  foo()   # как будто with mycontext(): foo()\n\n**Кратко:** контекстный менеджер — **with**; гарантия вызова **__exit__** при любом исходе; создание — класс (**__enter__**/__exit__) или **@contextmanager** (генератор с yield).' },
  { id: 49, question: 'Пространства имён в Python', answer: '**Пространство имён (namespace)** — отображение **имён на объекты**: словарь «имя переменной → ссылка на объект». В Python нет «голых» переменных — имя всегда связано с объектом в каком-то пространстве имён.\n\n**Где бывают пространства имён:** у модуля (глобальные имена модуля), у функции (локальные имена при вызове), у класса (атрибуты класса), у экземпляра (атрибуты экземпляра). Встроенные имена (**len**, **print**, **dict**) живут в пространстве **builtins**.\n\n**Порядок поиска имени (LEGB):** при обращении к имени Python ищет его в таком порядке:\n**L** — **Local** (локальное: внутри текущей функции).\n**E** — **Enclosing** (охватывающее: в объёмлющих функциях, замыкания).\n**G** — **Global** (глобальное: модуль, верхний уровень).\n**B** — **Built-in** (встроенное: len, open, Exception и т.д.).\n\nПоиск останавливается на первом совпадении. Присваивание (**x = ...**) создаёт или меняет имя в **локальном** пространстве (если нет **global**/ **nonlocal**).\n\n**global** — объявляет, что имя в функции относится к **глобальному** пространству модуля. Без **global** присваивание создало бы локальную переменную; с **global** мы меняем глобальную.\n  x = 1\n  def f():\n    global x\n    x = 2\n  f(); print(x)   # 2\n\n**nonlocal** — объявляет, что имя берётся из **ближайшего объёмлющего** пространства (не глобального). Нужен, когда во вложенной функции хотим изменить переменную внешней функции, а не создать новую локальную.\n  def outer():\n    n = 0\n    def inner():\n      nonlocal n\n      n += 1\n      return n\n    return inner\n  inc = outer(); inc(); inc()   # 1, 2\n\n**Жизненный цикл:** локальное пространство функции создаётся при **вызове** и исчезает при выходе из функции. Глобальное пространство модуля живёт пока загружен модуль. Класс и экземпляр — пока существуют объекты.\n\n**Кратко:** пространство имён — «имя → объект»; поиск по LEGB; **global** — писать в модуль, **nonlocal** — в объёмлющую функцию.' },
  { id: 19, question: 'O-нотация и сложность операций (list, dict, set)', answer: '**O-нотация** описывает **асимптотическую сложность** алгоритма по времени или памяти при росте n (размера данных). Позволяет сравнивать решения независимо от железа.\n\n**Часто встречающиеся классы сложности:**\n**Постоянное время:** O(1) — число операций не зависит от n.\n**Линейное время:** O(n) — пропорционально размеру данных.\n**Логарифмическое время:** O(log n) — при каждом шаге объём уменьшается (например, бинарный поиск).\n**Линейно-логарифмическое время:** O(n log n) — типично для эффективной сортировки.\n**Квадратичное время:** O(n²) — вложенные проходы по данным.\n\n**list:**\nдоступ по индексу — O(1); добавление в конец append — O(1); вставка/удаление по индексу — O(n); поиск in / index (при указании значения) — O(n); сортировка — O(n log n); срез [i:j] — O(j−i).\n\n**tuple / str:**\nдоступ по индексу — O(1); поиск in — O(n); неизменяемы (создание копии при «изменении» — O(n)).\n\n**dict:**\nвставка, доступ по ключу, удаление — в среднем O(1); в худшем (плохой хэш, коллизии) — O(n); итерация — O(n).\n\n**set:**\nadd, in, remove — в среднем O(1); в худшем O(n); операции над множествами (объединение, пересечение) — до O(n+m).\n\n**deque** (collections):\nappend/popleft с обоих концов — O(1); доступ по индексу в середине — O(n).' },
  { id: 20, question: 'Рекурсия', answer: '**Рекурсия** — подход, при котором функция вызывает саму себя для решения подзадачи того же типа.\n\n**Базовый случай** — условие, при котором функция возвращает результат без вызова себя (останавливает цепочку). Без него — бесконечные вызовы и **RecursionError** (в Python лимит стека вызовов).\n\n**Рекурсивный случай** — вызов себя с упрощёнными аргументами (шаг к базовому случаю).\n\nКаждый вызов кладётся в **стек вызовов**; при большой глубине возможен переполнение стека.\n\nУдобна для обхода деревьев/графов, разбиения задачи (divide and conquer), рекурсивных структур данных.\n\nПример (факториал):\n  def fact(n):\n    if n <= 1:\n      return 1\n    return n * fact(n - 1)\n  fact(4)   # 24' },
  { id: 21, question: 'ORM', answer: '**ORM** (Object Relational Mapping) связывает **объектную модель** приложения с **реляционной моделью** БД.\n\nСкрывает SQL-логику за Python-объектами: модели (таблицы), запросы, связи (FK, many-to-many).\n\n**Популярные ORM в Python:**\n**Django ORM** (в составе Django), **SQLAlchemy** (универсальная, часто с Flask/FastAPI), **Peewee** (лёгкая), **Tortoise ORM** (async), **Pony ORM**, **SQLObject**.' },
  { id: 22, question: 'Миграции', answer: '**Миграции** — механизм **версионирования схемы БД**, позволяющий безопасно изменять структуру таблиц (создание, изменение, удаление). Файлы миграций хранят историю изменений; применяются по порядку (вверх/откат).\n\n**Инструменты:** **Django** (встроенные миграции, `manage.py migrate`), **Alembic** (для SQLAlchemy), **Flask-Migrate** (Alembic под Flask), **Tortoise ORM** (aerich), **Peewee** (встроенный migrator).' },
  { id: 23, question: 'Транзакция', answer: '**Транзакция** — последовательность операций с БД, которая выполняется как **единое целое**: либо все операции применяются (**COMMIT**), либо все отменяются (**ROLLBACK**). Гарантирует **атомарность**: при ошибке или явном откате изменения не частично сохраняются.\n\nОбычный цикл: **BEGIN** (начало транзакции) → операции (INSERT, UPDATE, DELETE, SELECT) → **COMMIT** (подтвердить) или **ROLLBACK** (отменить). В многих драйверах и ORM транзакция начинается неявно при первом запросе; autocommit может быть включён по умолчанию (каждый запрос — отдельная транзакция).\n\nИспользуют, когда несколько операций должны быть выполнены вместе: перевод между счетами, создание заказа с позициями, обновление связанных таблиц. Без транзакции сбой посередине оставит БД в несогласованном состоянии.' },
  { id: 24, question: 'ACID', answer: '**ACID** — набор гарантий корректности транзакций в БД.\n\n**Атомарность (Atomicity):** транзакция выполняется целиком или не выполняется вовсе. Пример: перевод денег A→B — списание с A и зачисление на B либо оба шага, либо откат обоих; нельзя «списали с A, упало до зачисления на B».\n\n**Согласованность (Consistency):** после транзакции БД остаётся в допустимом состоянии: соблюдаются ограничения, ключи, инварианты и **связи между таблицами** (FK, CHECK). Пример: сумма на счетах до и после перевода не меняется.\n\n**Изолированность (Isolation):** параллельные транзакции не «видят» незакоммиченные изменения друг друга; результат как при некотором порядке выполнения.\n\n**Уровни изоляции** (от слабого к сильному):\n**READ UNCOMMITTED** — видны даже незакоммиченные данные (грязное чтение).\n\n**READ COMMITTED** — видны только закоммиченные; повторное чтение той же строки может дать другое значение (неповторяемое чтение).\n\n**REPEATABLE READ** — в рамках транзакции повторный запрос возвращает те же строки; возможны фантомы (новые строки, появившиеся в другой транзакции).\n\n**SERIALIZABLE** — строгая изоляция, как будто транзакции выполняются по одной; фантомов нет. Чем выше уровень, тем строже изоляция и обычно ниже параллелизм.\n\n**По умолчанию в популярных БД:** **PostgreSQL** — READ COMMITTED. **MySQL** (InnoDB) — REPEATABLE READ. **SQL Server**, **Oracle** — READ COMMITTED.\n\n**Надёжность (Durability):** закоммиченные данные сохраняются при сбое (журнал, WAL). Пример: после COMMIT данные не пропадут при отключении питания.' },
  { id: 25, question: 'Индексирование БД', answer: '**Индексирование** — создание дополнительных структур данных (**индексов**) для ускорения **поиска**, **фильтрации** и **сортировки** по столбцам. Индекс хранит значения столбца(ов) и ссылки на строки таблицы; **хранится в той же БД на диске** — в отдельных файлах/структурах, которыми управляет СУБД (таблица с данными не дублируется). Запросы по индексированным полям выполняются быстрее (часто без полного скана таблицы). Плата: замедление вставки/обновления/удаления и дополнительное место на диске.\n\n**Типы индексов:**\n\n**B-tree** — сбалансированное дерево; **по умолчанию** в PostgreSQL, MySQL, SQLite. Поддерживает **диапазоны** (<, <=, =, >=, >, BETWEEN) и **ORDER BY** по индексированным столбцам. Универсальный выбор для фильтрации и сортировки. Составной индекс (несколько столбцов) полезен, когда запросы фильтруют/сортируют по ним в одном порядке.\n\n**Hash** — индекс по **хэшу** значения. Подходит только для **точечного поиска** (WHERE col = value); не поддерживает диапазоны и сортировку. В PostgreSQL с версии 10; в MySQL — для движка MEMORY. Обычно B-tree не хуже, Hash имеет смысл при очень частом поиске по равенству.\n\n**GiST** (Generalized Search Tree) — обобщённое дерево поиска. Подходит для **геоданных** (точки, прямоугольники, «ближайшие N»), **полнотекстового поиска**, диапазонов типов. Гибкий, но для простого равенства по числу/строке чаще берут B-tree.\n\n**GIN** (Generalized Inverted Index) — **инвертированный** индекс: по «элементу» хранятся ссылки на строки. Подходит для **полнотекста**, **массивов** (WHERE arr содержит элемент), **JSONB** (содержит ключ/значение). Много записей на один ключ — типично для «содержит» / «входит в».\n\n**BRIN** (Block Range Index) — хранит **min/max** значений по **блокам** таблицы (а не по каждой строке). Занимает мало места; удобен для **очень больших** таблиц с **естественным порядком** по столбцу (время, монотонный id). Запрос по диапазону такого столбца отсекает целые блоки без их чтения. Не заменяет B-tree, если нужна точная выборка по разбросанным значениям.\n\n**Кратко по типам:** B-tree — основной универсальный; Hash — только =; GiST/GIN — полнотекст, гео, массивы, JSONB; BRIN — большие таблицы с упорядоченными данными.\n\n**Реализация в БД:** **PostgreSQL** — B-tree по умолчанию, hash, GiST, GIN, BRIN, частичные и составные индексы. **MySQL** — B-tree (InnoDB), hash для MEMORY. **SQLite** — B-tree. **MongoDB** — B-tree по умолчанию, hash, гео, полнотекст. Конкретный синтаксис (CREATE INDEX, опции) зависит от СУБД.' },
  { id: 37, question: 'Шардирование', answer: '**Шардирование** — когда одну большую таблицу **разносят по разным серверам (БД)**. Каждый сервер хранит свою часть строк — это и есть **шард**. По какой строке куда попадёт — решают по правилу: например, по **user_id** (все заказы пользователя на одном шарде), по региону или по хэшу от ключа.\n\n**Какое бывает (по способу выбора шарда):**\n**По диапазону (range)** — ключ попадает в диапазон (user_id 1–1M → шард 1, 1M–2M → шард 2). Просто, но возможен дисбаланс.\n**По хэшу (hash)** — шард = hash(key) % N. Равномерное распределение; минус — добавление шарда ведёт к ребалансировке.\n**По справочнику (directory)** — отдельная таблица/сервис «ключ → шард». Гибко, но лишний запрос и единая точка.\n**По региону (geo)** — шард по стране/дата-центру. Удобно для локалитета и регуляторики; возможен дисбаланс по регионам.\n\n**Зачем:** одна машина не тянет ни объём данных, ни нагрузку. Разнесли по шардам — каждый сервер обрабатывает меньше данных и запросов.\n\n**Минусы:** запрос «посчитать по всем пользователям» или JOIN по данным с разных шардов — сложно: нужно ходить на несколько серверов и потом склеивать результат. Добавить новый шард и переразложить данные (ребалансировка) — тоже нетривиально. Транзакции и внешние ключи между разными шардами из коробки не работают. Обычно шардируют по полю, которое чаще всего в запросах (например, user_id), чтобы максимум запросов шло в один шард.' },
  { id: 38, question: 'Партиционирование', answer: '**Партиционирование** — когда одну таблицу **делят на части (партиции)** по правилу, но все части остаются **в одной и той же БД** на одном сервере. Для приложения это по-прежнему одна таблица — просто внутри СУБД данные лежат кусками: например, по месяцам (январь — одна партиция, февраль — другая), по списку регионов или по хэшу.\n\n**Зачем:** запрос «данные за март» — БД открывает только партицию марта, а не сканирует всю таблицу. Удалить старые данные — просто отбросить партицию (DROP), без тяжёлого DELETE по гигантской таблице.\n\n**Чем отличается от шардирования:** партиции — это **всё ещё один сервер, одна БД**; шарды — это **разные серверы**. Партиционирование есть в PostgreSQL (RANGE, LIST, HASH), MySQL, Oracle и др.' },
  { id: 39, question: 'Репликация БД', answer: '**Репликация** — когда **одни и те же данные** хранятся на **нескольких серверах (репликах)**. Изменения с одного сервера копируются на остальные, чтобы везде была актуальная копия.\n\n**Зачем:** **отказоустойчивость** — если один сервер упал, можно переключиться на реплику. **Масштабирование чтения** — запросы на чтение раздают по репликам, основная БД разгружается. **Геораспределение** — копия ближе к пользователям, меньше задержка.\n\n**Как устроено:** обычно один сервер — **primary (master)** — принимает запись; остальные — **реплики (replicas)** — получают изменения и обслуживают чтение. Репликация бывает **синхронная** (запись подтверждается только когда данные попали на реплику — надёжнее, но медленнее) и **асинхронная** (реплика догоняет позже — быстрее, но при падении primary можно потерять последние изменения).\n\n**Отличие от шардирования и партиционирования:** при репликации на всех узлах **одни и те же данные**; при шардировании и партиционировании данные **разделены** между узлами или партициями.' },
  { id: 26, question: 'REST', answer: '**REST** (Representational State Transfer) — **архитектурный стиль** построения API поверх **HTTP**. Идея: всё — **ресурсы**, доступные по **URI**; клиент работает с ними через стандартные **HTTP-методы** и получает **представление** (JSON, XML и т.д.).\n\n**Принципы:**\n**Без состояния (stateless)** — сервер не хранит состояние клиента между запросами. Каждый запрос самодостаточен (все нужные данные в заголовках, URI, теле). Сессии и контекст — на стороне клиента или в токене.\n\n**Единообразный интерфейс** — один и тот же набор операций (GET, POST, PUT, PATCH, DELETE) для разных ресурсов. **GET** — получить ресурс (идемпотентный). **POST** — создать или действие (не идемпотентный). **PUT** — заменить целиком (идемпотентный). **PATCH** — частичное обновление. **DELETE** — удалить (идемпотентный).\n\n**Ресурсы по URI** — каждый объект имеет адрес, например `/users/1`, `/orders`. Иерархия и имя не обязаны совпадать с внутренней структурой БД — это контракт API. **URI и URL:** **URI** — общий идентификатор ресурса (имя или адрес). **URL** — подмножество URI: идентификатор, по которому можно **получить** ресурс (схема, хост, путь, например https://api.example.com/users/1). Каждый URL является URI; не каждый URI — URL (например, urn:isbn:0-393-04002-X — URI, но не URL).\n\n**Коды ответа** — сервер сообщает результат числом: **2xx** — успех (200 OK, 201 Created), **3xx** — перенаправление, **4xx** — ошибка клиента (400, 404, 401), **5xx** — ошибка сервера.' },
  { id: 27, question: 'Этапы работы HTTP', answer: '**1. DNS-запрос** — браузер или клиент по имени хоста (например, example.com) запрашивает у DNS **IP-адрес** сервера. Ответ кэшируется на разных уровнях (ОС, роутер, DNS-сервер).\n\n**2. Установка соединения** — по полученному IP открывается **TCP-**соединение с портом (обычно 80 для HTTP, 443 для HTTPS). **Трёхстороннее рукопожатие** (SYN, SYN-ACK, ACK) устанавливает надёжный канал.\n\n**3. TLS (если HTTPS)** — **handshake** между клиентом и сервером: согласование версии и шифров, проверка сертификата, обмен ключами. Дальше трафик шифруется.\n\n**4. HTTP-запрос** — клиент отправляет **строку запроса** (метод, URI, версия HTTP), **заголовки** (Host, User-Agent, Cookie, Content-Type и др.) и при необходимости **тело** (body) — например, JSON для POST.\n\n**5. Обработка на сервере** — веб-сервер принимает запрос, приложение (бэкенд) формирует ответ: читает БД, выполняет логику, собирает данные.\n\n**6. HTTP-ответ** — сервер возвращает **статус-код** (200, 404, 500 и т.д.), **заголовки** (Content-Type, Set-Cookie, Cache-Control и др.) и **тело ответа** (HTML, JSON, файл).\n\n**7. Закрытие или повторное использование** — соединение закрывается (HTTP/1.0) или остаётся открытым для следующих запросов (**keep-alive**, HTTP/1.1). Клиент разбирает ответ (рендер страницы, разбор JSON) и при необходимости делает новые запросы.' },
  { id: 28, question: 'Сериализация и десериализация', answer: '**Сериализация** — преобразование объектов в памяти в **формат для передачи или хранения** (строка, байты): JSON, XML, pickle и т.д.\n\n**Десериализация** — обратный процесс: из строки или байт снова получают объект в памяти.\n\n**Пример (JSON в Python):**\n  import json\n  data = {"name": "Alice", "age": 30}\n  json_str = json.dumps(data)   # сериализация: объект → строка\n  restored = json.loads(json_str)  # десериализация: строка → объект\n\n**Другие форматы:** **pickle** — сериализация любых Python-объектов в байты (использовать только для доверенных данных). **XML** — текстовый формат с тегами. В веб-API чаще всего **JSON**.' },
  { id: 29, question: 'Популярные веб-протоколы и их применение', answer: '**HTTP/1.1** — запрос–ответ по одному соединению, текст. **Применение:** обычные страницы, REST API.\n\n**HTTPS** — HTTP поверх **TLS**: шифрование и проверка сервера. **Применение:** любой трафик, где нужна конфиденциальность.\n\n**FTP** — протокол **передачи файлов**; отдельные каналы для управления (порт 21) и данных. **Применение:** загрузка и скачивание файлов на сервер (хостинг, бэкапы), публичные файловые архивы. Часто заменяют на **SFTP** (поверх SSH) или передачу по **HTTPS** из соображений безопасности (FTP передаёт пароль открытым текстом).\n\n**HTTP/2** — мультиплексирование потоков в одном TCP-соединении, сжатие заголовков. **Применение:** ускорение загрузки сайтов и API.\n\n**HTTP/3 (QUIC)** — поверх **UDP**, встроенное шифрование, быстрый handshake. **Применение:** низкая задержка, нестабильные сети, стриминг.\n\n**WebSocket** — постоянное **двустороннее** соединение (сначала HTTP-upgrade). **Применение:** чаты, уведомления в реальном времени, онлайн-игры.\n\n**gRPC** — RPC поверх HTTP/2, бинарный формат (часто **Protobuf**). **Применение:** микросервисы, стриминг, внутренние API.\n\n**BitTorrent** — **P2P**-протокол обмена файлами: участники (пиры) обмениваются **чанками** по TCP. Найти пиров можно через **трекер** (центральный сервер «раздача → список пиров») или через **DHT** (Distributed Hash Table) — распределённая сеть узлов без центра: каждый узел хранит часть соответствий «раздача → пиры», запрос рассылается по узлам и возвращает список пиров. **Применение:** распределённая раздача больших файлов (образы ОС, обновления, медиа).\n\n**TCP (транспорт):** надёжная доставка и порядок пакетов; под капотом у HTTP/1, HTTP/2, WebSocket, gRPC.\n\n**UDP (транспорт):** без гарантий доставки, быстрее; используется в QUIC (HTTP/3), стриминге, DNS.' },
  { id: 30, question: 'Библиотека VS фреймворк', answer: '**Библиотека** — набор функций или классов, которые **вы вызываете**, когда нужно. Поток выполнения определяет ваш код: вы решаете, когда вызвать библиотеку и что делать с результатом. Библиотека — **инструмент** в ваших руках.\n\n**Фреймворк** — задаёт **каркас приложения**: точки входа, жизненный цикл, структуру. Ваш код **подключается** в нужные места (обработчики, хуки, конфигурация), а **фреймворк вызывает** ваш код в нужный момент. Управление потоком у фреймворка — это **инверсия управления** (IoC): не вы вызываете фреймворк, а он вас («Don\'t call us, we\'ll call you»).\n\n**Аналогия:** библиотека — ящик с инструментами, вы берёте отвёртку, когда она нужна. Фреймворк — каркас дома: вы заполняете комнаты (пишете обработчики), но когда открывать дверь или включать свет — решает каркас (события, запросы).\n\n**Примеры:** **библиотеки** — requests, lodash, json, pytest (как набор утилит). **Фреймворки** — Django, Flask (для веба), React/Vue (каркас UI), Spring (для Java).' },
  { id: 31, question: 'SOLID', answer: '**SOLID** — пять принципов проектирования, которые повышают гибкость и поддерживаемость кода.\n\n**S — Single Responsibility (единственная ответственность):** класс должен иметь **одну причину для изменения**. Одна задача, одна зона ответственности. Если класс делает и отчёты, и рассылку, и сохранение в БД — при изменении одного из аспектов придётся трогать один и тот же класс; лучше разнести по разным классам.\n\n**O — Open/Closed (открыт для расширения, закрыт для модификации):** поведение расширяют **новым кодом** (наследование, композиция), а не правкой существующего. Добавляем новый тип — новый класс/модуль; старый код остаётся без изменений. Снижает риск поломать уже работающее.\n\n**L — Liskov Substitution (подстановка Лисков):** подкласс должен быть **заменяем** на базовый класс без нарушения контракта. Клиент, работающий с базовым типом, не должен «удивляться», если подставят наследника: пред- и постусловия, инварианты сохраняются. Нарушение: наследник бросает исключения, которые базовый не бросает, или сужает допустимое поведение.\n\n**I — Interface Segregation (разделение интерфейсов):** клиент не должен зависеть от методов, которые не использует. Лучше **несколько узких интерфейсов**, чем один «толстый». Иначе классы вынуждены реализовывать пустые или лишние методы.\n\n**D — Dependency Inversion (инверсия зависимостей):** зависимости должны быть от **абстракций**, а не от конкретных реализаций. Высокоуровневый модуль не должен импортировать низкоуровневый напрямую; оба зависят от интерфейса (абстрактного класса, протокола). Упрощает подмену реализаций, тестирование, смену инфраструктуры.' },
  { id: 32, question: 'GOF23: Порождающие паттерны (Creational)', answer: '**Порождающие паттерны** отвечают за создание объектов и снижают зависимость кода от конкретных классов.\n\n**Singleton** — один экземпляр класса на всё приложение; глобальная точка доступа.\n  class Singleton:\n    _instance = None\n    def __new__(cls):\n      if cls._instance is None:\n        cls._instance = super().__new__(cls)\n      return cls._instance\n\n**Factory Method** — создание объекта делегируется подклассам; клиент работает с абстрактным типом.\n  class Creator:\n    def factory_method(self): raise NotImplementedError\n    def use(self): return self.factory_method().do()\n  class ConcreteCreator(Creator):\n    def factory_method(self): return ConcreteProduct()\n\n**Abstract Factory** — создание семейства связанных продуктов без привязки к конкретным классам.\n  class GUIFactory:\n    def create_button(self): raise NotImplementedError\n    def create_checkbox(self): raise NotImplementedError\n  class WinFactory(GUIFactory): ...  # WinButton, WinCheckbox\n\n**Builder** — пошаговая сборка сложного объекта; один процесс — разные представления.\n  class Builder:\n    def set_a(self, x): self.a = x; return self\n    def set_b(self, x): self.b = x; return self\n    def build(self): return Product(self.a, self.b)\n  p = Builder().set_a(1).set_b(2).build()\n\n**Prototype** — копирование существующего объекта вместо создания через конструктор.\n  import copy\n  class Prototype:\n    def clone(self): return copy.deepcopy(self)' },
  { id: 33, question: 'GOF23: Структурные паттерны (Structural)', answer: '**Структурные паттерны** показывают, как собирать объекты и классы в более крупные структуры.\n\n**Adapter** — превращает интерфейс одного класса в другой, ожидаемый клиентом; интеграция несовместимого API.\n  class OldAPI: def specific_request(self): return "data"\n  class Adapter:\n    def __init__(self): self.old = OldAPI()\n    def request(self): return self.old.specific_request()\n\n**Decorator** — обёртка добавляет поведение без изменения класса; динамическое расширение.\n  def decorator(func):\n    def wrap(*a, **k): print("before"); r = func(*a,**k); print("after"); return r\n    return wrap\n  @decorator\ndef foo(): pass\n\n**Facade** — единый упрощённый интерфейс к подсистеме; скрывает сложность.\n  class SubsystemA: def run(self): ...\n  class Facade:\n    def __init__(self): self.a, self.b = SubsystemA(), SubsystemB()\n    def do_all(self): self.a.run(); self.b.run()\n\n**Proxy** — объект-заместитель контролирует доступ к реальному (ленивая инициализация, кэш, защита).\n  class Proxy:\n    def __init__(self): self._real = None\n    def request(self):\n      if self._real is None: self._real = RealSubject()\n      return self._real.request()\n\n**Composite** — композиция в древовидную структуру; к узлам и группам обращаются одинаково.\n  class Component: def operation(self): raise NotImplementedError\n  class Leaf(Component): def operation(self): return "Leaf"\n  class Composite(Component):\n    def __init__(self): self.children = []\n    def add(self, c): self.children.append(c)\n    def operation(self): return [c.operation() for c in self.children]\n\n**Bridge** — разделение абстракции и реализации, чтобы они могли меняться независимо.\n  class Implementor: def op(self): raise NotImplementedError\n  class Abstraction: def __init__(self, impl): self.impl = impl\n  def run(self): return self.impl.op()\n\n**Flyweight** — общее состояние вынесено; множество объектов делят его — экономия памяти.\n  class Flyweight:\n    _pool = {}\n    def __new__(cls, key): return cls._pool.setdefault(key, super().__new__(cls))' },
  { id: 40, question: 'Методы сортировки', answer: '**Bubble Sort (пузырьковая):** попарное сравнение соседних элементов, больший «всплывает» в конец. **O(n²)**. Стабильная, in-place. На практике почти не используют.\n  def bubble_sorting(arr: list[int]) -> list[int]:\n    is_changed = True\n    while is_changed:\n      is_changed = False\n      for n in range(len(arr) - 1):\n        if arr[n] > arr[n + 1]:\n          arr[n], arr[n + 1] = arr[n + 1], arr[n]\n          is_changed = True\n    return arr\n\n**Selection Sort (выбором):** на каждом шаге ищем минимум в неотсортированной части и ставим на текущую позицию. **O(n²)**. Не стабильная, in-place.\n  def selection(a):\n    for i in range(len(a)):\n      m = min(range(i, len(a)), key=lambda k: a[k])\n      a[i], a[m] = a[m], a[i]\n    return a\n\n**Insertion Sort (вставками):** по одному элементу вставляем в уже отсортированную часть на нужное место. **O(n²)** в общем, **O(n)** для почти отсортированных. Стабильная, in-place.\n  def insertion(a):\n    for i in range(1, len(a)):\n      j = i\n      while j > 0 and a[j - 1] > a[j]:\n        a[j], a[j - 1] = a[j - 1], a[j]\n        j -= 1\n    return a\n\n**Quick Sort (быстрая):** pivot, делим на «меньше» и «больше», рекурсия. **O(n log n)** в среднем, **O(n²)** в худшем. Не стабильная, in-place.\n  def quick(a):\n    if len(a) <= 1: return a\n    p = a[len(a) // 2]\n    left = [x for x in a if x < p]\n    mid = [x for x in a if x == p]\n    right = [x for x in a if x > p]\n    return quick(left) + mid + quick(right)\n\n**Merge Sort (слиянием):** делим пополам, рекурсия, сливаем два отсортированных подмассива. **O(n log n)**. Стабильная. **O(n)** доп. памяти.\n  def merge_sort(a):\n    if len(a) <= 1: return a\n    m = len(a) // 2\n    L, R = merge_sort(a[:m]), merge_sort(a[m:])\n    out, i, j = [], 0, 0\n    while i < len(L) and j < len(R):\n      if L[i] <= R[j]: out.append(L[i]); i += 1\n      else: out.append(R[j]); j += 1\n    return out + L[i:] + R[j:]\n\n**Heap Sort (пирамидальная):** строим кучу, извлекаем максимум, перестраиваем. **O(n log n)**. Не стабильная, in-place.\n  import heapq\n  def heap_sort(a):\n    heapq.heapify(a)\n    return [heapq.heappop(a) for _ in range(len(a))]' },
  { id: 42, question: 'Многопоточность и многопроцессорность', answer: '**Многопоточность (threading)** — несколько **потоков** в рамках **одного процесса**. Потоки делят общую память; переключение между ними легче, чем между процессами.\n\nВ **CPython** потоки ограничены **GIL**: в каждый момент выполняется байт-код только одного потока. Поэтому многопоточность даёт выигрыш в основном для **I/O-bound** задач (сеть, диск, ожидание ответа), где поток отдаёт GIL во время ожидания. Для **CPU-bound** (тяжёлые вычисления) потоки не ускоряют выполнение.\n\n**Многопроцессорность (multiprocessing)** — несколько **процессов**, у каждого свой интерпретатор и своя память. GIL действует только внутри одного процесса, поэтому процессы реально выполняют код параллельно на разных ядрах. Подходит для **CPU-bound** задач.\n\n**Плата за процессы:** больше потребление памяти; данные между процессами нужно передавать явно (сериализация, очереди, разделяемая память).\n\n**Когда что использовать:**\n**I/O-bound** (запросы к API, чтение файлов) — **threading** или **asyncio** (асинхронность в одном потоке).\n**CPU-bound** (обработка данных, расчёты) — **multiprocessing**.\n\n**Примеры в Python:**\n  import threading\n  t = threading.Thread(target=func, args=(a, b))\n  t.start(); t.join()\n\n  from multiprocessing import Process\n  p = Process(target=func, args=(a, b))\n  p.start(); p.join()' },
  { id: 43, question: 'Asyncio VS Threading VS Multiprocessing', answer: '**Асинхронность (asyncio)** — один поток, **кооперативная** многозадачность: корутины по очереди выполняют код и явно отдают управление (**await**). Пока одна корутина ждёт I/O, другие работают. Нет переключения контекста ОС и нет GIL-конфликтов между «потоками» — всё в одном потоке.\n\n**Многопоточность (threading)** — несколько потоков ОС в одном процессе; ОС переключает их. В CPython ограничены GIL, но при I/O поток отпускает GIL, поэтому для I/O-bound threading тоже полезен.\n\n**Когда выбирать asyncio:**\nМного **одновременных I/O-операций** (сотни/тысячи соединений, сокеты, HTTP-клиенты, очереди). Один поток, мало памяти на «поток», один event loop. Нужна поддержка **async/await** в коде и библиотеках (**aiohttp**, **asyncpg** и т.д.).\n\n**Когда выбирать threading:**\nУмеренное число I/O-задач; код или библиотеки **не асинхронные** (синхронные API). Проще внедрить без переписывания на async. Подходит, когда блокирующие вызовы уже есть и их не хочется менять.\n\n**Когда multiprocessing:**\n**CPU-bound** задачи (расчёты, обработка данных) — ни asyncio, ни threading не дадут прироста по CPU; только отдельные процессы.\n\n**Кратко:** I/O-bound, много соединений, готовы писать async — **asyncio**. I/O-bound, синхронный код, немного потоков — **threading**. CPU-bound — **multiprocessing**.' },
  { id: 44, question: 'Как устроено асинхронное программирование?', answer: '**Асинхронное программирование** — выполнение кода в **одном потоке** с **кооперативной** многозадачностью: задачи сами отдают управление в точках ожидания, вместо того чтобы поток блокировался.\n\n**Event loop (цикл событий)** — ядро: бесконечный цикл, который держит очередь готовых к выполнению **корутин** и обрабатывает события I/O (сокеты, таймеры). Когда корутина делает **await** на операции ввода-вывода, она «засыпает», event loop переключается на другую корутину; когда I/O завершён, первая снова попадает в очередь.\n\n**Корутина vs таска:**\n**Корутина** — объект, который возвращается при **вызове** функции **async def** (выполнение ещё не началось). Это «обещание» результата; чтобы корутина пошла в event loop, её нужно либо **await**-ить, либо обернуть в **таск**.\n\n**Таска (asyncio.Task)** — корутина, **уже запланированная** в event loop. Создаётся через **asyncio.create_task(coro)**. Таска начинает выполняться «в фоне»: loop переключается на неё без явного await в этом месте. **await task** — дождаться результата. Несколько тасок позволяют выполнять корутины **параллельно** (конкурентно) в одном потоке.\n\n**Футура (asyncio.Future)** — низкоуровневый объект-«**обещание**» результата: результат будет позже, пока Future в состоянии «ожидание». Когда операция завершена, в Future кладут результат (**set_result**) или исключение (**set_exception**); все, кто ждёт эту Future (**await future**), просыпаются и получают результат. **Таска** — подкласс Future: обёртка над корутиной, которая сама «заполняет» Future по завершении корутины. В коде чаще используют **create_task** и **await**; саму **Future** создают редко (например, при интеграции callback-библиотек с event loop).\n\n**Кратко:** корутина — это «что выполнять»; таска — «запущенная» корутина в loop, по которой можно ждать и отменять.\n\n**Простой пример:**\n  import asyncio\n  async def say_after(delay, text):\n    await asyncio.sleep(delay)\n    print(text)\n  async def main():\n    await say_after(1, \"hello\")\n    await say_after(1, \"world\")\n  asyncio.run(main())   # через 1 с hello, ещё через 1 с world\n\n**Параллельный запуск (таски):**\n  async def main():\n    t1 = asyncio.create_task(say_after(1, \"hello\"))\n    t2 = asyncio.create_task(say_after(1, \"world\"))\n    await t1\n    await t2\n  asyncio.run(main())   # через ~1 с оба сообщения\n\n**С gather():**\n  async def main():\n    await asyncio.gather(say_after(1, \"hello\"), say_after(1, \"world\"))\n  asyncio.run(main())   # через ~1 с оба сообщения; gather ждёт все корутины и возвращает список результатов\n\n**Неблокирующий I/O** — сокеты, HTTP-клиенты в asyncio отдают управление loop во время ожидания. Блокирующий код в корутине (обычный **time.sleep**, синхронные файлы) задерживает весь loop — используют **run_in_executor()** или async-аналоги (**asyncio.sleep**, aiofiles).' },
  { id: 45, question: 'Примитивы asyncio: Lock, Event, Semaphore, Queue', answer: '**Примитивы** — объекты для **координации** корутин: кто-то ждёт, кто-то сигналит или отпускает замок. Все операции **async** — не блокируют поток, отдают управление в event loop.\n\n**Lock (замок)** — **мьютекс**: в один момент замок держит только **одна** корутина. Остальные ждут **lock.acquire()** (или **async with lock**). Нужен, когда несколько корутин обращаются к **общему ресурсу** (файл, переменная) и важно, чтобы кусок кода выполнялся без вклинивания других.\n  lock = asyncio.Lock()\n  async def safe_update():\n    async with lock:\n      # только одна корутина здесь одновременно\n      shared_data.append(1)\n\n**Event (событие)** — **флаг**: изначально «не поднят». Одна корутина вызывает **event.set()** — «готово»; все, кто ждёт **event.wait()**, просыпаются. Удобно, когда одна задача что-то подготовила (загрузка, инициализация), а остальные должны подождать этого момента.\n  ready = asyncio.Event()\n  async def loader():\n    await load_config()\n    ready.set()\n  async def worker():\n    await ready.wait()\n    # конфиг уже загружен\n\n**Semaphore (семафор)** — **счётчик** одновременных «входов». Создаётся с лимитом: **Semaphore(3)** — не больше трёх корутин одновременно в защищённом участке. Остальные ждут **sem.acquire()** (или **async with sem**). Используют, чтобы **ограничить** нагрузку: не больше N запросов к API, не больше N соединений к БД.\n  sem = asyncio.Semaphore(2)\n  async def limited_request():\n    async with sem:\n      await do_http_request()\n  # максимум 2 запроса одновременно\n\n**Queue (очередь)** — **очередь сообщений** между корутинами. Одни кладут **await queue.put(item)**, другие забирают **item = await queue.get()**. Если очередь пуста, **get()** ждёт; если полна (при maxsize), **put()** ждёт. Классическая схема **производитель–потребитель**: воркеры обрабатывают задачи из общей очереди без явных замков.\n  q = asyncio.Queue(maxsize=10)\n  async def producer():\n    for i in range(5):\n      await q.put(i)\n  async def consumer():\n    while True:\n      x = await q.get()\n      if x is None: break\n      await process(x)\n  async def main():\n    await asyncio.gather(producer(), consumer())\n\n**Кратко:** **Lock** — один владелец ресурса. **Event** — «сигнал готовности» для многих. **Semaphore** — не больше N одновременно. **Queue** — передача данных между корутинами с ожиданием.' },
  { id: 46, question: 'Полезные методы asyncio', answer: '**asyncio.run(coro)** — точка входа: создаёт event loop, запускает переданную корутину, по завершении закрывает loop. Один вызов на программу (или на «островок» asyncio). Не использовать внутри уже запущенного loop.\n  async def main():\n    await asyncio.sleep(1)\n  asyncio.run(main())\n\n**asyncio.create_task(coro)** — планирует корутину в текущем loop и возвращает **Task**. Задача начинает выполняться «сразу» (конкурентно). **await task** — дождаться результата. Без create_task корутина не пойдёт параллельно с другими.\n  t = asyncio.create_task(fetch(url))\n  result = await t\n\n**asyncio.gather(*aws, return_exceptions=False)** — запускает несколько корутин **параллельно** и ждёт все. Возвращает **список результатов** в порядке аргументов. Если **return_exceptions=True**, исключения возвращаются как значения, а не пробрасываются.\n  results = await asyncio.gather(fetch(u1), fetch(u2), fetch(u3))\n  # results = [r1, r2, r3]\n\n**asyncio.sleep(delay)** — неблокирующая пауза: отдаёт управление в loop на указанное время. В отличие от **time.sleep** не блокирует поток.\n  await asyncio.sleep(2)\n\n**asyncio.wait_for(aw, timeout)** — ждёт одну корутину/таску, но не дольше **timeout** секунд. При превышении — **asyncio.TimeoutError**; сама задача при этом отменяется (**cancel**). Удобно для «запрос с таймаутом».\n  try:\n    result = await asyncio.wait_for(slow_request(), timeout=5.0)\n  except asyncio.TimeoutError:\n    print(\"таймаут\")\n\n**asyncio.wait(aws, return_when=...)** — ждёт набор задач; возвращает два множества: **(done, pending)**. **return_when**: **ALL_COMPLETED** (все), **FIRST_COMPLETED** (хотя бы одна), **FIRST_EXCEPTION** (одна завершилась исключением). Pending-задачи нужно при желании отменить.\n  done, pending = await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)\n  for t in pending:\n    t.cancel()\n\n**asyncio.to_thread(func, *args)** — выполняет **синхронную** функцию в отдельном потоке (пуле по умолчанию), не блокируя event loop. Возвращает результат. Python 3.9+.\n  result = await asyncio.to_thread(blocking_io, arg)\n\n**loop.run_in_executor(executor, func, *args)** — то же по смыслу: выполнить func в executor (например **None** — пул потоков по умолчанию). Возвращает Future, которую можно **await**.\n  loop = asyncio.get_event_loop()\n  result = await loop.run_in_executor(None, heavy_calc, data)\n\n**asyncio.shield(aw)** — «защита» от отмены: если отменяют внешнюю задачу (например gather), то **shield**-обёртка отменяется, а внутренняя задача продолжает выполняться. Нужно, когда одну задачу не должны отменить вместе с остальными.\n  await asyncio.gather(asyncio.shield(critical_task()), other_task())\n  # отмена gather не отменит critical_task\n\n**task.cancel()** — запрос на отмену таски. Таска получит **CancelledError** в точке следующего await. **await** отменённой таски пробрасывает **CancelledError**.\n  t = asyncio.create_task(long_running())\n  t.cancel()\n  try:\n    await t\n  except asyncio.CancelledError:\n    pass' },
  { id: 47, question: 'Async for и async with', answer: '**async for** — асинхронная итерация: перебираем объект, у которого **каждый следующий элемент** получается через **await** (например, чтение из потока по кускам, строки из async-файла). Обычный **for** ждёт синхронно; **async for** отдаёт управление в event loop на каждом шаге.\n\nОбъект должен быть **асинхронным итератором**: реализовать **__aiter__** (возвращает self или другой async iterator) и **__anext__** (async-метод: возвращает следующее значение или выбрасывает **StopAsyncIteration**). Встроенные **aiter()** и **anext()** работают с такими объектами.\n\n**Пример (async for по асинхронному итератору):**\n  class AsyncRange:\n    def __init__(self, n): self.n = n; self.i = 0\n    def __aiter__(self): return self\n    async def __anext__(self):\n      if self.i >= self.n: raise StopAsyncIteration\n      i = self.i; self.i += 1\n      await asyncio.sleep(0)\n      return i\n  async def main():\n    async for x in AsyncRange(3):\n      print(x)  # 0, 1, 2\n  asyncio.run(main())\n\n**Типичное применение:** чтение из **StreamReader** (asyncio), построчное чтение через **aiofiles**, перебор страниц API с пагинацией.\n\n**async with** — асинхронный контекстный менеджер: **вход** и **выход** из контекста — корутины. При входе вызывается **await obj.__aenter__()**, при выходе (нормальном или по исключению) — **await obj.__aexit__(...)**. Используют для ресурсов, которые нужно **асинхронно** открывать и закрывать: соединение к БД, сокет, **Lock**, транзакция.\n\n**Пример (async with Lock):**\n  lock = asyncio.Lock()\n  async def safe_work():\n    async with lock:\n      # только одна корутина здесь\n      await do_work()\n  # при выходе lock автоматически отпускается\n\n**Пример (async with соединение):**\n  async with aiohttp.ClientSession() as session:\n    async with session.get(url) as resp:\n      data = await resp.json()\n  # сессия и ответ закрываются после блока\n\n**Кратко:** **async for** — перебор по одному элементу с **await** на каждом шаге; объект с **__aiter__** и **__anext__**. **async with** — асинхронное «вход/выход» по **__aenter__** и **__aexit__**; для соединений, замков, транзакций.' },
  { id: 41, question: 'Бинарный поиск', answer: '**Бинарный поиск** — поиск в **отсортированном** массиве за **O(log n)** сравнений. На каждом шаге сравниваем искомое значение с элементом в середине диапазона: если меньше — ищем в левой половине, если больше — в правой. Размер области поиска каждый раз уменьшается вдвое.\n\n**Когда применять:** массив (или диапазон) отсортирован; нужно найти элемент, границу (первый ≥ x, последний ≤ x) или «бинарный поиск по ответу» (проверяем значение mid, сужаем диапазон).\n\n**Сложность:** **O(log n)** по времени, **O(1)** по памяти (итеративная реализация).\n\n**Пример (поиск индекса или -1):**\n  def binary_search(arr: list[int], target: int) -> int:\n    left, right = 0, len(arr) - 1\n    while left <= right:\n      mid = (left + right) // 2\n      if arr[mid] == target:\n        return mid\n      if arr[mid] < target:\n        left = mid + 1\n      else:\n        right = mid - 1\n    return -1\n\n**Важно:** границы **left/right** и условие **left <= right** должны быть согласованы, иначе возможен бесконечный цикл или пропуск элемента. Для «первый ≥ target» (lower_bound) возвращаем **left** после цикла (при right = mid - 1 и left = mid + 1).' },
  { id: 34, question: 'GOF23: Поведенческие паттерны (Behavioral)', answer: '**Поведенческие паттерны** решают задачи взаимодействия объектов и распределения ответственности.\n\n**Command** — запрос инкапсулирован в объект; отложенное выполнение, очереди, отмена.\n  class Command:\n    def __init__(self, receiver): self.receiver = receiver\n    def execute(self): self.receiver.action()\n  class Invoker: def set_command(self, c): self.cmd = c\n  def run(self): self.cmd.execute()\n\n**Chain of Responsibility** — запрос передаётся по цепочке обработчиков, пока кто-то не обработает.\n  class Handler:\n    def __init__(self): self.next = None\n    def handle(self, req):\n      if self.can_handle(req): return self.process(req)\n      return self.next.handle(req) if self.next else None\n\n**Observer** — подписчики уведомляются об изменениях субъекта; слабая связь.\n  class Subject:\n    def __init__(self): self._observers = []\n    def attach(self, o): self._observers.append(o)\n    def notify(self): [o.update(self) for o in self._observers]\n  class Observer: def update(self, subj): print("notified")\n\n**Strategy** — алгоритмы вынесены в отдельные классы; выбор в runtime, взаимозаменяемость.\n  class Strategy: def algo(self, data): raise NotImplementedError\n  class Context:\n    def __init__(self, strategy): self.strategy = strategy\n    def do(self, data): return self.strategy.algo(data)\n  ctx = Context(ConcreteStrategyA()); ctx.do(data)\n\n**Unit of Work** — накопление изменений и один коммит; согласованность транзакции.\n  class UnitOfWork:\n    def __init__(self): self.new, self.dirty, self.deleted = [], [], []\n    def register_new(self, e): self.new.append(e)\n    def commit(self): [repo.insert(e) for e in self.new]; ...\n\n**State** — поведение объекта зависит от внутреннего состояния; замена условных переходов на классы состояний.\n  class State: def handle(self, ctx): raise NotImplementedError\n  class Context: def __init__(self): self.state = StateA()\n  def request(self): self.state.handle(self)  # state может сменить self.state\n\n**Template Method** — скелет алгоритма в базовом классе; подклассы переопределяют шаги.\n  class Abstract:\n    def template(self): self.step1(); self.step2()  # step2 — переопределяют\n    def step1(self): ...\n    def step2(self): raise NotImplementedError' },
  { id: 50, question: 'Функция высшего порядка', answer: '**Функция высшего порядка** — функция, которая принимает одну или несколько **функций как аргументы** и/или **возвращает функцию**. В Python функции — объекты первого класса: их можно передавать, возвращать и хранить в переменных.\n\n**Принимает функцию как аргумент:** типичный случай — обобщённая логика (обход коллекции, фильтрация), а конкретное действие задаётся переданной функцией.\n  def apply_twice(f, x):\n    return f(f(x))\n  apply_twice(lambda n: n * 2, 5)   # 20\n\n**Встроенные функции высшего порядка:**\n**map(f, iterable)** — применяет **f** к каждому элементу, возвращает итератор результатов.\n  list(map(str.upper, [\'a\', \'b\']))   # [\'A\', \'B\']\n\n**filter(predicate, iterable)** — оставляет только элементы, для которых **predicate(x)** истинно.\n  list(filter(lambda x: x > 0, [-1, 2, -3, 4]))   # [2, 4]\n\n**sorted(iterable, key=f)** — сортирует по ключу **key**: для каждого элемента вызывается **f(x)**.\n  sorted([\'ab\', \'a\', \'abc\'], key=len)   # [\'a\', \'ab\', \'abc\']\n\n**functools.reduce(f, iterable, initial)** — сводит последовательность к одному значению, попарно применяя **f** (например, сумма, произведение).\n  from functools import reduce\n  reduce(lambda a, b: a + b, [1, 2, 3])   # 6\n\n**Возвращает функцию:** фабрика функций, замыкания, декораторы без вызова.\n  def make_multiplier(n):\n    def mul(x):\n      return x * n\n    return mul\n  double = make_multiplier(2)\n  double(5)   # 10\n\n**Кратко:** функция высшего порядка — принимает и/или возвращает функции; **map**, **filter**, **sorted**, **reduce** и свои обёртки (декораторы, фабрики).' },
  { id: 51, question: 'Работа с памятью в Python', answer: '**Иерархия памяти:** **арена (256 КБ)** → **пулы (4 КБ)** → **блоки (8–512 байт)**. Мелкие объекты живут в блоках; крупные выделяются напрямую у ОС.\n\n**Счётчик ссылок:** каждый объект хранит число ссылок на себя. **=** увеличивает, **del** или переприсваивание — уменьшает. Счётчик = 0 → объект удаляется.\n\n**Циклические ссылки:** если A → B → A, счётчики не обнулятся сами. Их находит **Garbage Collector (gc)**. **gc.collect()** — запустить вручную.\n\n**Полезные функции:**\n  sys.getrefcount(obj)  # счётчик ссылок\n  id(obj)               # адрес в памяти\n  sys.getsizeof(obj)    # размер объекта в байтах\n\n**weakref:** обычная ссылка «держит» объект в памяти (счётчик > 0). Слабая ссылка — как записка «где лежит объект», но она не мешает Python его удалить. Если объект удалён — weakref вернёт None. Используют в кэшах: храним данные, пока они кому-то нужны, но не мешаем их удалить, когда память нужна.\n\n**Экономия памяти:** **__slots__** убирает **__dict__** у экземпляров — меньше памяти при множестве объектов.' },
  { id: 52, question: 'Ключи словарей и коллизии', answer: '**Что такое коллизия:** ситуация, когда два разных ключа имеют **одинаковый хэш** (или одинаковый индекс ячейки после **hash(key) % размер_таблицы**).\n\n**Почему коллизии возникают:** хэш-функция не может создать уникальное число для каждого возможного ключа (бесконечное множество ключей → конечное количество хэшей). Даже хорошая хэш-функция иногда даёт одинаковые значения для разных объектов.\n\n**Как Python решает коллизии:** в каждой ячейке таблицы хранится список пар **(ключ, значение)**. При коллизии новый элемент просто добавляется в этот список. При поиске/получении значения Python: находит нужную ячейку по хэшу → перебирает все элементы в списке этой ячейки → сравнивает каждый ключ с искомым с помощью **==** → возвращает значение, когда нашёл совпадение.\n\n**Ключевые моменты:** **хэш** — это только подсказка «где примерно искать»; **==** — это то, что решает, тот ли это ключ. Если коллизий мало → поиск очень быстрый (**O(1)** в среднем). Если коллизий очень много → одна ячейка превращается в длинный список → скорость падает (в худшем случае **O(n)**).\n\n**Пример в голове:**\n  d = {\"listen\": \"слушать\", \"silent\": \"тишина\", \"bad\": 42}\n  # если все три ключа попали в одну ячейку:\n  # ячейка №7 → [(\"listen\", \"слушать\"), (\"silent\", \"тишина\"), (\"bad\", 42)]\n  # при запросе d[\"silent\"]:\n  # идём в ячейку 7\n  # \"listen\" == \"silent\"? → нет\n  # \"silent\" == \"silent\"? → да → возвращаем \"тишина\"\n\n**Вывод:** коллизии — нормальная и ожидаемая часть работы словаря. Python сделан так, чтобы они не ломали программу и не приводили к потере данных. Главное — хорошая хэш-функция и правильное определение **__eq__**, если вы создаёте свои классы как ключи. В обычном коде проблемы из-за коллизий почти не встречаются — **dict** в Python быстрый и надёжный.' },
  { id: 53, question: 'Очереди задач (Task Queues)', answer: '**Зачем нужны:** некоторые операции слишком долгие для обычного запроса (отправка email, обработка видео, генерация отчёта). Пользователь не должен ждать — задачу кладут в очередь, а отдельный воркер выполнит её в фоне.\n\n**Как работает:**\n1. Приложение кладёт задачу в **брокер** (очередь сообщений) — Redis, RabbitMQ\n2. **Воркер** (отдельный процесс) забирает задачу из очереди\n3. Воркер выполняет задачу и (опционально) сохраняет результат\n\n**Пример с Celery:**\n  # tasks.py\n  from celery import Celery\n  app = Celery(\"tasks\", broker=\"redis://localhost\")\n\n  @app.task\n  def send_email(to, subject, body):\n      # долгая операция\n      ...\n\n  # views.py\n  send_email.delay(\"user@mail.com\", \"Hi\", \"Hello!\")  # задача ушла в очередь\n  return {\"status\": \"email queued\"}  # ответ сразу\n\n**Популярные инструменты:** **Celery** (самый популярный, работает с Redis/RabbitMQ), **RQ** (Redis Queue — проще Celery), **Dramatiq** (современная альтернатива Celery), **Huey** (лёгкий, для небольших проектов).\n\n**Когда использовать:** отправка писем/SMS, обработка файлов и изображений, генерация PDF/отчётов, синхронизация с внешними API, любые операции > 1-2 секунд.\n\n**Кратко:** задача уходит в очередь → пользователь получает ответ сразу → воркер выполняет задачу в фоне.' },
  { id: 54, question: 'Объединение словарей', answer: '**1. Оператор | (Python 3.9+):** создаёт новый словарь; при совпадении ключей — значение из правого.\n  a = {\"x\": 1, \"y\": 2}\n  b = {\"y\": 3, \"z\": 4}\n  result = a | b   # {\"x\": 1, \"y\": 3, \"z\": 4}\n\n**2. Оператор |= (Python 3.9+):** обновляет словарь на месте (как update).\n  a |= b   # a теперь {\"x\": 1, \"y\": 3, \"z\": 4}\n\n**3. Распаковка ** (Python 3.5+):** создаёт новый словарь.\n  result = {**a, **b}   # {\"x\": 1, \"y\": 3, \"z\": 4}\n\n**4. Метод update():** изменяет исходный словарь на месте, ничего не возвращает.\n  a.update(b)   # a изменён\n\n**5. dict() + распаковка:**\n  result = dict(a, **b)   # работает, если ключи b — строки\n\n**6. Цикл (старый способ):**\n  result = a.copy()\n  for k, v in b.items():\n      result[k] = v\n\n**7. ChainMap (без копирования):** не создаёт новый словарь, а «смотрит» в оба; изменения отражаются в оригиналах.\n  from collections import ChainMap\n  combined = ChainMap(b, a)   # приоритет у b\n\n**Что выбрать:** **a | b** — самый читаемый (Python 3.9+). **{**a, **b}** — если нужна совместимость с 3.5+. **update()** — если не нужен новый словарь.' },
  { id: 55, question: 'Операторы and и or', answer: '**Порядок вычисления:** сначала все **and** слева направо, потом все **or** слева направо (and имеет больший приоритет).\n\n**and** — возвращает **первый False** (или falsy) элемент. Если все True — возвращает **последний**.\n  0 and 5        # 0 (первый falsy)\n  \"\" and \"hi\"    # \"\" (пустая строка — falsy)\n  3 and 5 and 7  # 7 (все truthy → последний)\n  True and 42    # 42\n\n**or** — возвращает **первый True** (или truthy) элемент. Если все False — возвращает **последний**.\n  0 or 5         # 5 (первый truthy)\n  \"\" or \"hi\"     # \"hi\"\n  None or 0 or \"\"  # \"\" (все falsy → последний)\n  \"a\" or \"b\"     # \"a\" (первый truthy)\n\n**Комбинация and и or:**\n  0 and 1 or 2   # сначала 0 and 1 → 0, потом 0 or 2 → 2\n  1 and 2 or 3   # сначала 1 and 2 → 2, потом 2 or 3 → 2\n  0 or 1 and 2   # сначала 1 and 2 → 2, потом 0 or 2 → 2\n\n**Практическое применение:**\n  name = user_name or \"Anonymous\"   # значение по умолчанию\n  x = data and data[0]              # безопасный доступ\n\n**Falsy-значения:** **False**, **None**, **0**, **\"\"**, **[]**, **{}**, **set()**. Всё остальное — truthy.' },
  { id: 56, question: 'Monkey patch', answer: '**Monkey patch** — изменение класса или модуля **в рантайме**: подмена или добавление метода/атрибута после того, как код уже определён. Возможно благодаря тому, что в Python классы и функции — объекты, их атрибуты можно переназначать.\n\n**Зачем используют:** исправить баг в сторонней библиотеке без правки её кода; добавить поведение к чужому классу; в тестах — подменить реальный вызов (сеть, БД) на заглушку.\n\n**Пример (подмена метода класса):**\n  class Dog:\n    def say(self):\n      return \"woof\"\n\n  def new_say(self):\n    return \"meow\"\n\n  Dog.say = new_say   # monkey patch\n  d = Dog()\n  d.say()   # \"meow\"\n\n**Пример (подмена функции в модуле):**\n  import requests\n  def fake_get(*args, **kwargs):\n    return type(\"Resp\", (), {\"status_code\": 200, \"json\": lambda: {}})()\n  requests.get = fake_get   # все вызовы requests.get теперь возвращают заглушку\n\n**Осторожно:** меняет поведение глобально; усложняет отладку и понимание кода. Лучше использовать только там, где нет контроля над исходным кодом (сторонние библиотеки, тесты).\n\n**Кратко:** monkey patch — переназначение атрибута/метода класса или модуля в рантайме; удобно для фиксов и тестов, но злоупотреблять не стоит.' },
  { id: 57, question: 'Создание класса через type()', answer: '**type(name, bases, dict)** — встроенная функция, которая **создаёт класс** в рантайме. Три аргумента: **name** — имя класса (строка), **bases** — кортеж базовых классов, **dict** — словарь атрибутов и методов класса (namespace). Возвращает новый тип (класс).\n\n**Зачем:** динамическое создание классов (по данным из конфига, API, фабрики классов); понимание, что **class** — это синтаксический сахар над вызовом **type** (или метакласса).\n\n**Пример (эквивалент обычного класса):**\n  def greet(self):\n    return f\"Hi, {self.name}\"\n  Person = type(\"Person\", (object,), {\"name\": \"\", \"greet\": greet})\n  p = Person()\n  p.name = \"Alice\"\n  p.greet()   # \"Hi, Alice\"\n\nТо же самое через **class**:\n  class Person:\n    name = \"\"\n    def greet(self):\n      return f\"Hi, {self.name}\"\n\n**Пример (наследование):**\n  Animal = type(\"Animal\", (object,), {\"say\": lambda self: \"...\"})\n  Dog = type(\"Dog\", (Animal,), {\"say\": lambda self: \"woof\"})\n  Dog().say()   # \"woof\"\n\n**Связь с метаклассами:** при выполнении **class Foo:** Python вызывает метакласс (по умолчанию **type**) с именем, базами и namespace; то есть создание класса — это вызов **type(...)** или **YourMeta(...)**.\n\n**Кратко:** **type(name, bases, dict)** создаёт класс в рантайме; **class** под капотом делает то же через метакласс (по умолчанию type).' },
  { id: 58, question: 'Unit of Work', answer: '**Unit of Work** — паттерн, при котором **несколько операций** с данными (добавление, изменение, удаление) объединяются в **одну транзакцию**. Либо выполняются все изменения, либо ни одно; при ошибке — откат целиком.\n\n**Зачем:** согласованность данных; не держать в голове «что уже сохранил, что ещё нет» — накапливаем изменения и один раз **commit** или **rollback**.\n\n**Идея:** объект Unit of Work **отслеживает** новые, изменённые и удалённые сущности; при вызове **commit()** применяет все изменения к БД в одной транзакции.\n\n**Пример (концептуальный):**\n  class UnitOfWork:\n    def __init__(self):\n      self.new = []      # объекты для insert\n      self.dirty = []   # изменённые\n      self.removed = [] # для delete\n    def register_new(self, obj): self.new.append(obj)\n    def register_dirty(self, obj): self.dirty.append(obj)\n    def register_removed(self, obj): self.removed.append(obj)\n    def commit(self):\n      for o in self.new: save(o)\n      for o in self.dirty: update(o)\n      for o in self.removed: delete(o)\n      # один commit транзакции\n\n**Пример (использование в сервисном слое):** созданный Unit of Work передаётся в сервис; сервис регистрирует изменения в UoW и в конце вызывает **commit()**.\n  class OrderService:\n    def __init__(self, uow: UnitOfWork):\n      self.uow = uow\n    def create_order(self, user_id, items):\n      order = Order(user_id=user_id, items=items)\n      self.uow.register_new(order)\n      for item in items:\n        self.uow.register_new(item)\n      self.uow.commit()   # одна транзакция — заказ и позиции\n  uow = UnitOfWork()\n  service = OrderService(uow)\n  service.create_order(1, [item1, item2])\n\n**В ORM:**\n- **Django:** **with transaction.atomic():** — блок внутри одной транзакции; при исключении — откат.\n  from django.db import transaction\n  with transaction.atomic():\n    User.objects.create(name=\"A\")\n    Order.objects.create(user_id=...)\n  # оба сохранены или оба откат\n\n- **SQLAlchemy:** **session** — Unit of Work: **session.add()**, **session.delete()**, изменение атрибутов; **session.commit()** — одна транзакция, **session.rollback()** — откат.\n  session.add(user)\n  session.add(order)\n  session.commit()   # всё разом\n\n**Кратко:** Unit of Work — накапливаем изменения и сохраняем одной транзакцией; в Django — **transaction.atomic()**, в SQLAlchemy — **session.commit()**.' },
  { id: 59, question: 'Слоистая архитектура (Layered)', answer: '**Слоистая архитектура** — разделение приложения на **горизонтальные слои**; каждый слой использует только слой ниже. Запрос идёт сверху вниз (UI → бизнес-логика → данные), ответ — обратно.\n\n**Типичные слои (сверху вниз):**\n- **Presentation** — API, контроллеры, формы; принимает запросы и отдаёт ответы.\n- **Business (Service)** — бизнес-правила, оркестрация; не знает про HTTP и БД.\n- **Data access (Repository)** — работа с БД, ORM, внешние сервисы.\n\n**Правило:** слой зависит только от слоя под ним; верхние слои не импортируют нижние «напрямую» в обход границ (зависимости через интерфейсы/абстракции при необходимости).\n\n**Пример (упрощённо):**\n  # Presentation — контроллер/views\n  class OrderController:\n    def __init__(self, order_service: OrderService):\n      self.service = order_service\n    def create(self, user_id, items):\n      order = self.service.create_order(user_id, items)\n      return {\"order_id\": order.id}\n\n  # Business — сервис\n  class OrderService:\n    def __init__(self, repo: OrderRepository):\n      self.repo = repo\n    def create_order(self, user_id, items):\n      order = Order(user_id=user_id, items=items)\n      self.repo.save(order)\n      return order\n\n  # Data access — репозиторий\n  class OrderRepository:\n    def save(self, order):\n      OrderModel.objects.create(...)\n\n**Плюсы:** понятное разделение, легко находить код. **Минусы:** при росте числа слоёв — «толстые» сервисы и проход через все слои.\n\n**Кратко:** слои Presentation → Service → Repository; зависимость только вниз.' },
  { id: 60, question: 'Чистая архитектура (Clean Architecture)', answer: '**Чистая архитектура** (Uncle Bob) — структура, где **ядро приложения не зависит** от фреймворков, БД и UI. Зависимости направлены **внутрь**: внешние слои зависят от внутренних, а не наоборот.\n\n**Кольца (изнутри наружу):**\n- **Entities** — сущности и правила предметной области; без зависимостей.\n- **Use cases** — сценарии приложения (один сценарий — один класс); зависят только от entities.\n- **Interface adapters** — презентеры, шлюзы к БД/API; реализуют интерфейсы, заданные use cases.\n- **Frameworks & drivers** — БД, HTTP, UI; подключают адаптеры.\n\n**Правило зависимостей:** внутренние кольца не знают о внешних. Use case объявляет интерфейс репозитория; адаптер в наружном кольце его реализует и внедряется (DI).\n\n**Пример (ядро + адаптер):**\n  # Entities (ядро)\n  class Order:\n    def __init__(self, user_id, items):\n      self.user_id = user_id\n      self.items = items\n\n  # Use case — зависит от абстракции репозитория\n  class CreateOrderUseCase:\n    def __init__(self, order_repo):  # интерфейс: save(order)\n      self.repo = order_repo\n    def execute(self, user_id, items):\n      order = Order(user_id, items)\n      self.repo.save(order)\n      return order\n\n  # Адаптер (внешний слой) — реализует репозиторий для БД\n  class DjangoOrderRepository:\n    def save(self, order):\n      OrderModel.objects.create(user_id=order.user_id, ...)\n\n  # Сборка (внешний слой)\n  repo = DjangoOrderRepository()\n  use_case = CreateOrderUseCase(repo)\n  # контроллер вызывает use_case.execute(...)\n\n**Плюсы:** ядро тестируемо без БД/HTTP; замена БД или UI не трогает use cases. **Минусы:** больше классов и абстракций.\n\n**Кратко:** зависимости внутрь; entities и use cases без фреймворков; адаптеры реализуют интерфейсы use cases.' },
  { id: 61, question: 'СУБД', answer: '**СУБД** (система управления базами данных) — программа, которая **создаёт, хранит и обрабатывает** данные в базе. Пользователь или приложение обращаются к СУБД (через SQL или API), а не к файлам напрямую.\n\n**Основные функции:**\n- **хранение** данных на диске с эффективной структурой;\n- **запросы** — выборка, вставка, обновление, удаление (SQL или аналог);\n- **транзакции** — группа операций как одна единица (commit/rollback);\n- **целостность** — ограничения, ключи, проверки;\n- **безопасность** — пользователи, права доступа;\n- **резервное копирование и восстановление**.\n\n**Типы СУБД:**\n- **Реляционные (SQL):** данные в таблицах, связи по ключам. **PostgreSQL**, **MySQL**, **SQLite**.\n- **Документные (NoSQL):** документы (JSON). **MongoDB**.\n- **Ключ–значение:** быстрый доступ по ключу. **Redis**, **Memcached**.\n- **Колоночные:** аналитика, большие объёмы. **ClickHouse**, **Cassandra**.\n\n**Пример (обращение к СУБД из приложения):** приложение подключается к СУБД драйвером/ORM и выполняет запросы — СУБД отвечает за физическое хранение и выполнение.\n  # PostgreSQL через psycopg2\n  conn = psycopg2.connect(\"dbname=mydb user=app\")\n  cur = conn.cursor()\n  cur.execute(\"SELECT * FROM users WHERE id = %s\", (1,))\n  row = cur.fetchone()\n\n**Кратко:** СУБД — программа, которая управляет базой данных: хранение, запросы, транзакции, целостность; реляционные (PostgreSQL, MySQL), документные (MongoDB), ключ–значение (Redis).' },
  { id: 62, question: 'Связь нескольких таблиц в SQL', answer: '**Связь таблиц** задаётся через **внешний ключ (FOREIGN KEY)**: в одной таблице хранится значение, ссылающееся на **первичный ключ (PRIMARY KEY)** другой таблицы. Выборка из нескольких связанных таблиц делается через **JOIN**.\n\n**Типы JOIN:**\n- **INNER JOIN** — только строки, где есть совпадение в **обеих** таблицах.\n- **LEFT JOIN** — все строки **левой** таблицы + совпадения справа; если справа нет — NULL.\n- **RIGHT JOIN** — все строки **правой** таблицы + совпадения слева.\n- **FULL OUTER JOIN** — все строки обеих таблиц; нет совпадения — NULL.\n- **CROSS JOIN** — «все со всеми»: каждую строку первой таблицы соединяем с **каждой** строкой второй. Условия ON нет. Если в первой таблице 3 строки, во второй 4 — получится 3 × 4 = 12 строк. Нужен, когда нужны все возможные пары (например, пользователи × товары).\n- **SEMI JOIN** — данные из первой таблицы, удовлетворяющие указанному условию соединения двух таблиц, **без возвращения данных второй таблицы**. В SQL выражается через **EXISTS** или **IN** (подзапрос); отдельного ключевого слова SEMI JOIN нет.\n\n**Пример таблиц (данные):**\n\n  users:\n  id | name\n  ---+------\n  1  | Alice\n  2  | Bob\n\n  orders:\n  id | user_id | total\n  ---+---------+------\n  1  | 1       | 100\n  2  | 2       | 200\n  3  | 1       | 150\n\n  Связь: orders.user_id → users.id (внешний ключ).\n\n**Примеры запросов и результаты:**\n\n  -- INNER JOIN: заказы с именем пользователя\n  SELECT o.id, o.total, u.name FROM orders o\n  INNER JOIN users u ON u.id = o.user_id;\n  Результат:\n  id | total | name\n  ---+-------+------\n  1  | 100   | Alice\n  2  | 200   | Bob\n  3  | 150   | Alice\n\n  -- LEFT JOIN: все пользователи и их заказы (без заказа — order_id, total = NULL)\n  SELECT u.name, o.id AS order_id, o.total FROM users u\n  LEFT JOIN orders o ON o.user_id = u.id;\n  Результат:\n  name  | order_id | total\n  ------+----------+------\n  Alice | 1        | 100\n  Alice | 3        | 150\n  Bob   | 2        | 200\n\n  -- CROSS JOIN: все пары пользователь × заказ (исходные таблицы users и orders)\n  SELECT u.name, o.id AS order_id, o.total FROM users u CROSS JOIN orders o;\n  Результат:\n  name  | order_id | total\n  ------+----------+------\n  Alice | 1        | 100\n  Alice | 2        | 200\n  Alice | 3        | 150\n  Bob   | 1        | 100\n  Bob   | 2        | 200\n  Bob   | 3        | 150\n\n  -- SEMI JOIN (EXISTS): пользователи, у которых есть хотя бы один заказ\n  SELECT * FROM users u\n  WHERE EXISTS (SELECT 1 FROM orders o WHERE o.user_id = u.id);\n  Результат:\n  id | name\n  ---+------\n  1  | Alice\n  2  | Bob\n  То же через IN: SELECT * FROM users WHERE id IN (SELECT user_id FROM orders);\n\n  -- FULL OUTER JOIN: все строки из обеих таблиц; нет совпадения — NULL\n  (добавим пользователя Carol без заказов)\n  SELECT u.name, o.id AS order_id, o.total FROM users u\n  FULL OUTER JOIN orders o ON o.user_id = u.id;\n  Результат:\n  name  | order_id | total\n  ------+----------+------\n  Alice | 1        | 100\n  Alice | 3        | 150\n  Bob   | 2        | 200\n  Carol | NULL     | NULL\n\n**Кратко:** связь — через **FOREIGN KEY**; **INNER** / **LEFT** / **RIGHT** / **FULL**; **CROSS** — декартово произведение; **SEMI** — «есть совпадение» через **EXISTS** или **IN**.' },
  { id: 63, question: 'Signals', answer: '**Signals** в Django — механизм **уведомлений**: при действиях с моделью (сохранение, удаление и т.д.) вызывается ваша функция **без изменения кода модели**. Приложения остаются **слабо связанными**.\n\n**Зачем:** побочные действия при событии — письмо при создании пользователя, создание профиля при первом **save**, обновление кэша, логирование.\n\n**Основные сигналы** (`django.db.models.signals`):\n- **pre_save** / **post_save** — до/после сохранения (create и update).\n- **pre_delete** / **post_delete** — до/после удаления.\n- **pre_init** / **post_init** — до/после создания экземпляра в памяти.\n- **m2m_changed** — при изменении связи многие-ко-многим (add, remove, clear); в **kwargs**: **action** (\'post_add\', \'pre_remove\' и т.д.), **pk_set**, **model**.\n\n**Подключение:** декоратор **@receiver(signal, sender=Model)** или **Signal.connect(receiver, sender=Model)**.\n\n**Регистрация в AppConfig.ready() — подробнее:**\n**Зачем:** метод **ready()** вызывается один раз при старте Django, когда все приложения и **модели уже загружены**. Если подключать сигналы при импорте модуля (на уровне файла), возможны **циклические импорты** (модель из другого приложения ещё не импортирована) или ситуация, когда код сигналов выполнится до полной инициализации приложений. В **ready()** порядок загрузки гарантирован.\n**Как:** в приложении объявляют **AppConfig** (в **apps.py**), в нём переопределяют **ready()** и там импортируют модуль с сигналами (или вызывают **connect**). Импорт модуля выполнит декораторы **@receiver** и зарегистрирует обработчики.\n**Пример:**\n  # myapp/apps.py\n  from django.apps import AppConfig\n\n  class MyAppConfig(AppConfig):\n      default_auto_field = \'django.db.models.BigAutoField\'\n      name = \'myapp\'\n\n      def ready(self):\n          import myapp.signals  # подтянет @receiver и connect\n\n  # в settings.INSTALLED_APPS указывать: \'myapp.apps.MyAppConfig\'\n\nЕсли не использовать **ready()**, а подключать при импорте **models.py**, при импорте моделей из других приложений в **sender=** можно получить ошибку «модель ещё не загружена». **dispatch_uid** в **@receiver** помогает избежать двойной регистрации при повторном вызове **ready()** (например, в тестах).\n\n**Аргументы @receiver (декоратор):**\n- **signal** — сам сигнал (post_save, post_delete, m2m_changed и т.д.).\n- **sender** — модель-источник (класс Model). Если не указать, обработчик вызывается для **любой** модели, отправившей этот сигнал.\n- **dispatch_uid** — уникальная строка (например, \'myapp.create_profile\'), чтобы один и тот же обработчик не подключался несколько раз при повторном импорте модуля (важно в тестах и при перезагрузке).\n\n**Аргументы функции-обработчика** (передаёт сигнал):\n- **post_save:** **sender** — класс модели; **instance** — сохранённый объект; **created** — True при создании новой записи, False при update; **update_fields** — множество полей при вызове save(update_fields=(...)), иначе None; **raw** — True при loaddata. Остальное в **kwargs**.\n- **post_delete:** **sender** — класс модели; **instance** — удалённый объект (запись в БД уже нет). Остальное в **kwargs**.\n- **m2m_changed:** **sender** — промежуточная модель связи (through); **instance** — объект, у которого меняли M2M-поле; **action** — \'pre_add\', \'post_add\', \'pre_remove\', \'post_remove\', \'pre_clear\', \'post_clear\'; **pk_set** — множество id добавленных/удалённых записей; **model** — класс «другой» стороны связи; **reverse** — направление (прямая/обратная). Остальное в **kwargs**.\n\n**Примеры (по одному на популярный сигнал):**\n\n**post_save** — создать профиль при создании пользователя:\n  @receiver(post_save, sender=User)\n  def create_profile(sender, instance, created, **kwargs):\n      if created:\n          UserProfile.objects.get_or_create(user=instance)\n\n**pre_save** — заполнить slug из title перед сохранением:\n  @receiver(pre_save, sender=Article)\n  def set_slug(sender, instance, **kwargs):\n      if not instance.slug:\n          instance.slug = slugify(instance.title)\n\n**post_delete** — инвалидировать кэш при удалении объекта:\n  @receiver(post_delete, sender=Product)\n  def invalidate_product_cache(sender, instance, **kwargs):\n      cache.delete(f\'product:{instance.id}\')\n\n**m2m_changed** — среагировать после добавления тегов к посту:\n  @receiver(m2m_changed, sender=Post.tags.through)\n  def on_post_tags_changed(sender, instance, action, **kwargs):\n      if action == \'post_add\' or action == \'post_remove\':\n          cache.delete(f\'post:{instance.id}:tags\')\n\n**Важно:** в **post_save** не вызывать **instance.save()** для той же модели — риск бесконечного цикла. Тяжёлую работу выносить в задачу (Celery).\n\n**Кратко:** Signals — уведомления при действиях с моделями; **post_save**, **post_delete**, **m2m_changed**; подписка через **@receiver** или **connect**; регистрация в **AppConfig.ready()**.' },
  { id: 64, question: 'Views', answer: '**Типы представлений** в Django: **FBV** (функция) и **CBV** (класс). Классы дают переиспользование через наследование, **миксины** и **дженерики**.\n\n**FBV** — функция принимает **request**, возвращает **HttpResponse**. Роутинг: path(\'url/\', views.my_view).\n\n**CBV** — класс с методами **get**, **post** и т.д.; атрибуты **model**, **template_name**, **queryset**. Роутинг: path(\'url/\', views.MyView.as_view()).\n\n**Что доступно через self в CBV:**\n**self.request** — текущий объект запроса (то же, что **request** в FBV).\n**self.args**, **self.kwargs** — позиционные и именованные аргументы из URL (например **self.kwargs[\'pk\']**, **self.kwargs[\'slug\']**).\n**self.object** — текущий объект (после вызова **get_object()**; в **DetailView**, **UpdateView**, **DeleteView**).\n**self.object_list** — список объектов (в **ListView**, после **get_queryset()**).\n**self.model** — класс модели.\n**self.queryset** — базовый QuerySet (если задан).\n**self.template_name** — путь к шаблону.\n**self.form_class** — класс формы (в **CreateView**, **UpdateView**, **FormView**).\n**self.success_url** — URL для редиректа после успеха.\n**self.get_queryset()**, **self.get_object()**, **self.get_context_data()**, **self.get_form()** — вызов собственных методов для получения данных.\n\n**Декораторы для FBV:**\n- **@login_required** — редирект на логин, если пользователь не аутентифицирован; опционально **login_url**, **redirect_field_name**.\n- **@require_http_methods([\"GET\", \"POST\"])** — разрешить только указанные методы; иначе 405.\n- **@require_GET**, **@require_POST** — только GET или только POST.\n- **@csrf_exempt** — отключить проверку CSRF (осторожно, только для API/внешних вызовов).\n- **@cache_page(sec)** — кэшировать ответ на заданное число секунд.\n- **@user_passes_test(func)** — вызов **func(user)**; при False — редирект на логин. Для проверки прав.\n\n**request — основные атрибуты и методы:**\n- **request.method** — строка метода (\"GET\", \"POST\", \"PUT\" и т.д.).\n- **request.GET**, **request.POST** — QueryDict с параметрами запроса и данными формы.\n- **request.FILES** — загруженные файлы (мультипарт-форма).\n- **request.user** — текущий пользователь (AnonymousUser или User); доступен при включённой аутентификации.\n- **request.path**, **request.get_full_path()** — путь URL (без домена / с query string).\n- **request.META** — словарь заголовков и метаданных (HTTP_REFERER, REMOTE_ADDR, CONTENT_TYPE и т.д.).\n- **request.body** — сырое тело запроса (bytes); для JSON: **json.loads(request.body)**.\n- **request.COOKIES**, **request.session** — куки и объект сессии.\n\n**Миксины (django.views.generic / auth):**\n- **LoginRequiredMixin** — редирект на страницу входа, если пользователь не аутентифицирован; задаётся **login_url**.\n- **UserPassesTestMixin** — вызывается **test_func()**; при False — **PermissionDenied** или редирект (**permission_denied_message**, **handle_no_permission()**).\n- **PermissionRequiredMixin** — проверка **permission_required** (список прав); при отсутствии — 403.\n- **SuccessMessageMixin** — добавляет **success_message** в сообщения фреймворка после успешной операции (например, CreateView).\n\n**Дженерики (django.views.generic) и их методы:**\n\n**TemplateView** — отображение шаблона без модели/формы. Атрибуты: **template_name**. Для статических страниц (о проекте, контакты).\nМетоды: **dispatch**, **get_context_data**, **get**.\n\n**ListView** — список объектов. Атрибуты: **model** / **queryset**, **template_name**, **context_object_name**, **paginate_by**.\nМетоды: **dispatch**, **get_queryset**, **get_context_data**, **get**.\n\n**DetailView** — один объект по **pk** / **slug**. Атрибуты: **model**, **context_object_name**.\nМетоды: **dispatch**, **get_queryset**, **get_object**, **get_context_data**, **get**.\n\n**CreateView** — форма создания объекта. Атрибуты: **model**, **form_class** / **fields**, **template_name**, **success_url**.\nМетоды: **dispatch**, **get_queryset**, **get_context_data**, **form_valid**, **form_invalid**, **get_success_url**, **get**, **post**.\n\n**UpdateView** — форма редактирования по pk/slug. Атрибуты: как у **CreateView**.\nМетоды: **dispatch**, **get_queryset**, **get_object**, **get_context_data**, **form_valid**, **form_invalid**, **get_success_url**, **get**, **post**.\n\n**DeleteView** — подтверждение и удаление. Атрибуты: **model**, **success_url**, **template_name**.\nМетоды: **dispatch**, **get_queryset**, **get_object**, **get_context_data**, **get_success_url**, **get**, **post**.\n\n**FormView** — форма без привязки к модели. Атрибуты: **form_class**, **template_name**, **success_url**.\nМетоды: **dispatch**, **get_context_data**, **form_valid**, **form_invalid**, **get_success_url**, **get**, **post**.\n\n**Описание методов (переопределяемые):**\n\n**dispatch(request, *args, **kwargs)** — точка входа: вызывается **до** get/post. Проверки, логирование, ограничение доступа. Вернуть **super().dispatch(...)** или свой **HttpResponse**.\n\n**get_queryset()** — вернуть QuerySet (фильтрация, аннотации). Пример: показать только активные записи текущего пользователя.\n\n**get_object(queryset=None)** — вернуть один объект. По умолчанию ищет по **pk** / **slug**. Переопределяют для поиска по другому полю или проверки прав.\n\n**get_context_data(**kwargs)** — добавить данные в контекст шаблона. Вызвать **super().get_context_data(**kwargs)**, дополнить словарь и вернуть.\n\n**form_valid(form)** — после успешной валидации формы. По умолчанию сохраняет объект. Переопределяют для логики перед сохранением (например, **form.instance.author = self.request.user**); вызвать **super().form_valid(form)**.\n\n**form_invalid(form)** — при невалидной форме; по умолчанию рендерит шаблон с ошибками. Переопределяют для доп. логики (логирование, уведомление).\n\n**get_success_url()** — URL редиректа после успеха. Можно вернуть **reverse(\'detail\', args=[self.object.pk])** или использовать атрибут **success_url**.\n\n**get / post** — обработка GET / POST. В дженериках обычно не переопределяют напрямую — используют **get_queryset**, **get_context_data**, **form_valid**.\n\n**Кратко:** FBV vs CBV; миксины — **LoginRequiredMixin**, **UserPassesTestMixin**, **PermissionRequiredMixin**; дженерики — **TemplateView**, **ListView**, **DetailView**, **CreateView**, **UpdateView**, **DeleteView**, **FormView**; переопределять **get_queryset**, **get_context_data**, **get_object**, **form_valid**, **get_success_url**, **dispatch**.' },
  { id: 65, question: 'Models', answer: '**Модель** в Django — класс, наследующий **django.db.models.Model**. Описывает таблицу БД: поля → колонки, связи → внешние ключи. Каждый экземпляр — строка таблицы.\n\n**Основные типы полей:**\n- **CharField**, **TextField** — строка (max_length для CharField).\n- **IntegerField**, **BigIntegerField**, **SmallIntegerField** — целое.\n- **DecimalField**, **FloatField** — числа.\n- **BooleanField**, **NullBooleanField** — флаг.\n- **DateField**, **DateTimeField** — дата/время; **auto_now** (обновлять при save), **auto_now_add** (только при создании).\n- **EmailField**, **URLField**, **SlugField** — строки с валидацией.\n- **ForeignKey(Model, on_delete)** — связь «много к одному»; **on_delete**: CASCADE, PROTECT, SET_NULL, SET_DEFAULT.\n- **OneToOneField** — один к одному.\n- **ManyToManyField** — многие ко многим; опционально **through** — своя промежуточная модель.\n- **FileField**, **ImageField** — файлы (путь в медиа).\n\n**Мета (class Meta):**\n- **ordering** — порядок по умолчанию (список полей, например [\'-created_at\']).\n- **verbose_name** / **verbose_name_plural** — человекочитаемые имена.\n- **db_table** — имя таблицы в БД.\n- **constraints** — ограничения уровня таблицы (вместо устаревшего **unique_together**): **UniqueConstraint(fields=[\'a\', \'b\'], name=\'uq_ab\')** — уникальность по группе полей; **CheckConstraint(check=Q(price__gte=0), name=\'chk_price\')** — проверка по условию. Задаётся список в **Meta.constraints**.\n- **indexes** — список **Index** для индексов.\n\n**Менеджер:**\n\nПо умолчанию **objects** — экземпляр **Manager**; через него **all()**, **filter()**, **get()** и т.д.\n\nСвой менеджер: класс от **models.Manager**, переопределить **get_queryset()** или свои методы, присвоить атрибуту модели (**objects = MyManager()**).\n\nНесколько менеджеров: несколько атрибутов (**objects**, **published** и т.д.). Менеджер по умолчанию — **Meta.default_manager_name** (3.2+) или первый объявленный.\n\nНаследование: подкласс наследует менеджер родителя; свой можно задать заново.\n\nПример своих менеджеров:\n  class PublishedManager(models.Manager):\n      def get_queryset(self):\n          return super().get_queryset().filter(is_published=True)\n\n  class Article(models.Model):\n      title = models.CharField(max_length=200)\n      is_published = models.BooleanField(default=False)\n      objects = models.Manager()       # все записи\n      published = PublishedManager()   # только опубликованные\n  # Article.published.all() — только с is_published=True\n\n**Методы для переопределения:**\n- **__str__(self)** — строковое представление (админка, shell, отладка).\n- **clean(self)** — валидация на уровне модели (целиком объект). Вызывается при **full_clean()** на экземпляре модели; **ModelForm** вызывает **full_clean()** внутри **is_valid()**, поэтому **clean()** модели срабатывает при проверке формы. Используют для проверок, затрагивающих **несколько полей** (например, дата начала < дата окончания, уникальность пары полей). При ошибке — **raise ValidationError** (можно передать словарь «поле → список сообщений» для привязки ошибок к полям). Метод **save()** валидацию не вызывает — чтобы проверка выполнялась при сохранении, нужно явно вызывать **instance.full_clean()** перед **save()** или использовать форму/сериализатор.\n- **save(self, *args, **kwargs)** — логика перед/после сохранения; в конце вызвать **super().save(*args, **kwargs)**.\n- **delete(self, *args, **kwargs)** — при удалении; **super().delete()** в конце.\n- **get_absolute_url(self)** — URL объекта (используется в админке, редиректах).\n\n**Миграции:** **makemigrations** — создать файлы миграций по изменениям моделей; **migrate** — применить к БД. **Migration** хранит операции (CreateModel, AddField, AlterField и т.д.).\n\n**Кратко:** модель = класс от **Model**, поля и **Meta**; **ForeignKey**, **ManyToManyField**; менеджер **objects** и свои; **__str__**, **clean**, **save**, **delete**, **get_absolute_url**; миграции — **makemigrations**, **migrate**.' },
  { id: 66, question: 'Транзакции', answer: '**Транзакция** — группа операций с БД как одно целое: либо выполняются все, либо при ошибке откатываются все. В Django — через **django.db.transaction**.\n\nПо умолчанию **каждый view** выполняется в одной транзакции: при успешном ответе — commit, при необработанном исключении — rollback. Явный **atomic()** нужен, когда хотите объединить несколько операций в один блок или использовать savepoint.\n\n**transaction.atomic(using=None):** контекстный менеджер или декоратор; всё внутри одного блока выполняется в одной транзакции. При исключении — **rollback**, при нормальном выходе — **commit**.\n\n**Использование:**\n- Как блок: **with transaction.atomic():** — код внутри в одной транзакции.\n- Как декоратор: **@transaction.atomic** — вся функция в одной транзакции.\n- Вложенные **atomic()** создают **savepoint** (точки сохранения); откат откатывает до savepoint, а не до начала внешней транзакции. Пример: во внешнем **atomic()** создали запись A, во вложенном **atomic()** создали B и выбросили исключение — откатится только вложенный блок (B не сохранится), A останется в БД; после выхода из внешнего блока будет один commit.\n  with transaction.atomic():\n      A.objects.create(name=\"a\")   # останется\n      try:\n          with transaction.atomic():\n              B.objects.create(name=\"b\")\n              raise ValueError()   # откат только этого блока\n      except ValueError:\n          pass\n  # в БД только A\n\n**Пример (один блок):**\n  with transaction.atomic():\n      User.objects.create(username=\"a\")\n      Order.objects.create(user_id=...)\n  # оба сохранены или оба откат при исключении\n\n**Важно:** по умолчанию в режиме **autocommit** каждый запрос в своей транзакции. **atomic()** отключает autocommit на время блока и делает один commit в конце. Для БД, не поддерживающей транзакции (например старый MyISAM), **atomic()** лишь эмулирует поведение через savepoint.\n\n**Кратко:** **transaction.atomic()** — блок или декоратор; один commit/rollback на блок; вложенные блоки — savepoint; при исключении — откат.' },
  { id: 67, question: 'Templates', answer: '**Шаблоны** — HTML (или другой текст) с подстановкой данных и логикой. Рендер через **render(request, \'template.html\', context)** или **TemplateResponse**.\n\n**Вывод переменных (синтаксис):**\n\n**{{ variable }}** — двойные фигурные скобки; **variable** — ключ из контекста (словаря, переданного в **render()**). Результат подставляется в HTML; если переменной нет — пустая строка (если не задан фильтр **default**).\n\n**Точка (.)** подходит для разного: **{{ объект.имя }}** — атрибут объекта; **{{ словарь[\'ключ\'] }}** — ключ словаря в квадратных скобках; **{{ список.0 }}**, **{{ список.1 }}** — числовой индекс списка (у списка нет именованных ключей, только 0, 1, 2…); **{{ словарь.ключ }}** — ключ словаря; **{{ объект.метод }}** — вызов метода без скобок и без аргументов (Django сам подставит результат). При отсутствии ключа/атрибута — пусто.\n\nТехнически при встрече точки система шаблонов ищет значение **в таком порядке:** (1) поиск в словаре (ключ), (2) поиск атрибута или метода, (3) поиск по числовому индексу.\n\n**Фильтры** — вертикальная черта после переменной. Без аргумента: **{{ name|lower }}**, **{{ text|upper }}**. С одним аргументом: **{{ value|default:\"—\" }}** (значение по умолчанию), **{{ date|date:\"d.m.Y\" }}**, **{{ text|truncatewords:10 }}**. Аргумент в кавычках — строка (**\"...\"** или **\'...\'**), без кавычек — число или переменная. Несколько фильтров подряд: **{{ name|lower|truncatewords:5 }}** — сначала **lower**, потом **truncatewords**.\n\n**Примеры:** **{{ title }}**, **{{ user.email|default:\"нет\" }}**, **{{ created_at|date:\"d E Y\" }}**, **{{ items|length }}**.\n\n**Теги (логика):**\n**{% if %}** / **{% elif %}** / **{% endif %}** — условие.\n**{% for item in list %}** / **{% empty %}** / **{% endfor %}** — цикл.\n**{% url \'name\' %}** — обратное разрешение URL.\n**{% csrf_token %}** — токен для формы.\n**{% block name %}** / **{% endblock %}** — блок для наследования.\n**{% extends \'base.html\' %}** — наследование от базового шаблона.\n**{% include \'partial.html\' %}** — вставка фрагмента.\n**{% load static %}** или **{% load my_tags %}** — загрузка тегов/фильтров.\n\n**Наследование:** базовый шаблон задаёт блоки **{% block content %}** ... **{% endblock %}**. Дочерний **{% extends \'base.html\' %}** и переопределяет блоки. **{{ block.super }}** — вставить содержимое блока из родителя.\n\n**Частые фильтры:** **date**, **time** — формат даты/времени. **default** — значение по умолчанию. **length**, **slice**, **truncatewords** — длина и обрезка. **lower**, **upper** — регистр. **join** — объединение списка. **yesno** — да/нет/пусто.\n\n**Каталоги:** шаблоны ищутся в **TEMPLATES[\'DIRS\']** и в **app_dir/templates/**. Подшаблоны часто по пути **app_name/имя.html**.\n\n**Custom template tags:** в приложении создать каталог **templatetags**, в нём файл-модуль (например **my_tags.py**). В модуле: **from django import template**, **register = template.Library()**. Простой тег — **@register.simple_tag**, возвращает строку; в шаблоне **{% load my_tags %}**, затем **{% my_tag arg %}**. Тег с шаблоном — **@register.inclusion_tag(\'partial.html\')**, функция возвращает словарь контекста; в шаблоне **{% my_inclusion_tag %}**.\n  # myapp/templatetags/my_tags.py\n  from django import template\n  register = template.Library()\n\n  @register.simple_tag\n  def current_time(format_str):\n      return datetime.now().strftime(format_str)\n  # в шаблоне: {% load my_tags %} {% current_time \"%H:%M\" %}\n\n**Custom filters:** в том же **templatetags**-модуле **@register.filter**; функция принимает значение и опционально аргумент, возвращает значение для подстановки в **{{ value|my_filter }}** или **{{ value|my_filter:arg }}**. Можно **@register.filter(name=\'other_name\')** для другого имени в шаблоне.\n  @register.filter\n  def cut(value, arg):\n      return value.replace(arg, \"\")\n  # в шаблоне: {{ text|cut:\" \" }}\n\n**Кратко:** **{{ var }}**, **{{ var|filter }}**; теги **if**, **for**, **url**, **csrf_token**, **block**, **extends**, **include**, **load**; custom tags и filters в **templatetags**, **@register.simple_tag** / **inclusion_tag** / **filter**.' },
  { id: 68, question: 'Middleware', answer: '**Middleware** — прослойка между запросом и view (и между view и ответом). Цепочка выполняется по порядку при запросе и в **обратном** порядке при формировании ответа. Нужен для логирования, аутентификации, CSRF, сжатия, заголовков и т.д.\n\n**Подключение:** в **settings.MIDDLEWARE** — список строк (пути к классам). Порядок важен: при запросе — сверху вниз, при ответе — снизу вверх.\n\n**Современный стиль (callable):** класс с **__init__(self, get_response)** и **__call__(self, request)**. В **__call__** вызывают **response = self.get_response(request)**; код до вызова — до view, после — после view. Возвращать нужно **response** (или свой HttpResponse).\n  class MyMiddleware:\n      def __init__(self, get_response):\n          self.get_response = get_response\n      def __call__(self, request):\n          # до view\n          response = self.get_response(request)\n          # после view\n          return response\n\n**Методы (опционально):** **process_request(request)** — до view; если вернуть **HttpResponse**, цепочка обрывается, view не вызывается. **process_response(request, response)** — после view, можно изменить ответ. **process_view(request, view_func, view_args, view_kwargs)** — прямо перед вызовом view. **process_exception(request, exception)** — если view выбросила исключение. **process_template_response(request, response)** — если view вернула **TemplateResponse**.\n\n**Кратко:** Middleware — цепочка до/после view; **MIDDLEWARE** в settings; класс с **__init__(get_response)** и **__call__(request)** или методы **process_request** / **process_response**; порядок в списке задаёт порядок выполнения.' },
  { id: 69, question: 'Пользовательская команда', answer: '**Management command** — команда, вызываемая через **python manage.py &lt;имя&gt;** (например **runserver**, **migrate**). Свои команды добавляют в приложении.\n\n**Создание:** в приложении создают каталог **management/commands/** и в нём файл **&lt;имя_команды&gt;.py** (имя без пробелов, в нижнем регистре). В файле объявляют класс с именем **Command**, наследующий **django.core.management.base.BaseCommand**. Обязательный метод — **handle(self, *args, **options)**: в нём пишут логику команды.\n\n**Аргументы команды (простыми словами):** аргументы — это то, что пользователь дописывает в командной строке после имени команды (файл, флаги, числа). Чтобы команда это приняла, нужно объявить аргументы в методе **add_arguments(self, parser)**. **parser** — это «описание формы»: вы говорите, какие аргументы бывают, а Django при вызове команды разбирает строку и подставляет значения в **options**; в **handle** вы их просто читаете из **options**.\n\n**Позиционные аргументы** — то, что пишут по порядку, без имени. Например: **python manage.py import_users data.csv**. Здесь **data.csv** — первый позиционный аргумент. Объявление: **parser.add_argument(\'file\', type=str)**. Имя **\'file\'** — ключ в словаре: в **handle** получите **options[\'file\']** = **\'data.csv\'**. Порядок важен: первый написанный аргумент — первый в команде.\n\n**Несколько значений подряд:** **parser.add_argument(\'ids\', nargs=\'+\')** — тогда в командной строке можно перечислить несколько слов (например **1 2 3**), и в **options[\'ids\']** попадёт список **[\'1\', \'2\', \'3\']**.\n\n**Именованные аргументы** — с именем через два минуса, порядок не важен. Например **--dry-run** или **--limit 50**. Флаг (да/нет): **parser.add_argument(\'--dry-run\', action=\'store_true\')**. Если пользователь написал **--dry-run**, в **options[\'dry_run\']** будет **True**, иначе **False**. В **options** имя всегда без **--** и с подчёркиванием вместо минуса: **--dry-run** → **dry_run**.\n\n**Именованный аргумент со значением:** **parser.add_argument(\'--limit\', type=int, default=100)**. Пользователь может написать **--limit 50**; тогда **options[\'limit\']** = **50**. Если не написал — **options[\'limit\']** = **100** (default). **type=int** — значение приводят к числу.\n\nИтого: в **add_arguments** вы описываете, что можно передать в команду; в **handle** всё уже разобранное лежит в **options** — берите по ключу и используйте.\n\n**Вывод:** используют **self.stdout.write(\'текст\')** вместо **print** (так тесты и перенаправление работают корректно). Для ошибок — **self.stderr**. **self.stdout.write(self.style.SUCCESS(\'OK\'))** даёт цветной вывод в терминале; есть также **self.style.WARNING**, **self.style.ERROR**.\n\n**Пример:**\n  # myapp/management/commands/import_users.py\n  from django.core.management.base import BaseCommand\n\n  class Command(BaseCommand):\n      help = \'Импорт пользователей из CSV\'\n\n      def add_arguments(self, parser):\n          parser.add_argument(\'file\', type=str)\n          parser.add_argument(\'--dry-run\', action=\'store_true\')\n\n      def handle(self, *args, **options):\n          path = options[\'file\']\n          if options[\'dry_run\']:\n              self.stdout.write(\'Dry run, skip\')\n              return\n          # открыть path, создать записи...\n          self.stdout.write(self.style.SUCCESS(f\'Imported from {path}\'))\n  # вызов: python manage.py import_users data.csv --dry-run\n\n**Кратко:** команда = **management/commands/&lt;name&gt;.py**, класс **Command(BaseCommand)**, метод **handle()**; аргументы задаются в **add_arguments(parser)** (позиционные и именованные, через argparse); вывод через **self.stdout** / **self.stderr**.' },
  { id: 72, question: 'Context Processor', answer: '**Context processor** — функция, которая принимает **request** и возвращает **словарь**. Этот словарь автоматически добавляется в **контекст каждого шаблона** (не нужно передавать вручную через render). Удобно для данных, нужных на **всех** страницах: текущий пользователь, настройки сайта, корзина, уведомления.\n\n**Встроенные (по умолчанию в TEMPLATES):**\n**django.template.context_processors.debug** — переменные **debug** и **sql_queries**.\n**django.template.context_processors.request** — объект **request** в шаблоне.\n**django.contrib.auth.context_processors.auth** — **user** и **perms** (текущий пользователь и его права).\n**django.contrib.messages.context_processors.messages** — **messages** (сообщения из **django.contrib.messages**).\n**django.template.context_processors.static** — **STATIC_URL**.\n**django.template.context_processors.media** — **MEDIA_URL**.\n\n**Создание своего context processor:**\n\n1. Создать функцию в любом модуле (обычно **myapp/context_processors.py**).\n2. Функция принимает **request**, возвращает **dict**.\n3. Зарегистрировать путь к функции в **settings.py** → **TEMPLATES** → **OPTIONS** → **context_processors**.\n\n**Пример:**\n  # myapp/context_processors.py\n  from .models import Category\n\n  def categories(request):\n      return {\'categories\': Category.objects.all()}\n\n  def site_settings(request):\n      return {\n          \'SITE_NAME\': \'My Site\',\n          \'SUPPORT_EMAIL\': \'help@example.com\',\n      }\n\n**Подключение в settings.py:**\n  TEMPLATES = [{\n      ...\n      \'OPTIONS\': {\n          \'context_processors\': [\n              \'django.template.context_processors.debug\',\n              \'django.template.context_processors.request\',\n              \'django.contrib.auth.context_processors.auth\',\n              \'django.contrib.messages.context_processors.messages\',\n              \'myapp.context_processors.categories\',\n              \'myapp.context_processors.site_settings\',\n          ],\n      },\n  }]\n\n**В шаблоне (без передачи через render):**\n  {{ SITE_NAME }}\n  {% for cat in categories %}\n      {{ cat.name }}\n  {% endfor %}\n\n**Важно:** context processor вызывается на **каждый** запрос, поэтому тяжёлые запросы к БД лучше **кэшировать** или выносить в middleware. Работает только при рендере через **render()**, **TemplateResponse** или **RequestContext** (обычный **Context** не запускает процессоры).\n\n**Кратко:** context processor — функция **(request) → dict**; словарь доступен во **всех** шаблонах; регистрация в **TEMPLATES[OPTIONS][context_processors]**; встроенные дают **user**, **request**, **messages**, **STATIC_URL**.' },
  { id: 73, question: 'APIViews (DRF)', answer: '**APIView** (rest_framework.views) — базовый класс для API. Обрабатывает **request** (уже парсированный: **request.data** для JSON/POST). Поддерживает **permission_classes**, **throttle_classes**, **authentication_classes**. Переопределяют **get**, **post**, **put**, **patch**, **delete**.\n  from rest_framework.views import APIView\n  from rest_framework.response import Response\n\n  class HelloAPIView(APIView):\n      def get(self, request):\n          return Response({\'message\': \'Hello\'})\n      def post(self, request):\n          name = request.data.get(\'name\')\n          return Response({\'greeting\': f\'Hi, {name}\'})\n\n**GenericAPIView** — наследует **APIView**, добавляет работу с моделью и сериализатором: **queryset**, **serializer_class**, **lookup_url_kwarg** (по умолчанию **pk**). Методы: **get_queryset()**, **get_object()**, **get_serializer()**, **get_serializer_context()**. Сами **get/post** не реализует — используют вместе с **миксинами** или переопределяют.\n\n**Миксины (rest_framework.mixins):**\n**ListModelMixin** — **list(request)** → список, **paginate_queryset**.\n**CreateModelMixin** — **create(request)** → создание, **perform_create(serializer)**.\n**RetrieveModelMixin** — **retrieve(request, pk)** → один объект.\n**UpdateModelMixin** — **update** (PUT), **partial_update** (PATCH); **perform_update(serializer)**.\n**DestroyModelMixin** — **destroy(request, pk)** → удаление, **perform_destroy(instance)**.\n\n**Конкретные классы (миксин + GenericAPIView):**\n**ListAPIView** — List + GenericAPIView. GET — список.\n**CreateAPIView** — Create + GenericAPIView. POST — создание.\n**RetrieveAPIView** — Retrieve + GenericAPIView. GET /pk/ — один объект.\n**UpdateAPIView** — Update + GenericAPIView. PUT/PATCH /pk/.\n**DestroyAPIView** — Destroy + GenericAPIView. DELETE /pk/.\n**ListCreateAPIView** — List + Create. GET список, POST создание.\n**RetrieveUpdateAPIView** — Retrieve + Update. GET/PUT/PATCH /pk/.\n**RetrieveDestroyAPIView** — Retrieve + Destroy. GET/DELETE /pk/.\n**RetrieveUpdateDestroyAPIView** — полный CRUD по одному объекту: GET/PUT/PATCH/DELETE /pk/.\n\n**Пример (ListCreateAPIView):**\n  from rest_framework.generics import ListCreateAPIView\n\n  class ArticleListCreate(ListCreateAPIView):\n      queryset = Article.objects.all()\n      serializer_class = ArticleSerializer\n      permission_classes = [IsAuthenticatedOrReadOnly]\n\n  # urls: path(\'articles/\', ArticleListCreate.as_view())\n  # GET articles/ — список, POST articles/ — создать\n\n**ViewSet** — объединяет логику нескольких действий в одном классе. Не привязан к URL; маршруты задаёт **Router**. Actions: **list**, **create**, **retrieve**, **update**, **partial_update**, **destroy**.\n\n**ModelViewSet** — GenericAPIView + все 5 миксинов. Полный CRUD. Атрибуты: **queryset**, **serializer_class**, **permission_classes**, **filter_backends**, **pagination_class**.\n**ReadOnlyModelViewSet** — только **ListModelMixin** + **RetrieveModelMixin**. list + retrieve.\n**GenericViewSet** — только GenericAPIView; свои методы помечают **@action**.\n\n**Пример ViewSet (ModelViewSet):**\n  from rest_framework.viewsets import ModelViewSet\n  from rest_framework.permissions import IsAuthenticatedOrReadOnly\n\n  class ArticleViewSet(ModelViewSet):\n      queryset = Article.objects.all()\n      serializer_class = ArticleSerializer\n      permission_classes = [IsAuthenticatedOrReadOnly]\n\n      def get_queryset(self):\n          qs = super().get_queryset()\n          if self.action == \'list\' and self.request.query_params.get(\'draft\'):\n              return qs.filter(is_draft=True)\n          return qs.filter(is_draft=False)\n\n      @action(detail=True, methods=[\'post\'])\n      def publish(self, request, pk=None):\n          article = self.get_object()\n          article.is_draft = False\n          article.save()\n          return Response({\'status\': \'published\'})\n\n**Router:**\n  from rest_framework.routers import DefaultRouter\n  router = DefaultRouter()\n  router.register(r\'articles\', ArticleViewSet, basename=\'article\')\n  urlpatterns = [path(\'api/\', include(router.urls))]\n  # GET/POST /api/articles/ ; GET/PUT/PATCH/DELETE /api/articles/5/\n\n**Кастомный @action:**\n  @action(detail=True, methods=[\'post\'])\n  def publish(self, request, pk=None):\n      obj = self.get_object(); obj.is_draft = False; obj.save()\n      return Response({\'status\': \'ok\'})\n  # POST /api/articles/5/publish/\n\n**Через self доступны:** **request**, **kwargs** (pk и др.), **action** (в ViewSet), **get_queryset()**, **get_object()**, **get_serializer()**, **perform_create()**, **perform_update()**, **perform_destroy()**.\n\n**Кратко:** **APIView** → **GenericAPIView** + миксины → **ListAPIView**, **CreateAPIView**, **ListCreateAPIView**, **RetrieveUpdateDestroyAPIView** и т.д.; **ViewSet** + Router для одного класса на ресурс; **ModelViewSet**, **ReadOnlyModelViewSet**, **@action**.' },
  { id: 74, question: 'Serializers (DRF)', answer: '**Serializer** (rest_framework.serializers) — преобразует объекты Python в JSON/XML и обратно; проверяет входящие данные (**validation**). Аналог **Form** для API. Два направления: **сериализация** (объект → **.data** для ответа) и **десериализация** (входные данные → **.is_valid()**, **.validated_data**, **.save()**).\n\n**Serializer** (базовый) — поля задают вручную. Обязательно переопределить **create(self, validated_data)** и **update(self, instance, validated_data)** для **.save()**. Методы: **.is_valid(raise_exception=False)**, **.validated_data**, **.errors** (словарь ошибок по полям), **.save(**kwargs)** (вызывает create или update), **.data** (после сериализации).\n\n**ModelSerializer** — поля и **create**/ **update** строятся по модели. В **Meta**: **model**, **fields** (список или **\'__all__\'**), **exclude** (исключить поля), **read_only_fields**, **extra_kwargs** (аргументы для полей: **max_length**, **min_value**, **validators** и т.д.), **depth** (глубина вложенности FK при автоматическом вложенном представлении).\n\n**Типы полей (часто используемые):**\n**CharField**, **IntegerField**, **FloatField**, **BooleanField**, **DateTimeField**, **DateField** — по смыслу как в модели. Параметры: **required**, **default**, **allow_null**, **allow_blank** (для строк), **max_length**, **min_value**, **max_value**.\n**EmailField**, **URLField**, **SlugField** — с валидацией.\n**PrimaryKeyRelatedField(queryset=...)** — FK: в запросе/ответе **id**; **queryset** для валидации.\n**SlugRelatedField(slug_field=\'name\', queryset=...)** — FK по slug (или другому полю).\n**StringRelatedField** — FK в ответе как **str(объекта)**; только **read_only**.\n**SerializerMethodField()** — только чтение; значение задаётся методом **get_<field_name>(self, obj)**. Для вычисляемых полей.\n**HiddenField** — значение задаётся в коде (например **default=CurrentUserDefault()**), не из запроса.\n\n**Пример ModelSerializer с Meta и переопределением:**\n  from rest_framework import serializers\n  from .models import Article\n\n  class ArticleSerializer(serializers.ModelSerializer):\n      author_name = serializers.CharField(source=\'author.username\', read_only=True)\n      class Meta:\n          model = Article\n          fields = [\'id\', \'title\', \'body\', \'author\', \'author_name\', \'created_at\']\n          read_only_fields = [\'author\', \'created_at\']\n          extra_kwargs = {\'title\': {\'max_length\': 200}}\n\n  # В view:\n  # GET (один объект в ответ)\n  ArticleSerializer(instance)\n  # POST (создание)\n  ArticleSerializer(data=request.data)\n  # PATCH (частичное обновление)\n  ArticleSerializer(instance, data=request.data, partial=True)\n\n**Валидация.**\n**На уровне поля:** **required=False**, **default**, **allow_null**, **validators=[функция или класс]**.\n**validate_<field_name>(self, value)** — вызывается для одного поля после стандартной проверки; вернуть **value** или **raise serializers.ValidationError(\'msg\')**; для ошибки по полю: **ValidationError({\'field\': [\'msg\']})**.\n**validate(self, attrs)** — после проверки всех полей; **attrs** — словарь **validated_data**; вернуть **attrs** или **raise ValidationError**. Удобно для сравнения полей (например пароль и подтверждение).\n\n**read_only / write_only:** **read_only=True** — поле только в ответе (игнорируется при POST/PUT). **write_only=True** — только при вводе (не попадает в **.data** при сериализации; типично для пароля).\n\n**partial=True** — при обновлении проверяются только переданные поля; непереданные не требуются и не меняются. Для PATCH: **ArticleSerializer(instance, data=request.data, partial=True)**.\n\n**context** — словарь из view: **get_serializer_context()** возвращает **{\'request\', \'view\', \'format\', ...}**. В сериализаторе: **self.context[\'request\']**, **self.context.get(\'view\')**. Используют, чтобы подставить **request.user** в **create()**, или выбрать вариант сериализатора по **view.action**.\n\n**create(validated_data)** — создание объекта. **validated_data** — очищенные данные. Вернуть экземпляр модели. Пример: **validated_data.setdefault(\'author\', self.context[\'request\'].user)**; **return super().create(validated_data)**.\n\n**update(instance, validated_data)** — обновление **instance**. Вернуть обновлённый **instance**.\n\n**to_representation(self, instance)** — переопределить, чтобы изменить данные **на выход** (перед возвратом **.data**). Вызывается при сериализации объекта.\n\n**to_internal_value(self, data)** — переопределить, чтобы изменить/валидировать **входящие** данные до **validate_<field>** и **validate**.\n\n**Вложенные сериализаторы.**\n**В ответе (read):** указать вложенный класс — **user = UserSerializer(read_only=True)** — в JSON будет вложенный объект. Для списка связанных: **comments = CommentSerializer(many=True, read_only=True)**.\n**При записи (write):** обычно принимают только **id** — **author = serializers.PrimaryKeyRelatedField(queryset=User.objects.all())**. Либо два поля: отдельный **AuthorSerializer(read_only=True)** для ответа и **author_id = PrimaryKeyRelatedField(...)** для ввода, или один **PrimaryKeyRelatedField** без вложенного (в ответе будет только id).\n**Двусторонняя вложенность:** вложенный сериализатор для вывода; переопределить **create**/ **update**, чтобы из **validated_data** извлекать вложенные словари и создавать/обновлять связанные объекты.\n\n**many=True** — сериализация списка: **ArticleSerializer(queryset, many=True).data** возвращает список словарей. При **data=request.data** с массивом — **is_valid()** пройдёт по каждому элементу.\n\n**Кратко:** **Serializer** (поля вручную, **create**/ **update** сам) и **ModelSerializer** (Meta: **model**, **fields**, **read_only_fields**, **extra_kwargs**); поля **CharField**, **PrimaryKeyRelatedField**, **SerializerMethodField** и др.; валидация **validate_<field>**, **validate**; **read_only**, **write_only**, **partial**; **context**; **to_representation**, **to_internal_value**; вложенные сериализаторы и **many=True**.' },
  { id: 75, question: 'drf-spectacular', answer: '**drf-spectacular** — библиотека для автоматической генерации **OpenAPI 3.0** схемы из DRF-кода (views, serializers, filterset, pagination). Заменяет устаревший **drf-yasg**. На выходе — **Swagger UI** и **Redoc** для документации API.\n\n**Установка и подключение:**\n  pip install drf-spectacular\n\n**settings.py:**\n  INSTALLED_APPS = [..., \'drf_spectacular\']\n\n  REST_FRAMEWORK = {\n      \'DEFAULT_SCHEMA_CLASS\': \'drf_spectacular.openapi.AutoSchema\',\n  }\n\n  SPECTACULAR_SETTINGS = {\n      \'TITLE\': \'My API\',\n      \'DESCRIPTION\': \'Описание проекта\',\n      \'VERSION\': \'1.0.0\',\n      \'SERVE_INCLUDE_SCHEMA\': False,\n  }\n\n**URL-маршруты (urls.py):**\n  from drf_spectacular.views import (\n      SpectacularAPIView,\n      SpectacularSwaggerView,\n      SpectacularRedocView,\n  )\n  urlpatterns += [\n      path(\'api/schema/\', SpectacularAPIView.as_view(), name=\'schema\'),\n      path(\'api/docs/\', SpectacularSwaggerView.as_view(url_name=\'schema\'), name=\'swagger-ui\'),\n      path(\'api/redoc/\', SpectacularRedocView.as_view(url_name=\'schema\'), name=\'redoc\'),\n  ]\n\n**SpectacularAPIView** — отдаёт JSON/YAML-схему.\n**SpectacularSwaggerView** — интерактивный Swagger UI.\n**SpectacularRedocView** — документация в стиле Redoc.\n\n**Декоратор @extend_schema** — тонкая настройка документации для конкретного view / action:\n  from drf_spectacular.utils import extend_schema, OpenApiParameter, OpenApiExample\n\n  class ArticleViewSet(ModelViewSet):\n      ...\n      @extend_schema(\n          summary=\'Список статей\',\n          description=\'Возвращает статьи с пагинацией\',\n          parameters=[\n              OpenApiParameter(name=\'search\', type=str, description=\'Поиск по заголовку\'),\n          ],\n          responses={200: ArticleSerializer(many=True)},\n          tags=[\'articles\'],\n      )\n      def list(self, request, *args, **kwargs):\n          return super().list(request, *args, **kwargs)\n\n**@extend_schema_view** — задать **@extend_schema** для нескольких action разом (на уровне класса):\n  from drf_spectacular.utils import extend_schema_view\n\n  @extend_schema_view(\n      list=extend_schema(summary=\'Список\'),\n      retrieve=extend_schema(summary=\'Детали\'),\n      create=extend_schema(summary=\'Создать\'),\n  )\n  class ArticleViewSet(ModelViewSet):\n      ...\n\n**Основные параметры @extend_schema:**\n**summary** — краткое описание (заголовок endpoint).\n**description** — подробное описание.\n**parameters** — список **OpenApiParameter** (query, path, header, cookie).\n**request** — сериализатор или тип тела запроса.\n**responses** — словарь {код: сериализатор} или класс ответа.\n**tags** — группировка в Swagger UI.\n**exclude** — исключить endpoint из схемы: **@extend_schema(exclude=True)**.\n\n**OpenApiParameter** — описание query/path/header параметра: **name**, **type** (str, int, bool, OpenApiTypes), **location** (**query** / **path** / **header**), **required**, **description**, **enum** (варианты значений).\n\n**Кратко:** **drf-spectacular** = автоматическая **OpenAPI 3.0** схема из DRF; **SpectacularAPIView** (schema), **SpectacularSwaggerView** (Swagger UI), **SpectacularRedocView**; настройка через **@extend_schema** и **@extend_schema_view**; **SPECTACULAR_SETTINGS** в settings.py.' },
  { id: 77, question: 'Forms', answer: '**Django Forms** — механизм для создания HTML-форм, валидации данных и преобразования в Python-типы. Две базовые разновидности: **forms.Form** (произвольные поля) и **forms.ModelForm** (поля из модели).\n\n**Создание формы (Form):**\n  from django import forms\n\n  class ContactForm(forms.Form):\n      name = forms.CharField(max_length=100)\n      email = forms.EmailField()\n      message = forms.CharField(widget=forms.Textarea)\n      agree = forms.BooleanField(required=True)\n\n**Создание формы (ModelForm — поля из модели):**\n  class ArticleForm(forms.ModelForm):\n      class Meta:\n          model = Article\n          fields = [\\\'title\\\', \\\'body\\\', \\\'category\\\']\n          # fields = \\\'__all__\\\'          — все поля\n          # exclude = [\\\'author\\\']        — все кроме указанных\n\n**Обработка в представлении (FBV):**\n  def contact_view(request):\n      if request.method == \\\'POST\\\':\n          form = ContactForm(request.POST, request.FILES)\n          if form.is_valid():\n              data = form.cleaned_data\n              # data[\\\'name\\\'], data[\\\'email\\\'], ...\n              return redirect(\\\'success\\\')\n      else:\n          form = ContactForm()\n      return render(request, \\\'contact.html\\\', {\\\'form\\\': form})\n\n**Обработка ModelForm (автосохранение):**\n  def article_create(request):\n      if request.method == \\\'POST\\\':\n          form = ArticleForm(request.POST)\n          if form.is_valid():\n              article = form.save(commit=False)\n              article.author = request.user\n              article.save()\n              return redirect(article)\n      else:\n          form = ArticleForm()\n      return render(request, \\\'article_form.html\\\', {\\\'form\\\': form})\n\n**Обработка в CBV (CreateView / UpdateView):**\n  # **form_class** — указать класс формы\n  # **form_valid(form)** — вызывается после успешной валидации\n  # **form_invalid(form)** — при ошибках\n  # **get_form_kwargs()** — передать доп. аргументы в конструктор формы\n\n**Отображение в шаблоне:**\n  # **вся форма сразу:**\n  {{ form.as_p }}      — каждое поле в <p>\n  {{ form.as_div }}    — каждое поле в <div> (Django 5+)\n  {{ form.as_table }}  — строки <tr>\n\n  # **по полям вручную:**\n  {{ form.name.label_tag }}\n  {{ form.name }}\n  {{ form.name.errors }}\n  {{ form.name.help_text }}\n\n  # **ошибки формы целиком:**\n  {{ form.errors }}            — все ошибки (dict)\n  {{ form.non_field_errors }}  — ошибки не привязанные к полю\n\n**Типы полей (основные):**\n  forms.CharField(max_length=255)\n  forms.IntegerField(min_value=0)\n  forms.FloatField()\n  forms.DecimalField(max_digits=10, decimal_places=2)\n  forms.BooleanField()         — обязательный чекбокс (True)\n  forms.NullBooleanField()     — True / False / None\n  forms.EmailField()\n  forms.URLField()\n  forms.SlugField()\n  forms.DateField()            — date\n  forms.DateTimeField()        — datetime\n  forms.TimeField()            — time\n  forms.FileField()\n  forms.ImageField()           — файл + проверка картинки\n  forms.ChoiceField(choices=[(\\\'a\\\', \\\'Option A\\\'), ...])\n  forms.MultipleChoiceField(choices=[...])\n  forms.TypedChoiceField(choices=[...], coerce=int)\n  forms.ModelChoiceField(queryset=Category.objects.all())\n  forms.ModelMultipleChoiceField(queryset=Tag.objects.all())\n\n**Общие параметры полей:**\n  required=True         — обязательное (по умолчанию)\n  initial=\\\'значение\\\'   — значение по умолчанию\n  label=\\\'Имя\\\'          — текст label\n  help_text=\\\'подсказка\\\'\n  error_messages={\\\'required\\\': \\\'Обязательное поле\\\'}\n  disabled=True         — нередактируемое\n  validators=[...]      — список валидаторов\n\n**Виджеты (widget) — управление HTML-отображением:**\n  forms.TextInput          — <input type=\"text\">\n  forms.PasswordInput      — <input type=\"password\">\n  forms.HiddenInput        — <input type=\"hidden\">\n  forms.Textarea           — <textarea>\n  forms.NumberInput        — <input type=\"number\">\n  forms.EmailInput         — <input type=\"email\">\n  forms.URLInput           — <input type=\"url\">\n  forms.DateInput          — <input type=\"date\">\n  forms.DateTimeInput      — <input type=\"datetime-local\">\n  forms.CheckboxInput      — <input type=\"checkbox\">\n  forms.Select             — <select>\n  forms.SelectMultiple     — <select multiple>\n  forms.RadioSelect        — набор <input type=\"radio\">\n  forms.CheckboxSelectMultiple — набор чекбоксов\n  forms.FileInput          — <input type=\"file\">\n  forms.ClearableFileInput — файл + кнопка «очистить»\n\n**Назначение виджета и attrs:**\n  # **в поле напрямую:**\n  name = forms.CharField(widget=forms.TextInput(attrs={\\\'class\\\': \\\'form-control\\\', \\\'placeholder\\\': \\\'Имя\\\'}))\n  # **в Meta (ModelForm):**\n  class Meta:\n      widgets = {\n          \\\'body\\\': forms.Textarea(attrs={\\\'rows\\\': 5, \\\'class\\\': \\\'form-control\\\'}),\n          \\\'category\\\': forms.Select(attrs={\\\'class\\\': \\\'form-select\\\'}),\n      }\n\n**Встроенная валидация:**\n— Каждое поле проверяет тип и ограничения автоматически: **max_length**, **min_value**, **required**, формат email/url и т.д.\n— **ModelForm** дополнительно вызывает **model.full_clean()** (unique, unique_together).\n— Ошибки попадают в **form.errors** (dict: поле → список ошибок).\n\n**Пользовательская валидация:**\n  # **валидация одного поля — clean_<fieldname>():**\n  class ContactForm(forms.Form):\n      email = forms.EmailField()\n\n      def clean_email(self):\n          email = self.cleaned_data[\\\'email\\\']\n          if not email.endswith(\\\'@company.com\\\'):\n              raise forms.ValidationError(\\\'Только корпоративная почта\\\')\n          return email\n\n  # **валидация нескольких полей — clean():**\n  def clean(self):\n      cleaned = super().clean()\n      start = cleaned.get(\\\'start_date\\\')\n      end = cleaned.get(\\\'end_date\\\')\n      if start and end and start > end:\n          raise forms.ValidationError(\\\'Дата начала не может быть позже даты окончания\\\')\n      return cleaned\n\n  # **валидатор-функция (переиспользуемый):**\n  from django.core.validators import RegexValidator, MinLengthValidator\n\n  phone_validator = RegexValidator(r\\\'\\\\+7\\\\d{10}\\\', \\\'Формат: +7XXXXXXXXXX\\\')\n  phone = forms.CharField(validators=[phone_validator])\n\n  # **встроенные валидаторы:**\n  # MinValueValidator, MaxValueValidator, MinLengthValidator, MaxLengthValidator\n  # EmailValidator, URLValidator, RegexValidator, FileExtensionValidator\n\n**Порядок валидации:** field.clean() (тип + validators) → clean_<field>() → clean() (межполевая).\n\n**form.save(commit=False)** — создаёт объект модели, но **не сохраняет** в БД. Позволяет дополнить поля (author, slug) перед .save().\n\n**Кратко:** **Form** — произвольные поля; **ModelForm** — из модели + Meta (fields, widgets, exclude); отображение — **.as_p**, **.as_div**, по полям; обработка — **is_valid()** → **cleaned_data** / **form.errors**; валидация — **clean_<field>()** (одно поле), **clean()** (несколько), **validators=[...]** (переиспользуемые); виджеты — **widget=forms.XxxInput(attrs={...})** управляют HTML.' },
  { id: 78, question: 'Миксины для CBV', answer: '**Миксин** — класс, который добавляет поведение в **class-based view**, не являясь полноценным представлением. Обычно переопределяет один или несколько методов (**dispatch**, **get_queryset**, **get_context_data**, **form_valid** и т.д.) и **вызывает super()**, чтобы цепочка базовых классов не прервалась. Порядок наследования важен: **MRO** (Method Resolution Order) определяет, кто вызывается первым.\n\n**Зачем свои миксины:** переиспользовать логику (проверка прав, фильтрация queryset, доп. контекст) в нескольких view без копирования кода.\n\n**Базовые правила:**\n  # **миксин не наследует View — только object**\n  class MyMixin:\n      pass\n  # **в view миксин указывают перед базовым view (слева)**\n  class ArticleListView(MyMixin, ListView):\n      ...\n  # **в переопределённом методе обязательно super()**\n  def get_queryset(self):\n      qs = super().get_queryset()\n      return qs.filter(is_published=True)\n\n**Пример 1 — проверка доступа (аналог LoginRequiredMixin):**\n  from django.contrib.auth.mixins import LoginRequiredMixin\n  from django.http import HttpResponseForbidden\n\n  class OwnerRequiredMixin:\n      def dispatch(self, request, *args, **kwargs):\n          obj = self.get_object()\n          if obj.owner != request.user:\n              return HttpResponseForbidden()\n          return super().dispatch(request, *args, **kwargs)\n\n  class ArticleUpdateView(OwnerRequiredMixin, UpdateView):\n      model = Article\n      ...\n\n**Пример 2 — фильтрация queryset по пользователю:**\n  class UserQuerysetMixin:\n      def get_queryset(self):\n          return super().get_queryset().filter(author=self.request.user)\n\n  class MyDraftListView(UserQuerysetMixin, ListView):\n      model = Article\n      template_name = \'drafts.html\'\n\n**Пример 3 — добавление данных в контекст:**\n  class SidebarMixin:\n      def get_context_data(self, **kwargs):\n          kwargs.setdefault(\'categories\', Category.objects.all()[:10])\n          return super().get_context_data(**kwargs)\n\n  class ArticleDetailView(SidebarMixin, DetailView):\n      model = Article\n\n**Пример 4 — подстановка автора в форму (CreateView):**\n  class SetAuthorMixin:\n      def form_valid(self, form):\n          form.instance.author = self.request.user\n          return super().form_valid(form)\n\n  class ArticleCreateView(SetAuthorMixin, CreateView):\n      model = Article\n      fields = [\'title\', \'body\']\n\n**Пример 5 — настраиваемые атрибуты (классовые переменные в миксине):**\n  class PaginateByMixin:\n      paginate_by = 20\n\n  class FilterByStatusMixin:\n      status_filter = None\n\n      def get_queryset(self):\n          qs = super().get_queryset()\n          if self.status_filter is not None:\n              return qs.filter(status=self.status_filter)\n          return qs\n\n  class ArticleListView(FilterByStatusMixin, ListView):\n      model = Article\n      status_filter = \'published\'\n\n**Порядок наследования (MRO):** при вызове **get_queryset()** Python ищет метод слева направо: сначала в **FilterByStatusMixin**, затем в **ListView**, затем в **View**. Поэтому миксин вызывает **super().get_queryset()** — управление уходит в **ListView**, который вернёт **Model.objects.all()**; миксин может отфильтровать результат и вернуть его.\n\n**Что доступно в миксине через self:** **self.request**, **self.kwargs**, **self.args**, **self.object** (в DetailView/UpdateView/DeleteView после get_object), **self.get_object()**, **self.get_queryset()**, **self.get_form_class()**, **self.get_form_kwargs()**, **self.get_context_data()**, **self.get_success_url()** — всё, что предоставляют базовые view и другие миксины слева в MRO.\n\n**Встроенные миксины Django:** **LoginRequiredMixin** (redirect на логин), **PermissionRequiredMixin** (проверка прав), **UserPassesTestMixin** (test_func), **SuccessMessageMixin** (django.contrib.messages).\n\n**Кратко:** миксин — класс с методами и **super()**; порядок в наследовании важен (MRO); типичные переопределения — **dispatch**, **get_queryset**, **get_context_data**, **form_valid**; через **self** доступны request, kwargs, get_object, get_queryset и др.; можно задавать атрибуты (paginate_by, status_filter) для настройки в дочернем view.' },
  { id: 76, question: 'Основные запросы к БД (SQLAlchemy 2.0+)', answer: '**SQLAlchemy 2.0+** — новый стиль: **select()** + **session.execute()** вместо устаревшего session.query().\n\n**Импорты:**\n  from sqlalchemy import select, insert, update, delete, and_, or_, not_, func\n  from sqlalchemy.orm import Session, joinedload, selectinload\n\n**Сессия** — объект **Session** управляет транзакциями; в FastAPI получают через **Depends(get_db)**.\n\n**Цепочка результата:**\n  stmt = select(User)                        # → Select — SQL-конструкция\n  result = db.execute(stmt)                   # → Result[Row(User,)] — набор строк-кортежей\n  result.scalars()                            # → ScalarResult[User] — «развернул» кортежи, остались объекты\n  result.scalars().all()                      # → list[User]\n  result.scalars().first()                    # → User | None\n  result.scalar_one()                         # → User  (raises NoResultFound / MultipleResultsFound)\n  result.scalar_one_or_none()                 # → User | None  (raises если >1)\n  result.scalar()                             # → Any | None — первое значение первой строки\n  result.all()                                # → list[Row] — без .scalars() — строки-кортежи\n  result.first()                              # → Row | None — один кортеж\n  result.one()                                # → Row  (raises если 0 или >1)\n\n**Пример — Row (строка-кортеж) vs ORM-объект:**\n\n  # select(Model) — запрос целой модели\n  # **без .scalars() → Row — кортеж с одним элементом:**\n  row = db.execute(select(User)).first()\n  # row → (User(id=1, username=\'admin\'),)   ← Row-кортеж\n  # row[0] → <User id=1>                    ← ORM-объект внутри\n  # row[0].username → \'admin\'\n\n  # **с .scalars() → сразу ORM-объект:**\n  user = db.execute(select(User)).scalars().first()\n  # user → <User id=1>                      ← ORM-объект напрямую\n  # user.username → \'admin\'\n  # user.id → 1\n\n  # select(колонки) — запрос отдельных полей\n  # **всегда Row (scalars не нужен, иначе потеряете столбцы):**\n  row = db.execute(select(User.id, User.username, User.email)).first()\n  # row → (1, \'admin\', \'a@b.com\')           ← Row-кортеж\n  # row[0] → 1\n  # row.id → 1                              ← доступ по имени колонки\n  # row.username → \'admin\'\n  # row.email → \'a@b.com\'\n\n  # **список Row при .all():**\n  rows = db.execute(select(User.city, func.count(User.id)).group_by(User.city)).all()\n  # rows → [(\'Москва\', 42), (\'СПб\', 18)]   ← list[Row]\n  # rows[0].city → \'Москва\'\n  # rows[0][1] → 42\n\n**Чтение (SELECT):**\n  # **все записи → list[User]**\n  db.execute(select(User)).scalars().all()\n  # **фильтр по условию → list[User]**\n  db.execute(select(User).where(User.is_active == True)).scalars().all()\n  # **несколько условий (AND) → list[User]**\n  db.execute(select(User).where(User.age >= 18, User.is_active == True)).scalars().all()\n  # **исключить (NOT) → list[User]**\n  db.execute(select(User).where(User.is_staff != True)).scalars().all()\n  # **одна запись по pk → User | None**\n  db.get(User, 1)\n  # **первая запись → User | None**\n  db.execute(select(User)).scalars().first()\n  # **ровно одна; raises если 0 или >1 → User**\n  db.execute(select(User).where(User.id == 1)).scalar_one()\n  # **ровно одна или None; raises если >1 → User | None**\n  db.execute(select(User).where(User.id == 1)).scalar_one_or_none()\n  # **сортировка → list[User]**\n  db.execute(select(User).order_by(User.created_at.desc())).scalars().all()\n  # **количество → int**\n  db.execute(select(func.count()).select_from(User)).scalar()\n  # **проверка существования → bool**\n  db.execute(select(User).where(User.email == email)).scalars().first() is not None\n  # **уникальные значения → list[str]**\n  db.execute(select(User.city).distinct()).scalars().all()\n\n**Лукапы (условия в .where()):**\n  # **равно / не равно**\n  User.name == \'admin\'\n  User.name != \'admin\'\n  # **больше / меньше / >= / <=**\n  User.age > 18\n  User.age <= 65\n  # **LIKE / ILIKE (регистронезависимо)**\n  User.name.like(\'%test%\')\n  User.name.ilike(\'%test%\')\n  # **IN**\n  User.id.in_([1, 2, 3])\n  # **BETWEEN**\n  User.age.between(18, 65)\n  # **IS NULL / IS NOT NULL**\n  User.email.is_(None)\n  User.email.is_not(None)\n\n**AND, OR, NOT:**\n  # **OR → list[User]**\n  db.execute(select(User).where(or_(User.is_active == True, User.is_staff == True))).scalars().all()\n  # **AND (явно) → list[User]**\n  db.execute(select(User).where(and_(User.age >= 18, User.is_active == True))).scalars().all()\n  # **NOT → list[User]**\n  db.execute(select(User).where(not_(User.is_staff == True))).scalars().all()\n  # **отрицание через ~ → list[User]**\n  db.execute(select(User).where(~User.is_staff)).scalars().all()\n\n**Связи (загрузка):**\n  # **joinedload — JOIN (аналог select_related) → list[Order] (order.user уже загружен)**\n  db.execute(select(Order).options(joinedload(Order.user))).scalars().unique().all()\n  # **selectinload — WHERE id IN (...) (аналог prefetch_related) → list[User] (user.orders загружены)**\n  db.execute(select(User).options(selectinload(User.orders))).scalars().unique().all()\n  # **subqueryload — подзапрос → list[User]**\n  db.execute(select(User).options(subqueryload(User.orders))).scalars().unique().all()\n\n**.unique()** обязателен при joinedload / selectinload, т.к. JOIN может дублировать строки.\n\n**Агрегация:**\n  # **количество → int**\n  db.execute(select(func.count(User.id))).scalar()\n  # **сумма и среднее → Row(sum, avg) например (Decimal, Decimal)**\n  db.execute(select(func.sum(Order.total), func.avg(Order.total))).first()\n  # **группировка → list[Row(city, count)] например [(\\\'Москва\\\', 42), ...]**\n  db.execute(select(User.city, func.count(User.id)).group_by(User.city)).all()\n  # **HAVING → list[Row(city, count)]**\n  db.execute(select(User.city, func.count(User.id)).group_by(User.city).having(func.count(User.id) > 5)).all()\n\n**Создание (ORM-стиль — вызывает события, объект попадает в сессию):**\n  # **одна запись → после refresh: User с заполненным id**\n  user = User(username=\'a\', email=\'a@b.com\')\n  db.add(user)\n  db.commit()\n  db.refresh(user)\n  # **несколько записей**\n  db.add_all([User(username=\'a\'), User(username=\'b\')])\n  db.commit()\n\n**Создание (Core-стиль — insert(), быстрее, без ORM-событий):**\n  # **одна запись → CursorResult**\n  db.execute(insert(User).values(username=\'admin\', email=\'a@b.com\'))\n  db.commit()\n  # **bulk insert — список словарей → CursorResult (самый быстрый способ)**\n  db.execute(insert(User), [{\'username\': \'a\', \'email\': \'a@b.com\'}, {\'username\': \'b\', \'email\': \'b@b.com\'}])\n  db.commit()\n  # **returning — получить созданный объект (PostgreSQL, SQLite 3.35+) → User**\n  user = db.execute(insert(User).values(username=\'admin\').returning(User)).scalar_one()\n  db.commit()\n\n**Обновление (ORM-стиль — через объект, вызывает события):**\n  # **одна запись → User**\n  user = db.get(User, 1)\n  user.email = \'new@b.com\'\n  db.commit()\n\n**Обновление (Core-стиль — update(), быстрее, без ORM-событий):**\n  # **массовое → CursorResult (result.rowcount — кол-во затронутых)**\n  result = db.execute(update(User).where(User.is_active == False).values(is_active=True))\n  result.rowcount\n  db.commit()\n  # **returning → User**\n  user = db.execute(update(User).where(User.id == 1).values(email=\'new@b.com\').returning(User)).scalar_one()\n  db.commit()\n\n**Удаление (ORM-стиль — через объект, вызывает события):**\n  # **одна запись → None**\n  db.delete(user)\n  db.commit()\n\n**Удаление (Core-стиль — delete(), быстрее, без ORM-событий):**\n  # **массовое → CursorResult**\n  result = db.execute(delete(User).where(User.age < 0))\n  result.rowcount\n  db.commit()\n\n**ORM vs Core:** db.add / db.delete — **вызывают** ORM-события (before_insert и т.д.), объект отслеживается сессией. insert() / update() / delete() — **чистый SQL**, быстрее для массовых операций, но **не обновляют** объекты в сессии (нужен db.expire_all() или db.refresh()).\n\n**Срезы и выбор полей:**\n  # **первые 10 → list[User]**\n  db.execute(select(User).limit(10)).scalars().all()\n  # **пропустить + лимит → list[User]**\n  db.execute(select(User).offset(20).limit(10)).scalars().all()\n  # **только определённые поля → list[Row(id, username)]**\n  db.execute(select(User.id, User.username)).all()\n\n**Кратко:** **select(Model)** → Select; **db.execute()** → Result; **.scalars()** → ScalarResult (ORM-объекты); **.all()** → list; **.first()** → obj|None; **.scalar_one()** → obj (raises); **db.get(Model, pk)** → obj|None; без .scalars() — Row-кортежи; **update()** / **delete()** → CursorResult.' },
  { id: 71, question: 'Generic Foreign Key', answer: '**Generic Foreign Key (GFK)** — «универсальная» связь: позволяет ссылаться на **любую модель**, а не на одну конкретную. Используется, когда одна таблица (комментарии, лайки, теги, лог действий) должна ссылаться на записи **разных** таблиц.\n\n**Как устроена:** опирается на **ContentType** — встроенную модель Django, хранящую метаинформацию о каждой зарегистрированной модели (app_label + model). В модели с GFK объявляют **три поля:**\n\n**1. content_type** — **ForeignKey** на **ContentType**: указывает, **какая модель**.\n**2. object_id** — **PositiveIntegerField** (или другой тип pk): хранит **pk записи** в той модели.\n**3. content_object** — **GenericForeignKey(\'content_type\', \'object_id\')**: виртуальное поле (не создаёт колонку в БД); через него обращаются к связанному объекту как к обычному атрибуту.\n\n**Пример (модель Comment, привязываемая к любой модели):**\n  from django.db import models\n  from django.contrib.contenttypes.fields import GenericForeignKey, GenericRelation\n  from django.contrib.contenttypes.models import ContentType\n\n  class Comment(models.Model):\n      text = models.TextField()\n      content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)\n      object_id = models.PositiveIntegerField()\n      content_object = GenericForeignKey(\'content_type\', \'object_id\')\n\n  class Article(models.Model):\n      title = models.CharField(max_length=200)\n      comments = GenericRelation(Comment)\n\n  class Photo(models.Model):\n      url = models.URLField()\n      comments = GenericRelation(Comment)\n\n**Использование:**\n  # **создать комментарий к статье**\n  article = Article.objects.get(pk=1)\n  Comment.objects.create(text=\'Отлично!\', content_object=article)\n  # **создать комментарий к фото**\n  photo = Photo.objects.get(pk=5)\n  Comment.objects.create(text=\'Красиво!\', content_object=photo)\n  # **получить комментарии статьи (через GenericRelation)**\n  article.comments.all()\n  # **получить объект из комментария**\n  comment.content_object\n\n**GenericRelation** — обратная связь; объявляется в модели, на которую ссылается GFK. Даёт **related manager** (article.comments.all()) и позволяет каскадное удаление. Без **GenericRelation** обратный доступ невозможен (GFK не создаёт FK на уровне БД).\n\n**Когда использовать:** лайки, комментарии, теги, уведомления, логи — всё, что привязывается к **разным** моделям. Если связь всегда с **одной** моделью — обычный **ForeignKey** проще и эффективнее.\n\n**Минусы:** нет **ограничения на уровне БД** (нет настоящего FK-constraint); нельзя использовать **select_related** (только **prefetch_related**); сложнее фильтрация — нужно указывать **content_type** и **object_id**.\n\n**Кратко:** GFK = **content_type** (какая модель) + **object_id** (pk записи) + **GenericForeignKey** (виртуальное поле); обратная связь — **GenericRelation**; удобно для полиморфных связей (комментарии, лайки к любым моделям).' },
  { id: 70, question: 'Основные запросы к БД', answer: '**Чтение (SELECT):**\n  # **все записи**\n  User.objects.all()\n  # **отбор (AND по умолчанию)**\n  User.objects.filter(is_active=True)\n  # **несколько условий**\n  User.objects.filter(age__gte=18, is_active=True)\n  # **исключить**\n  User.objects.exclude(is_staff=True)\n  # **одна запись; исключение если 0 или &gt;1**\n  User.objects.get(id=1)\n  # **первая по дате (новые сверху)**\n  User.objects.order_by(\'-created_at\').first()\n  # **последняя по имени**\n  User.objects.order_by(\'name\').last()\n  # **уникальные строки**\n  User.objects.distinct()\n  # **число записей**\n  User.objects.count()\n  # **есть ли такая (True/False)**\n  User.objects.filter(email=email).exists()\n\n**Двойное подчёркивание (__): переход по связям и лукапы**\n\n**__** используется в двух случаях. (1) **Переход по связям** — обращение к полям связанной модели: фильтр «заказы, у которых пользователь с таким username»: **order.user** — связь, в **filter** пишем **user__username**. Цепочка: **user__profile__bio** (User → Profile → bio). (2) **Лукупы (тип сравнения)** — суффикс после имени поля: **age__gte=18**, **name__icontains=\'test\'**, **created_at__year=2024**, **id__in=[1,2,3]**, **email__isnull=True**. Связь и лукап вместе: **Order.objects.filter(user__is_active=True, total__gte=100)**.\n  # **фильтр по полю связанной модели**\n  Order.objects.filter(user__username=\'admin\')\n  # **цепочка связей**\n  User.objects.filter(profile__city=\'Moscow\')\n  # **лукапы: gte, icontains, in, year**\n  User.objects.filter(age__gte=18, username__icontains=\'john\')\n  Article.objects.filter(created_at__year=2024, id__in=[1, 2, 3])\n\n**Срезы и выбор полей:**\n  # **первые 10**\n  User.objects.all()[:10]\n  # **список словарей по полям**\n  User.objects.values(\'id\', \'username\')\n  # **плоский список id**\n  User.objects.values_list(\'id\', flat=True)\n  # **загрузить только эти поля**\n  Article.objects.only(\'id\', \'title\')\n  # **загрузить всё, кроме body**\n  Article.objects.defer(\'body\')\n\n**Связи (избежать N+1):**\n\n**select_related** — для **ForeignKey** и **OneToOne**. Делает один SQL-запрос с **JOIN**: заказы и связанные пользователи подтягиваются вместе. Обращение к **order.user** не вызывает доп. запрос. Передавать можно цепочку: **select_related(\'user\', \'user__profile\')**.\n  # **один запрос с JOIN, order.user уже в памяти**\n  Order.objects.select_related(\'user\').all()\n\n**prefetch_related** — для **обратной связи** (related_name) и **ManyToMany**. Отдельный запрос: сначала основные объекты, потом один запрос с **WHERE id IN (...)** за связанными; Django склеивает в Python. Подходит, когда с одной «главной» стороны много записей с другой (у пользователя — много заказов; у поста — много тегов).\n  # **два запроса: users, затем orders по user_id**\n  User.objects.prefetch_related(\'orders\').all()\n  # **посты + один запрос за теги**\n  Post.objects.prefetch_related(\'tags\').filter(is_published=True)\n\n**Аннотации и агрегация:**\n\n**annotate** — добавляет к **каждой строке** QuerySet вычисленное поле. Результат: по-прежнему список объектов (по одному на запись), у каждого есть новое атрибутивное поле (например **order_count**). Используют, когда нужно «на каждой записи» что-то посчитать (сколько у пользователя заказов, средняя цена по категории и т.п.).\n\n**aggregate** — считает **одно значение (или словарь значений) по всему** QuerySet. Результат: один словарь, а не список объектов. Используют для общей статистики: сумма по всем заказам, среднее, количество записей по всей выборке.\n\n**Разница:** **annotate** — «на каждую строку добавить поле» (результат — много строк). **aggregate** — «по всем строкам вычислить одно» (результат — одна сводка).\n\n  # **у каждой строки поле order_count**\n  User.objects.annotate(order_count=Count(\'orders\'))\n  # **одна строка: сумма и среднее**\n  Order.objects.aggregate(Sum(\'total\'), Avg(\'total\'))\n  # **именованный результат**\n  Order.objects.filter(user=u).aggregate(total_sum=Sum(\'total\'))\n\n**Q и F:**\n\n**Q** — объект для **сложных условий** в **filter** / **exclude**: логическое И (**&**), ИЛИ (**|**), отрицание (**~**). Обычный **filter(a=1, b=2)** — это только AND; для OR или комбинаций условия оборачивают в **Q(...)**.\n\n**F** — ссылка на **значение поля в БД** внутри запроса. Позволяет сравнивать поля между собой (**views &gt; likes**) и делать обновления по выражению (**views = views + 1**) прямо в SQL, без загрузки строк в Python.\n\n  # **OR**\n  User.objects.filter(Q(is_active=True) | Q(is_staff=True))\n  # **AND**\n  User.objects.filter(Q(age__gte=18) & Q(is_active=True))\n  # **сравнение полей в БД**\n  Article.objects.filter(views__gt=F(\'likes\'))\n  # **инкремент в БД**\n  Article.objects.filter(pk=1).update(views=F(\'views\') + 1)\n\n**Создание, обновление, удаление:**\n  # **одна запись**\n  User.objects.create(username=\'a\', email=\'a@b.com\')\n  # **много за один запрос**\n  User.objects.bulk_create([User(username=x) for x in [\'a\', \'b\']])\n  # **сохранить (create или update)**\n  user.save()\n  # **массовое обновление**\n  User.objects.filter(is_active=False).update(is_active=True)\n  # **удалить одну**\n  user.delete()\n  # **массовое удаление**\n  User.objects.filter(age__lt=0).delete()\n  # **найти или создать**\n  user, created = User.objects.get_or_create(username=\'a\', defaults={\'email\': \'a@b.com\'})\n  # **обновить или создать**\n  user, created = User.objects.update_or_create(username=\'a\', defaults={\'email\': \'new@b.com\'})\n\n**Прочие:**\n  # **словарь {id: instance}**\n  User.objects.in_bulk([1, 2, 3])\n  # **сырой SQL**\n  User.objects.raw(\'SELECT id, username FROM auth_user WHERE id = %s\', [1])\n  # **блокировка строк (транзакция)**\n  Order.objects.select_for_update().filter(user=user)\n  # **пустой QuerySet**\n  User.objects.none()\n  # **объединение двух QuerySet**\n  qs1.union(qs2)\n\n**Кратко:** чтение — **all**, **filter**, **exclude**, **get**, **order_by**, **values**, **count**, **exists**; связи — **select_related**, **prefetch_related**; **annotate**, **aggregate**; **Q**, **F**; **create**, **bulk_create**, **update**, **delete**, **get_or_create**, **update_or_create**; **only**, **defer**, **in_bulk**, **raw**, **select_for_update**.' }
];

/** Блоки: id, title, questionIds */
const BLOCKS = [
  { id: 'basic', title: 'Python Core', questionIds: [1, 2, 3, 4, 50, 5, 6, 7, 8, 11, 17, 18, 48, 49, 19, 20, 42, 43, 51, 52, 54, 55, 56] },
  { id: 'oop', title: 'OOP', questionIds: [9, 10, 12, 13, 14, 15, 16, 35, 36, 57] },
  { id: 'algorithms', title: 'Algorithms', questionIds: [40, 41] },
  { id: 'db', title: 'DB', questionIds: [21, 22, 23, 24, 25, 37, 38, 39, 61, 62] },
  { id: 'web', title: 'Web / Network / REST', questionIds: [26, 27, 28, 29] },
  { id: 'asyncio', title: 'Asyncio', questionIds: [44, 45, 46, 47] },
  { id: 'django-drf', title: 'Django + DRF', questionIds: [63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 77, 78] },
  { id: 'fastapi', title: 'FastAPI', questionIds: [76] },
  { id: 'architecture', title: 'Architecture / Patterns', questionIds: [30, 31, 32, 33, 34, 53, 58, 59, 60] }
];

(function () {
  const blocksEl = document.getElementById('blocks');
  const modalEl = document.getElementById('modal');
  const modalQuestion = modalEl.querySelector('.modal-question');
  const modalAnswer = modalEl.querySelector('.modal-answer');
  const modalClose = modalEl.querySelector('.modal-close');
  const modalBackdrop = modalEl.querySelector('.modal-backdrop');
  const modalContent = modalEl.querySelector('.modal-content');

  const questionsById = {};
  QUESTIONS.forEach(function (item) { questionsById[item.id] = item; });

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  /** В тексте **фраза** → жирное выделение (ключевые куски). */
  function formatKeyPhrases(rawLine) {
    const parts = rawLine.split(/\*\*(.+?)\*\*/g);
    let html = '';
    for (var i = 0; i < parts.length; i++) {
      var seg = escapeHtml(parts[i]);
      if (i % 2 === 1) html += '<strong class="answer-key">' + seg + '</strong>';
      else html += seg;
    }
    return html;
  }

  /** Строки с 2+ пробелов/таб — код; остальные — параграфы. Строки, оканчивающиеся на ":" — подзаголовки. **фраза** — ключевое. Пояснение (#) и следующая строка кода — одна пара с общей границей; между парами — пустая строка. */
  function formatAnswer(text) {
    if (!text || typeof text !== 'string') return '';
    const lines = text.split('\n');
    var out = '';
    var inCode = false;
    var pairOpen = false;
    for (var i = 0; i < lines.length; i++) {
      var line = lines[i];
      var isCodeLine = /^\s{2,}/.test(line) || /^\t/.test(line);
      if (isCodeLine) {
        if (!inCode) { out += '<pre class="answer-code"><code>'; inCode = true; }
        var trimmed = line.replace(/^\s+/, '');
        var isComment = trimmed.indexOf('#') === 0;
        if (isComment) {
          if (pairOpen) { out += '</span>'; pairOpen = false; }
          out += '<span class="answer-code-pair"><span class="answer-code-comment">' + escapeHtml(line) + '</span>';
          pairOpen = true;
        } else {
          if (pairOpen) {
            out += '<span class="answer-code-line">' + escapeHtml(line) + '</span>\n';
            out += '</span>';
            pairOpen = false;
          } else {
            out += escapeHtml(line) + '\n';
          }
        }
      } else {
        if (inCode) {
          if (pairOpen) { out += '</span>'; pairOpen = false; }
          out += '</code></pre>';
          inCode = false;
        }
        if (line.length) {
          var isHeading = line.slice(-1) === ':' && line.length < 160;
          var lineHtml = formatKeyPhrases(line);
          out += isHeading ? '<p class="answer-heading">' + lineHtml + '</p>' : '<p>' + lineHtml + '</p>';
        } else {
          out += '<p class="answer-space">&nbsp;</p>';
        }
      }
    }
    if (inCode) {
      if (pairOpen) out += '</span>';
      out += '</code></pre>';
    }
    return out;
  }

  function openModal(item) {
    modalQuestion.textContent = item.question;
    modalAnswer.innerHTML = formatAnswer(item.answer);
    modalEl.classList.add('modal-open');
    document.body.style.overflow = 'hidden';
  }

  function closeModal() {
    modalEl.classList.remove('modal-open');
    document.body.style.overflow = '';
  }

  BLOCKS.forEach(function (block) {
    const section = document.createElement('section');
    section.className = 'block block--collapsed';
    section.id = block.id;
    const h2 = document.createElement('h2');
    h2.className = 'block-title';
    const toggle = document.createElement('span');
    toggle.className = 'block-title-toggle';
    toggle.setAttribute('aria-hidden', 'true');
    toggle.textContent = '\u25BE';
    h2.appendChild(toggle);
    h2.appendChild(document.createTextNode(block.title));
    h2.addEventListener('click', function () {
      section.classList.toggle('block--collapsed');
    });
    section.appendChild(h2);
    const cardsWrap = document.createElement('div');
    cardsWrap.className = 'cards';
    block.questionIds.forEach(function (qId, index) {
      const item = questionsById[qId];
      if (!item) return;
      const card = document.createElement('div');
      card.className = 'card';
      const numInBlock = index + 1;
      card.innerHTML = '<span class="card-id">' + numInBlock + '</span><span class="card-question">' + escapeHtml(item.question) + '</span>';
      card.addEventListener('click', function () { openModal(item); });
      cardsWrap.appendChild(card);
    });
    section.appendChild(cardsWrap);
    blocksEl.appendChild(section);
  });

  modalClose.addEventListener('click', closeModal);
  modalBackdrop.addEventListener('click', closeModal);
  modalContent.addEventListener('click', function (e) { e.stopPropagation(); });
  modalEl.addEventListener('click', function (e) {
    if (e.target === modalEl) closeModal();
  });
  document.addEventListener('keydown', function (e) {
    if (e.key === 'Escape' && modalEl.classList.contains('modal-open')) closeModal();
  });

  const btn500 = document.getElementById('btn-500');
  const screen500 = document.getElementById('screen-500');
  if (btn500 && screen500) {
    btn500.addEventListener('click', function () {
      document.body.classList.add('screen-500-active');
      document.body.style.overflow = 'hidden';
      screen500.classList.add('is-active');
      screen500.setAttribute('aria-hidden', 'false');
    });
    screen500.addEventListener('click', function () {
      document.body.classList.remove('screen-500-active');
      document.body.style.overflow = '';
      screen500.classList.remove('is-active');
      screen500.setAttribute('aria-hidden', 'true');
    });
  }
})();
