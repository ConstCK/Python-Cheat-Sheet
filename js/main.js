/** Вопросы и ответы: id, question, answer. id — строго по порядку 1, 2, 3, … N; при добавлении/удалении пересчитывать и обновлять questionIds в BLOCKS. */
const QUESTIONS = [
  { id: 1, question: 'Что такое Python?', answer: '**Python** — высокоуровневый **интерпретируемый** язык с **динамической** и **строгой типизацией**.\n\n**Интерпретируемый:** код не компилируется в машинный язык заранее; в CPython он превращается в байт-код и выполняется виртуальной машиной «на лету», без отдельного шага сборки в исполняемый файл.\n\n**Типизация:** динамическая — тип переменной определяется в runtime (одна и та же переменная может ссылаться на объекты разных типов); строгая — неявных приведений типов почти нет (например, нельзя сложить строку и число без явного преобразования).\n\n**Под капотом (CPython), по шагам:**\n1. Исходный код (.py) парсится в AST (Абстрактное синтаксическое дерево).\n2. AST компилируется в байт-код (.pyc).\n3. Байт-код выполняется виртуальной машиной (PVM).\n4. Результат — переносимость между платформами без перекомпиляции.\n\n**Сборщик мусора:** основной механизм — **подсчёт ссылок (reference counting):** у каждого объекта хранится счётчик — сколько ссылок на него указывает; при создании ссылки счётчик увеличивается, при удалении ссылки — уменьшается; когда счётчик становится 0, объект сразу освобождается. Дополнительно модуль **gc** находит циклы ссылок (A → B → C → A), где счётчики не обнуляются, и помечает такие объекты для удаления.' },
  { id: 2, question: 'Какие типы данных есть в Python?', answer: 'Типы делятся на **изменяемые** и **неизменяемые**.\n\n**Изменяемые:** list, dict, set — могут изменяться после создания.\n\n**Неизменяемые:** int, float, complex, bool, str, tuple, frozenset — при изменении создаётся новый объект.' },
  { id: 3, question: 'Какие структуры данных есть в Python?', answer: '**Встроенные:** список (динамический массив), кортеж (неизменяемая последовательность), словарь (хэш-таблица), множество, строка, range.\n\n**Через библиотеки или свои реализации:** стек, очередь, деревья и графы.' },
  { id: 4, question: 'Что такое lambda-функция?', answer: '**Lambda** — анонимная функция, ограниченная одним выражением.\n\nЧаще всего используется как аргумент **функций высшего порядка** (map, filter, sorted) или там, где полноценное def избыточно.\n\nПример:\n  square = lambda x: x ** 2\n  evens = filter(lambda x: x % 2 == 0, [1, 2, 3, 4])\n  sorted(users, key=lambda u: u[\'name\'])' },
  { id: 5, question: 'Что такое генератор?', answer: '**Генератор** — объект, возвращающий значения по одному по запросу (**ленивые вычисления**). Реализует протокол итератора (__iter__, __next__), при исчерпании выбрасывает **StopIteration**.\n\n**Создание:** функция с **yield** или **generator comprehension** (x for x in ...). Экономят память — не хранят всю последовательность сразу.\n\n**Методы:**\n**next(g)** / **g.__next__()** — следующее значение.\n**g.send(value)** — отправить значение в генератор (оно подставляется в выражение yield). Перед первым **send(value)** нужно «прогнать» генератор до первого yield — вызвать **send(None)** или **next(g)**; иначе некуда подставлять value.\n**g.throw(exc)** — выбросить исключение внутри генератора.\n**g.close()** — завершить генератор.\n\n**return** в теле генератора: завершает генератор; в Python 3.3+ значение после return попадает в атрибут **StopIteration.value** (при переборе через for не видно, только при ручном next).\n\nПример с yield:\n  def count_to(n):\n    for i in range(n):\n      yield i\n  g = count_to(3)\n  next(g)  # 0\n  next(g)  # 1\n\nПример generator comprehension:\n  squares = (x ** 2 for x in range(5))\n  list(squares)  # [0, 1, 4, 9, 16]' },
  { id: 6, question: 'Что такое итератор?', answer: '**Итератор** — объект, поддерживающий **протокол итерации** (__iter__, __next__).\n\nХранит текущее состояние перебора и выбрасывает **StopIteration**, когда элементы заканчиваются.\n\nПример итератора на уровне класса:\n  class CountDown:\n    def __init__(self, start):\n      self.current = start\n    def __iter__(self):\n      return self\n    def __next__(self):\n      if self.current <= 0:\n        raise StopIteration\n      value = self.current\n      self.current -= 1\n      return value\n  for x in CountDown(3):\n    print(x)  # 3, 2, 1' },
  { id: 7, question: 'Что такое list/dict comprehension?', answer: '**Comprehension** — синтаксический сахар для компактного создания коллекций (list, dict, set). Повышает читаемость и часто быстрее эквивалентных циклов for.\n\n**List comprehension:**\n  [x ** 2 for x in range(5)]           # [0, 1, 4, 9, 16]\n  [x for x in nums if x % 2 == 0]     # только чётные\n  [x if x > 0 else 0 for x in nums]  # тернарный (else обязателен)\n\n**С несколькими for и if:**\n  [(i, j) for i in range(2) for j in range(2) if i != j]  # [(0,1), (1,0)]\n  [x for row in matrix for x in row]  # «развернуть» матрицу в список\n\n**Dict comprehension:**\n  {k: v * 2 for k, v in d.items()}\n  {x: x ** 2 for x in range(5) if x % 2 == 0}  # {0: 0, 2: 4, 4: 16}\n\n**Set comprehension:**\n  {abs(x) for x in [-1, 1, -2, 2]}  # {1, 2}' },
  { id: 8, question: 'Что такое *args и **kwargs?', answer: 'Используются для передачи **переменного количества аргументов**.\n\n***args** — собирает позиционные аргументы в **кортеж**.\n\n****kwargs** — именованные аргументы в **словарь**. Часто применяются в декораторах и обёртках.\n\nПримеры в функции:\n  def f(*args):\n    print(args)  # кортеж\n  f(1, 2, 3)   # (1, 2, 3)\n\n  def g(**kwargs):\n    print(kwargs)  # словарь\n  g(a=1, b=2)     # {\'a\': 1, \'b\': 2}\n\n  def h(*args, **kwargs):\n    print(args, kwargs)\n  h(1, 2, x=3)   # (1, 2) {\'x\': 3}' },
  { id: 9, question: 'Основные принципы ООП', answer: '**Абстракция** — выделение существенных свойств объекта и сокрытие деталей. Модель описывает «что» объект делает, а не «как». В коде: абстрактные классы, интерфейсы, минимальный публичный контракт.\n\n**Инкапсуляция** — скрытие внутреннего состояния и реализации; доступ только через методы (или свойства). Защита от некорректного изменения данных, возможность менять реализацию без слома клиентов. В Python: соглашение об именовании (_protected, __private), property, дескрипторы.\n\n**Типы атрибутов (по именованию):** **public** — без подчёркивания, открытый интерфейс. **Protected** — одно подчёркивание **_name**: соглашение «внутренний, не для внешнего кода»; доступ не запрещён, но не рекомендуется. **Private** — два подчёркивания **__name**: имя манглится в **_Class__name**, чтобы уменьшить коллизии при наследовании; извне класса обращаться неудобно (но технически возможно). Один trailing underscore (**name_**) — чтобы не конфликтовать с ключевыми словами. В Python нет жёсткой блокировки доступа, только соглашения и name mangling.\n\n**Наследование** — подкласс получает поля и методы базового класса, может переопределять и дополнять. Повторное использование кода и выражение иерархии «является» (is-a).\n\n**Полиморфизм** — один интерфейс (имя метода, сигнатура), разное поведение у разных типов. Вызывающий код работает с абстракцией, не зная конкретный класс. В Python — утиная типизация: важна поддержка нужных методов, а не явное наследование.' },
  { id: 10, question: 'Разница между __new__(), __init__(), __call__()?', answer: '**__new__** — создаёт объект в памяти (возвращает экземпляр).\n\n**__init__** — инициализирует уже созданный объект (self уже есть).\n\n**__call__** — позволяет вызывать экземпляр класса как функцию.\n\nПример (import не нужен — всё встроено):\n  class A:\n    def __new__(cls, x):\n      obj = super().__new__(cls)\n      return obj\n    def __init__(self, x):\n      self.x = x\n    def __call__(self, y):\n      return self.x + y\n  a = A(10)   # 1) __new__(A, 10) создаёт объект, 2) __init__(a, 10) задаёт a.x = 10\n  a(5)       # 15 — вызывается __call__(a, 5), возвращает a.x + 5' },
  { id: 11, question: 'Что такое декоратор?', answer: '**Декоратор** — функция высшего порядка: принимает функцию (или класс) и возвращает новую, оборачивая исходную и расширяя её поведение. Не меняет код самой функции.\n\nСинтаксис **@decorator** над определением функции эквивалентен присваиванию: `func = decorator(func)`.\n\nЧасто используется для **логирования**, **авторизации**, **кэширования**, замеров времени, повторных попыток.\n\nПример (логирование вызова):\n  def log(f):\n    def wrap(*args, **kwargs):\n      print(\'call\', f.__name__)\n      return f(*args, **kwargs)\n    return wrap\n  @log\n  def add(a, b):\n    return a + b\n  add(1, 2)   # print \"call add\", затем 3\n\nПример (декоратор с аргументами — фабрика декораторов):\n  def repeat(n):\n    def dec(f):\n      def wrap(*a, **k):\n        for _ in range(n): f(*a, **k)\n      return wrap\n    return dec\n  @repeat(2)\n  def say(): print(\'hi\')\n  say()   # hi hi' },
  { id: 12, question: 'Что такое дескрипторы?', answer: '**Дескрипторы** — классы, управляющие доступом к атрибутам других классов. Реализуют **__get__**, **__set__** (опционально), **__delete__** (опционально). Используются в **property**, ORM и системах валидации.\n\nПример:\n  class NonNegative:\n    def __init__(self, name):\n      self.name = name\n    def __get__(self, obj, type=None):\n      return obj.__dict__.get(self.name, 0)\n    def __set__(self, obj, value):\n      if value < 0:\n        raise ValueError(\'must be >= 0\')\n      obj.__dict__[self.name] = value\n  class Product:\n    price = NonNegative(\'price\')\n  p = Product()\n  p.price = 10   # ok\n  p.price = -1   # ValueError' },
  { id: 13, question: '@staticmethod / @classmethod / @property', answer: '**@staticmethod** — метод без доступа к self и cls; вызывается как **Class.method()** или **obj.method()**. Удобен для утилит, логически привязанных к классу (валидация, форматирование).\n\n**@classmethod** — первым аргументом получает **cls** (сам класс). Может создавать экземпляры, альтернативные конструкторы; доступ к атрибутам класса и наследованию.\n\n**@property** — когда обращаешься к атрибуту как к полю (**obj.x**), вызывается метод (чтение). Можно возвращать вычисленное значение. Если добавить **@x.setter** — тот же метод вызывается при присваивании (**obj.x = value**). Без setter атрибут только для чтения.\n\nПример:\n  class C:\n    x = 0\n    @staticmethod\n    def check(v): return v > 0\n    @classmethod\n    def from_pair(cls, a, b): return cls(a + b)\n    def __init__(self, val): self.val = val\n    @property\n    def double(self): return self.val * 2\n  C.check(1)       # True\n  c = C.from_pair(1, 2)  # c.val == 3\n  c.double         # 6 (без скобок)' },
  { id: 14, question: 'Что такое __slots__', answer: '**__slots__** — кортеж или список имён разрешённых атрибутов экземпляра. Ограничивает динамическое добавление атрибутов (только перечисленные в __slots__) и убирает **__dict__** у экземпляров, что снижает потребление памяти. Важно при большом количестве объектов.\n\n**Наследники:** если подкласс **не задаёт** свой __slots__, у его экземпляров появляется **__dict__** (можно добавлять атрибуты). Если подкласс задаёт **__slots__**, он обычно перечисляет и свои новые имена; слоты родителя наследуются, у экземпляров подкласса снова нет __dict__ (только слоты родителя + свои). Пустой **__slots__ = ()** в подклассе сохраняет слоты родителя без добавления своих и без __dict__.' },
  { id: 15, question: 'Что такое MRO?', answer: '**MRO** (Method Resolution Order) — порядок, в котором Python ищет метод (или атрибут) при **множественном наследовании**: обход базовых классов слева направо по списку наследования, без повторного посещения одного класса.\n\nЗачем нужен: при «ромбе» (A → B, C → D(B, C)) однозначно решить, какой метод вызвать. Алгоритм **C3** строит линейный порядок так, что: порядок в объявлении класса сохраняется; если класс X наследует от Y, то в MRO X идёт перед Y. Гарантирует предсказуемый и устойчивый к изменениям порядок.\n\nПример:\n  class A: pass\n  class B(A): pass\n  class C(A): pass\n  class D(B, C): pass\n  print(D.__mro__)\n  # (D, B, C, A, object)\n  # поиск метода: сначала D, потом B, потом C, потом A, потом object' },
  { id: 16, question: 'Что такое метаклассы?', answer: '**Метакласс** — класс класса: объект класса является экземпляром своего метакласса. По умолчанию метакласс — **type**. При определении класса вызываются **__new__** и **__init__** метакласса (а не обычного класса). Чтобы изменить пространство имён класса (dct) до создания класса — важно переопределить **__new__**; **__init__** получает уже созданный класс и подходит для постобработки.\n\nИспользуются для **валидации** (проверка атрибутов/наследования при создании класса), **регистрации** классов (реестры, плагины), построения фреймворков (ORM, API), автоматического добавления методов или атрибутов.\n\nПример (метакласс добавляет атрибут):\n  class Meta(type):\n    def __new__(mcs, name, bases, dct):\n      dct[\'created_by\'] = \'Meta\'\n      return super().__new__(mcs, name, bases, dct)\n  class A(metaclass=Meta): pass\n  print(A.created_by)   # Meta' },
  { id: 35, question: 'Основные дандер-методы класса', answer: '**Дандеры** (double underscore) — специальные методы, которые вызываются операторами и встроенными функциями.\n\n**Создание и инициализация:**\n**__new__(cls, ...)** — создаёт объект в памяти; **__init__(self, ...)** — инициализирует уже созданный экземпляр.\n\n**Строковое представление:**\n**__str__(self)** — вызывается **str(obj)** и **print(obj)**; для пользователя. **__repr__(self)** — **repr(obj)** и отображение в интерпретаторе; желательно однозначное представление для отладки.\n\n**Сравнение и хэш:**\n**__eq__(self, other)** — оператор **==**. **__hash__(self)** — **hash(obj)**; нужен для использования в **set** и как ключ **dict**; если переопределяете __eq__, обычно нужно переопределить __hash__ (неизменяемые объекты).\n\n**Коллекции и доступ:**\n**__len__(self)** — вызывается **len(obj)**; должен возвращать неотрицательное целое (размер коллекции).\n\n**__getitem__(self, key)** — **obj[key]**; чтение по ключу/индексу; для **in** и итерации по индексу используется, если нет __iter__.\n\n**__setitem__(self, key, value)** — **obj[key] = value**; запись по ключу/индексу (для изменяемых коллекций).\n\n**__iter__(self)** — вызывается **iter(obj)** и в **for**; должен возвращать итератор (объект с **__next__**). **__next__(self)** — следующий элемент; вызывается **next(iterator)**; в конце выбрасывает **StopIteration**.\n\n**Доступ к атрибутам:**\n**__getattr__(self, name)** — вызывается, когда атрибут **не найден** в обычном поиске (self.name, getattr); удобен для «ленивых» атрибутов и прокси.\n\n**__getattribute__(self, name)** — вызывается **при каждом** обращении к атрибуту (до поиска в __dict__); легко зациклить (обращение к self внутри), обычно используют **object.__getattribute__(self, name)**.\n\n**__setattr__(self, name, value)** — вызывается при **присваивании** атрибута **obj.name = value**; внутри избегать прямого self.name = ... (вызовет рекурсию), использовать **object.__setattr__(self, name, value)** или **self.__dict__[name] = value**.\n\n**Вызов и контекст:**\n**__call__(self, ...)** — вызов экземпляра как функции **obj(...)**. **__enter__(self)**, **__exit__(self, ...)** — контекстный менеджер **with obj:**.' },
  { id: 36, question: 'Геттеры, сеттеры и делитеры', answer: '**Геттер** — метод для чтения атрибута; **сеттер** — для записи; **делитер** — для удаления (del obj.attr). В Python их реализуют через **@property** и опционально **@имя.setter**, **@имя.deleter** — обращение к атрибуту выглядит как к полю (obj.x), но вызываются методы.\n\n**@property** — метод вызывается при **чтении** obj.x; можно вычислять значение, кэшировать, проверять доступ.\n\n**@x.setter** — вызывается при **присваивании** obj.x = value; удобно для валидации или побочных эффектов.\n\n**@x.deleter** — вызывается при **del obj.x**; освобождение ресурсов или сброс состояния.\n\nПример:\n  class C:\n    def __init__(self):\n      self._x = 0\n    @property\n    def x(self):\n      return self._x\n    @x.setter\n    def x(self, v):\n      if v < 0: raise ValueError(\'x >= 0\')\n      self._x = v\n    @x.deleter\n    def x(self):\n      self._x = 0\n  c = C()\n  c.x = 10\n  print(c.x)   # 10\n  del c.x\n  print(c.x)   # 0' },
  { id: 17, question: 'Что такое GIL?', answer: '**GIL** (Global Interpreter Lock) — блокировка, ограничивающая одновременное выполнение байт-кода **одним потоком** в CPython.\n\n**Для чего:** избежание **race conditions** (гонок). Race condition — когда два потока одновременно читают или меняют одни и те же данные и результат зависит от порядка выполнения (данные могут испортиться). В CPython используется **подсчёт ссылок** — без GIL два потока могли бы менять счётчик одного объекта одновременно. GIL гарантирует, что байт-код выполняется только одним потоком в момент времени, защищая внутренние структуры и C-расширения.\n\nМинус: снижает эффективность **CPU-bound** задач в потоках; для параллелизма по CPU — процессы (multiprocessing) или альтернативы (PyPy, Jython).' },
  { id: 18, question: 'Поверхностная и глубокая копия', answer: '**Shallow copy** — копирует только верхний уровень (вложенные объекты — по ссылке). **Deep copy** — рекурсивно копирует все вложенные объекты.\n\nПримеры:\n  import copy\n  a = [1, [2, 3]]\n  s = copy.copy(a)      # или a.copy(), a[:]\n  d = copy.deepcopy(a)\n  s[1][0] = 99\n  print(a[1][0])       # 99 — вложенный список общий у a и s\n  d[1][0] = 100\n  print(a[1][0])       # 99 — у d свой вложенный список' },
  { id: 19, question: 'O-нотация и сложность операций (list, dict, set)', answer: '**O-нотация** описывает **асимптотическую сложность** алгоритма по времени или памяти при росте n (размера данных). Позволяет сравнивать решения независимо от железа.\n\n**list:**\nдоступ по индексу — O(1); добавление в конец append — O(1); вставка/удаление по индексу — O(n); поиск in / index (при указании значения) — O(n); сортировка — O(n log n); срез [i:j] — O(j−i).\n\n**tuple / str:**\nдоступ по индексу — O(1); поиск in — O(n); неизменяемы (создание копии при «изменении» — O(n)).\n\n**dict:**\nвставка, доступ по ключу, удаление — в среднем O(1); в худшем (плохой хэш, коллизии) — O(n); итерация — O(n).\n\n**set:**\nadd, in, remove — в среднем O(1); в худшем O(n); операции над множествами (объединение, пересечение) — до O(n+m).\n\n**deque** (collections):\nappend/popleft с обоих концов — O(1); доступ по индексу в середине — O(n).' },
  { id: 20, question: 'Что такое рекурсия?', answer: '**Рекурсия** — подход, при котором функция вызывает саму себя для решения подзадачи того же типа.\n\n**Базовый случай** — условие, при котором функция возвращает результат без вызова себя (останавливает цепочку). Без него — бесконечные вызовы и **RecursionError** (в Python лимит стека вызовов).\n\n**Рекурсивный случай** — вызов себя с упрощёнными аргументами (шаг к базовому случаю).\n\nКаждый вызов кладётся в **стек вызовов**; при большой глубине возможен переполнение стека. В Python **хвостовая рекурсия** не оптимизируется (в отличие от некоторых языков), поэтому при очень большой глубине часто используют цикл или явный стек.\n\nУдобна для обхода деревьев/графов, разбиения задачи (divide and conquer), рекурсивных структур данных.\n\nПример (факториал):\n  def fact(n):\n    if n <= 1:\n      return 1\n    return n * fact(n - 1)\n  fact(4)   # 24' },
  { id: 21, question: 'Что такое ORM?', answer: '**ORM** (Object Relational Mapping) связывает **объектную модель** приложения с **реляционной моделью** БД.\n\nСкрывает SQL-логику за Python-объектами: модели (таблицы), запросы, связи (FK, many-to-many).\n\n**Популярные ORM в Python:**\n**Django ORM** (в составе Django), **SQLAlchemy** (универсальная, часто с Flask/FastAPI), **Peewee** (лёгкая), **Tortoise ORM** (async), **Pony ORM**, **SQLObject**.' },
  { id: 22, question: 'Что такое миграции?', answer: '**Миграции** — механизм **версионирования схемы БД**, позволяющий безопасно изменять структуру таблиц (создание, изменение, удаление). Файлы миграций хранят историю изменений; применяются по порядку (вверх/откат).\n\n**Инструменты:** **Django** (встроенные миграции, `manage.py migrate`), **Alembic** (для SQLAlchemy), **Flask-Migrate** (Alembic под Flask), **Tortoise ORM** (aerich), **Peewee** (встроенный migrator).' },
  { id: 23, question: 'Что такое транзакция?', answer: '**Транзакция** — последовательность операций с БД, которая выполняется как **единое целое**: либо все операции применяются (**COMMIT**), либо все отменяются (**ROLLBACK**). Гарантирует **атомарность**: при ошибке или явном откате изменения не частично сохраняются.\n\nОбычный цикл: **BEGIN** (начало транзакции) → операции (INSERT, UPDATE, DELETE, SELECT) → **COMMIT** (подтвердить) или **ROLLBACK** (отменить). В многих драйверах и ORM транзакция начинается неявно при первом запросе; autocommit может быть включён по умолчанию (каждый запрос — отдельная транзакция).\n\nИспользуют, когда несколько операций должны быть выполнены вместе: перевод между счетами, создание заказа с позициями, обновление связанных таблиц. Без транзакции сбой посередине оставит БД в несогласованном состоянии.' },
  { id: 24, question: 'Что такое ACID?', answer: '**ACID** — набор гарантий корректности транзакций в БД.\n\n**Атомарность (Atomicity):** транзакция выполняется целиком или не выполняется вовсе. Пример: перевод денег A→B — списание с A и зачисление на B либо оба шага, либо откат обоих; нельзя «списали с A, упало до зачисления на B».\n\n**Согласованность (Consistency):** после транзакции БД остаётся в допустимом состоянии: соблюдаются ограничения, ключи, инварианты и **связи между таблицами** (FK, CHECK). Пример: сумма на счетах до и после перевода не меняется.\n\n**Изолированность (Isolation):** параллельные транзакции не «видят» незакоммиченные изменения друг друга; результат как при некотором порядке выполнения.\n\n**Уровни изоляции** (от слабого к сильному):\n**READ UNCOMMITTED** — видны даже незакоммиченные данные (грязное чтение).\n\n**READ COMMITTED** — видны только закоммиченные; повторное чтение той же строки может дать другое значение (неповторяемое чтение).\n\n**REPEATABLE READ** — в рамках транзакции повторный запрос возвращает те же строки; возможны фантомы (новые строки, появившиеся в другой транзакции).\n\n**SERIALIZABLE** — строгая изоляция, как будто транзакции выполняются по одной; фантомов нет. Чем выше уровень, тем строже изоляция и обычно ниже параллелизм.\n\n**По умолчанию в популярных БД:** **PostgreSQL** — READ COMMITTED. **MySQL** (InnoDB) — REPEATABLE READ. **SQL Server**, **Oracle** — READ COMMITTED.\n\n**Надёжность (Durability):** закоммиченные данные сохраняются при сбое (журнал, WAL). Пример: после COMMIT данные не пропадут при отключении питания.' },
  { id: 25, question: 'Что такое индексирование БД?', answer: '**Индексирование** — создание дополнительных структур данных (**индексов**) для ускорения **поиска**, **фильтрации** и **сортировки** по столбцам. Индекс хранит значения столбца(ов) и ссылки на строки таблицы; **хранится в той же БД на диске** — в отдельных файлах/структурах, которыми управляет СУБД (таблица с данными не дублируется). Запросы по индексированным полям выполняются быстрее (часто без полного скана таблицы). Плата: замедление вставки/обновления/удаления и дополнительное место на диске.\n\n**Типы индексов:** **B-tree** — универсальный, диапазоны и сортировка (по умолчанию во многих БД). **Hash** — точечный поиск по равенству (ключ = значение). **GiST, GIN** — полнотекстовый поиск, геоданные, массивы (PostgreSQL). **BRIN** — для очень больших таблиц с естественным порядком (PostgreSQL).\n\n**Реализация в БД:** **PostgreSQL** — B-tree по умолчанию, hash, GiST, GIN, BRIN, частичные и составные индексы. **MySQL** — B-tree (InnoDB), hash для MEMORY. **SQLite** — B-tree. **MongoDB** — B-tree по умолчанию, hash, гео, полнотекст. Конкретный синтаксис (CREATE INDEX, опции) зависит от СУБД.' },
  { id: 37, question: 'Что такое шардирование?', answer: '**Шардирование** — когда одну большую таблицу **разносят по разным серверам (БД)**. Каждый сервер хранит свою часть строк — это и есть **шард**. По какой строке куда попадёт — решают по правилу: например, по **user_id** (все заказы пользователя на одном шарде), по региону или по хэшу от ключа.\n\n**Какое бывает (по способу выбора шарда):**\n**По диапазону (range)** — ключ попадает в диапазон (user_id 1–1M → шард 1, 1M–2M → шард 2). Просто, но возможен дисбаланс.\n**По хэшу (hash)** — шард = hash(key) % N. Равномерное распределение; минус — добавление шарда ведёт к ребалансировке.\n**По справочнику (directory)** — отдельная таблица/сервис «ключ → шард». Гибко, но лишний запрос и единая точка.\n**По региону (geo)** — шард по стране/дата-центру. Удобно для локалитета и регуляторики; возможен дисбаланс по регионам.\n\n**Зачем:** одна машина не тянет ни объём данных, ни нагрузку. Разнесли по шардам — каждый сервер обрабатывает меньше данных и запросов.\n\n**Минусы:** запрос «посчитать по всем пользователям» или JOIN по данным с разных шардов — сложно: нужно ходить на несколько серверов и потом склеивать результат. Добавить новый шард и переразложить данные (ребалансировка) — тоже нетривиально. Транзакции и внешние ключи между разными шардами из коробки не работают. Обычно шардируют по полю, которое чаще всего в запросах (например, user_id), чтобы максимум запросов шло в один шард.' },
  { id: 38, question: 'Что такое партиционирование?', answer: '**Партиционирование** — когда одну таблицу **делят на части (партиции)** по правилу, но все части остаются **в одной и той же БД** на одном сервере. Для приложения это по-прежнему одна таблица — просто внутри СУБД данные лежат кусками: например, по месяцам (январь — одна партиция, февраль — другая), по списку регионов или по хэшу.\n\n**Зачем:** запрос «данные за март» — БД открывает только партицию марта, а не сканирует всю таблицу. Удалить старые данные — просто отбросить партицию (DROP), без тяжёлого DELETE по гигантской таблице.\n\n**Чем отличается от шардирования:** партиции — это **всё ещё один сервер, одна БД**; шарды — это **разные серверы**. Партиционирование есть в PostgreSQL (RANGE, LIST, HASH), MySQL, Oracle и др.' },
  { id: 39, question: 'Что такое репликация БД?', answer: '**Репликация** — когда **одни и те же данные** хранятся на **нескольких серверах (репликах)**. Изменения с одного сервера копируются на остальные, чтобы везде была актуальная копия.\n\n**Зачем:** **отказоустойчивость** — если один сервер упал, можно переключиться на реплику. **Масштабирование чтения** — запросы на чтение раздают по репликам, основная БД разгружается. **Геораспределение** — копия ближе к пользователям, меньше задержка.\n\n**Как устроено:** обычно один сервер — **primary (master)** — принимает запись; остальные — **реплики (replicas)** — получают изменения и обслуживают чтение. Репликация бывает **синхронная** (запись подтверждается только когда данные попали на реплику — надёжнее, но медленнее) и **асинхронная** (реплика догоняет позже — быстрее, но при падении primary можно потерять последние изменения).\n\n**Отличие от шардирования и партиционирования:** при репликации на всех узлах **одни и те же данные**; при шардировании и партиционировании данные **разделены** между узлами или партициями.' },
  { id: 26, question: 'Что такое REST?', answer: '**REST** (Representational State Transfer) — **архитектурный стиль** построения API поверх **HTTP**. Идея: всё — **ресурсы**, доступные по **URI**; клиент работает с ними через стандартные **HTTP-методы** и получает **представление** (JSON, XML и т.д.).\n\n**Принципы:**\n**Без состояния (stateless)** — сервер не хранит состояние клиента между запросами. Каждый запрос самодостаточен (все нужные данные в заголовках, URI, теле). Сессии и контекст — на стороне клиента или в токене.\n\n**Единообразный интерфейс** — один и тот же набор операций (GET, POST, PUT, PATCH, DELETE) для разных ресурсов. **GET** — получить ресурс (идемпотентный). **POST** — создать или действие (не идемпотентный). **PUT** — заменить целиком (идемпотентный). **PATCH** — частичное обновление. **DELETE** — удалить (идемпотентный).\n\n**Ресурсы по URI** — каждый объект имеет адрес, например `/users/1`, `/orders`. Иерархия и имя не обязаны совпадать с внутренней структурой БД — это контракт API. **URI и URL:** **URI** — общий идентификатор ресурса (имя или адрес). **URL** — подмножество URI: идентификатор, по которому можно **получить** ресурс (схема, хост, путь, например https://api.example.com/users/1). Каждый URL является URI; не каждый URI — URL (например, urn:isbn:0-393-04002-X — URI, но не URL).\n\n**Коды ответа** — сервер сообщает результат числом: **2xx** — успех (200 OK, 201 Created), **3xx** — перенаправление, **4xx** — ошибка клиента (400, 404, 401), **5xx** — ошибка сервера.' },
  { id: 27, question: 'Этапы работы HTTP', answer: '**1. DNS-запрос** — браузер или клиент по имени хоста (например, example.com) запрашивает у DNS **IP-адрес** сервера. Ответ кэшируется на разных уровнях (ОС, роутер, DNS-сервер).\n\n**2. Установка соединения** — по полученному IP открывается **TCP-**соединение с портом (обычно 80 для HTTP, 443 для HTTPS). **Трёхстороннее рукопожатие** (SYN, SYN-ACK, ACK) устанавливает надёжный канал.\n\n**3. TLS (если HTTPS)** — **handshake** между клиентом и сервером: согласование версии и шифров, проверка сертификата, обмен ключами. Дальше трафик шифруется.\n\n**4. HTTP-запрос** — клиент отправляет **строку запроса** (метод, URI, версия HTTP), **заголовки** (Host, User-Agent, Cookie, Content-Type и др.) и при необходимости **тело** (body) — например, JSON для POST.\n\n**5. Обработка на сервере** — веб-сервер принимает запрос, приложение (бэкенд) формирует ответ: читает БД, выполняет логику, собирает данные.\n\n**6. HTTP-ответ** — сервер возвращает **статус-код** (200, 404, 500 и т.д.), **заголовки** (Content-Type, Set-Cookie, Cache-Control и др.) и **тело ответа** (HTML, JSON, файл).\n\n**7. Закрытие или повторное использование** — соединение закрывается (HTTP/1.0) или остаётся открытым для следующих запросов (**keep-alive**, HTTP/1.1). Клиент разбирает ответ (рендер страницы, разбор JSON) и при необходимости делает новые запросы.' },
  { id: 28, question: 'Что такое сериализация и десериализация?', answer: '**Сериализация** — преобразование объектов в памяти в **формат для передачи или хранения** (строка, байты): JSON, XML, pickle и т.д.\n\n**Десериализация** — обратный процесс: из строки или байт снова получают объект в памяти.\n\n**Пример (JSON в Python):**\n  import json\n  data = {"name": "Alice", "age": 30}\n  json_str = json.dumps(data)   # сериализация: объект → строка\n  restored = json.loads(json_str)  # десериализация: строка → объект\n\n**Другие форматы:** **pickle** — сериализация любых Python-объектов в байты (использовать только для доверенных данных). **XML** — текстовый формат с тегами. В веб-API чаще всего **JSON**.' },
  { id: 29, question: 'Популярные веб-протоколы и их применение', answer: '**HTTP/1.1** — запрос–ответ по одному соединению, текст. **Применение:** обычные страницы, REST API.\n\n**HTTPS** — HTTP поверх **TLS**: шифрование и проверка сервера. **Применение:** любой трафик, где нужна конфиденциальность.\n\n**HTTP/2** — мультиплексирование потоков в одном TCP-соединении, сжатие заголовков. **Применение:** ускорение загрузки сайтов и API.\n\n**HTTP/3 (QUIC)** — поверх **UDP**, встроенное шифрование, быстрый handshake. **Применение:** низкая задержка, нестабильные сети, стриминг.\n\n**WebSocket** — постоянное **двустороннее** соединение (сначала HTTP-upgrade). **Применение:** чаты, уведомления в реальном времени, онлайн-игры.\n\n**gRPC** — RPC поверх HTTP/2, бинарный формат (часто **Protobuf**). **Применение:** микросервисы, стриминг, внутренние API.\n\n**BitTorrent** — **P2P**-протокол обмена файлами: участники (пиры) обмениваются **чанками** по TCP. Найти пиров можно через **трекер** (центральный сервер «раздача → список пиров») или через **DHT** (Distributed Hash Table) — распределённая сеть узлов без центра: каждый узел хранит часть соответствий «раздача → пиры», запрос рассылается по узлам и возвращает список пиров. **Применение:** распределённая раздача больших файлов (образы ОС, обновления, медиа).\n\n**TCP (транспорт):** надёжная доставка и порядок пакетов; под капотом у HTTP/1, HTTP/2, WebSocket, gRPC.\n\n**UDP (транспорт):** без гарантий доставки, быстрее; используется в QUIC (HTTP/3), стриминге, DNS.' },
  { id: 30, question: 'Чем библиотека отличается от фреймворка?', answer: '**Библиотека** — вызывается из пользовательского кода (вы управляете потоком).\n\n**Фреймворк** — управляет потоком выполнения и **вызывает** ваш код (инверсия управления).' },
  { id: 31, question: 'Что такое SOLID?', answer: 'Набор принципов проектирования: **S**ingle responsibility, **O**pen/Closed, **L**iskov substitution, **I**nterface segregation, **D**ependency inversion — повышают гибкость и поддерживаемость кода.' },
  { id: 32, question: 'GOF23: Порождающие паттерны (Creational)', answer: '**Порождающие паттерны** отвечают за создание объектов и снижают зависимость кода от конкретных классов.\n\n**Singleton** — единственный экземпляр:\n  class Singleton:\n    _instance = None\n    def __new__(cls):\n      if cls._instance is None:\n        cls._instance = super().__new__(cls)\n      return cls._instance\n\n**Factory Method** — создание в подклассах:\n  class Creator:\n    def factory_method(self): raise NotImplementedError\n    def use(self): return self.factory_method().do()\n  class ConcreteCreator(Creator):\n    def factory_method(self): return ConcreteProduct()\n\n**Abstract Factory** — семейство продуктов:\n  class GUIFactory:\n    def create_button(self): raise NotImplementedError\n    def create_checkbox(self): raise NotImplementedError\n  class WinFactory(GUIFactory): ...  # WinButton, WinCheckbox\n\n**Builder** — пошаговая сборка:\n  class Builder:\n    def set_a(self, x): self.a = x; return self\n    def set_b(self, x): self.b = x; return self\n    def build(self): return Product(self.a, self.b)\n  p = Builder().set_a(1).set_b(2).build()\n\n**Prototype** — клонирование:\n  import copy\n  class Prototype:\n    def clone(self): return copy.deepcopy(self)' },
  { id: 33, question: 'GOF23: Структурные паттерны (Structural)', answer: '**Структурные паттерны** показывают, как собирать объекты и классы в более крупные структуры.\n\n**Adapter** — подгонка интерфейса:\n  class OldAPI: def specific_request(self): return "data"\n  class Adapter:\n    def __init__(self): self.old = OldAPI()\n    def request(self): return self.old.specific_request()\n\n**Decorator** — обёртка с новой логикой:\n  def decorator(func):\n    def wrap(*a, **k): print("before"); r = func(*a,**k); print("after"); return r\n    return wrap\n  @decorator\ndef foo(): pass\n\n**Facade** — один простой вход:\n  class SubsystemA: def run(self): ...\n  class Facade:\n    def __init__(self): self.a, self.b = SubsystemA(), SubsystemB()\n    def do_all(self): self.a.run(); self.b.run()\n\n**Proxy** — заместитель с контролем доступа:\n  class Proxy:\n    def __init__(self): self._real = None\n    def request(self):\n      if self._real is None: self._real = RealSubject()\n      return self._real.request()\n\n**Composite** — дерево с единым интерфейсом:\n  class Component: def operation(self): raise NotImplementedError\n  class Leaf(Component): def operation(self): return "Leaf"\n  class Composite(Component):\n    def __init__(self): self.children = []\n    def add(self, c): self.children.append(c)\n    def operation(self): return [c.operation() for c in self.children]\n\n**Bridge** — абстракция + реализация:\n  class Implementor: def op(self): raise NotImplementedError\n  class Abstraction: def __init__(self, impl): self.impl = impl\n  def run(self): return self.impl.op()\n\n**Flyweight** — общее состояние:\n  class Flyweight:\n    _pool = {}\n    def __new__(cls, key): return cls._pool.setdefault(key, super().__new__(cls))' },
  { id: 34, question: 'GOF23: Поведенческие паттерны (Behavioral)', answer: '**Поведенческие паттерны** решают задачи взаимодействия объектов и распределения ответственности.\n\n**Command** — запрос как объект:\n  class Command:\n    def __init__(self, receiver): self.receiver = receiver\n    def execute(self): self.receiver.action()\n  class Invoker: def set_command(self, c): self.cmd = c\n  def run(self): self.cmd.execute()\n\n**Chain of Responsibility** — цепочка обработчиков:\n  class Handler:\n    def __init__(self): self.next = None\n    def handle(self, req):\n      if self.can_handle(req): return self.process(req)\n      return self.next.handle(req) if self.next else None\n\n**Observer** — подписчики уведомляются:\n  class Subject:\n    def __init__(self): self._observers = []\n    def attach(self, o): self._observers.append(o)\n    def notify(self): [o.update(self) for o in self._observers]\n  class Observer: def update(self, subj): print("notified")\n\n**Strategy** — взаимозаменяемый алгоритм:\n  class Strategy: def algo(self, data): raise NotImplementedError\n  class Context:\n    def __init__(self, strategy): self.strategy = strategy\n    def do(self, data): return self.strategy.algo(data)\n  ctx = Context(ConcreteStrategyA()); ctx.do(data)\n\n**Unit of Work** — накопление и коммит:\n  class UnitOfWork:\n    def __init__(self): self.new, self.dirty, self.deleted = [], [], []\n    def register_new(self, e): self.new.append(e)\n    def commit(self): [repo.insert(e) for e in self.new]; ...\n\n**State** — поведение от состояния:\n  class State: def handle(self, ctx): raise NotImplementedError\n  class Context: def __init__(self): self.state = StateA()\n  def request(self): self.state.handle(self)  # state может сменить self.state\n\n**Template Method** — скелет в базовом классе:\n  class Abstract:\n    def template(self): self.step1(); self.step2()  # step2 — переопределяют\n    def step1(self): ...\n    def step2(self): raise NotImplementedError' }
];

/** Блоки: id, title, questionIds */
const BLOCKS = [
  { id: 'basic', title: 'Python Core', questionIds: [1, 2, 3, 4, 5, 6, 7, 8, 17, 18, 19, 20] },
  { id: 'oop', title: 'OOP', questionIds: [9, 10, 11, 12, 13, 14, 15, 16, 35, 36] },
  { id: 'algorithms', title: 'Algorithms', questionIds: [] },
  { id: 'db', title: 'DB', questionIds: [21, 22, 23, 24, 25, 37, 38, 39] },
  { id: 'web', title: 'Web / Network / REST', questionIds: [26, 27, 28, 29] },
  { id: 'architecture', title: 'Architecture / Patterns', questionIds: [30, 31, 32, 33, 34] }
];

(function () {
  const blocksEl = document.getElementById('blocks');
  const modalEl = document.getElementById('modal');
  const modalQuestion = modalEl.querySelector('.modal-question');
  const modalAnswer = modalEl.querySelector('.modal-answer');
  const modalClose = modalEl.querySelector('.modal-close');
  const modalBackdrop = modalEl.querySelector('.modal-backdrop');
  const modalContent = modalEl.querySelector('.modal-content');

  const questionsById = {};
  QUESTIONS.forEach(function (item) { questionsById[item.id] = item; });

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  /** В тексте **фраза** → жирное выделение (ключевые куски). */
  function formatKeyPhrases(rawLine) {
    const parts = rawLine.split(/\*\*(.+?)\*\*/g);
    let html = '';
    for (var i = 0; i < parts.length; i++) {
      var seg = escapeHtml(parts[i]);
      if (i % 2 === 1) html += '<strong class="answer-key">' + seg + '</strong>';
      else html += seg;
    }
    return html;
  }

  /** Строки с 2+ пробелов/таб — код; остальные — параграфы. Строки, оканчивающиеся на ":" — подзаголовки. **фраза** — ключевое. */
  function formatAnswer(text) {
    if (!text || typeof text !== 'string') return '';
    const lines = text.split('\n');
    var out = '';
    var inCode = false;
    for (var i = 0; i < lines.length; i++) {
      var line = lines[i];
      var isCodeLine = /^\s{2,}/.test(line) || /^\t/.test(line);
      if (isCodeLine) {
        if (!inCode) { out += '<pre class="answer-code"><code>'; inCode = true; }
        out += escapeHtml(line) + '\n';
      } else {
        if (inCode) { out += '</code></pre>'; inCode = false; }
        if (line.length) {
          var isHeading = line.slice(-1) === ':' && line.length < 160;
          var lineHtml = formatKeyPhrases(line);
          out += isHeading ? '<p class="answer-heading">' + lineHtml + '</p>' : '<p>' + lineHtml + '</p>';
        } else {
          out += '<p class="answer-space">&nbsp;</p>';
        }
      }
    }
    if (inCode) out += '</code></pre>';
    return out;
  }

  function openModal(item) {
    modalQuestion.textContent = item.question;
    modalAnswer.innerHTML = formatAnswer(item.answer);
    modalEl.classList.add('modal-open');
    document.body.style.overflow = 'hidden';
  }

  function closeModal() {
    modalEl.classList.remove('modal-open');
    document.body.style.overflow = '';
  }

  BLOCKS.forEach(function (block) {
    const section = document.createElement('section');
    section.className = 'block';
    section.id = block.id;
    const h2 = document.createElement('h2');
    h2.className = 'block-title';
    h2.textContent = block.title;
    section.appendChild(h2);
    const cardsWrap = document.createElement('div');
    cardsWrap.className = 'cards';
    block.questionIds.forEach(function (qId, index) {
      const item = questionsById[qId];
      if (!item) return;
      const card = document.createElement('div');
      card.className = 'card';
      const numInBlock = index + 1;
      card.innerHTML = '<span class="card-id">' + numInBlock + '</span><span class="card-question">' + escapeHtml(item.question) + '</span>';
      card.addEventListener('click', function () { openModal(item); });
      cardsWrap.appendChild(card);
    });
    section.appendChild(cardsWrap);
    blocksEl.appendChild(section);
  });

  modalClose.addEventListener('click', closeModal);
  modalBackdrop.addEventListener('click', closeModal);
  modalContent.addEventListener('click', function (e) { e.stopPropagation(); });
  modalEl.addEventListener('click', function (e) {
    if (e.target === modalEl) closeModal();
  });
  document.addEventListener('keydown', function (e) {
    if (e.key === 'Escape' && modalEl.classList.contains('modal-open')) closeModal();
  });
})();
