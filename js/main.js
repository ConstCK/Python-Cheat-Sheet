/** Вопросы и ответы: id, question, answer. id — строго по порядку 1, 2, 3, … N; при добавлении/удалении пересчитывать и обновлять questionIds в BLOCKS. */
const QUESTIONS = [
  { id: 1, question: 'Python', answer: '**Python** — высокоуровневый **интерпретируемый** язык с **динамической** и **строгой типизацией**.\n\n**Интерпретируемый:** код не компилируется в машинный язык заранее; в CPython он превращается в байт-код и выполняется виртуальной машиной «на лету», без отдельного шага сборки в исполняемый файл.\n\n**Типизация:** динамическая — тип переменной определяется в runtime (одна и та же переменная может ссылаться на объекты разных типов); строгая — неявных приведений типов почти нет (например, нельзя сложить строку и число без явного преобразования).\n\n**Под капотом (CPython), по шагам:**\n1. Исходный код (.py) парсится в AST (Абстрактное синтаксическое дерево).\n2. AST компилируется в байт-код (.pyc).\n3. Байт-код выполняется виртуальной машиной (PVM).\n4. Результат — переносимость между платформами без перекомпиляции.\n\n**Сборщик мусора:** основной механизм — **подсчёт ссылок (reference counting):** у каждого объекта хранится счётчик — сколько ссылок на него указывает; при создании ссылки счётчик увеличивается, при удалении ссылки — уменьшается; когда счётчик становится 0, объект сразу освобождается. Дополнительно модуль **gc** находит циклы ссылок (A → B → C → A), где счётчики не обнуляются, и помечает такие объекты для удаления.' },
  { id: 2, question: 'Типы данных в Python', answer: 'Типы делятся на **изменяемые** и **неизменяемые**.\n\n**Изменяемые:** list, dict, set — могут изменяться после создания.\n\n**Неизменяемые:** int, float, complex, bool, str, tuple, frozenset — при изменении создаётся новый объект.' },
  { id: 3, question: 'Структуры данных в Python', answer: '**Встроенные:** список (динамический массив), кортеж (неизменяемая последовательность), словарь (хэш-таблица), множество, строка, range.\n\n**Через библиотеки или свои реализации:** стек, очередь, деревья и графы.' },
  { id: 4, question: 'Lambda-функция', answer: '**Lambda** — анонимная функция, ограниченная одним выражением.\n\nЧаще всего используется как аргумент **функций высшего порядка** (map, filter, sorted) или там, где полноценное def избыточно.\n\nПример:\n  square = lambda x: x ** 2\n  evens = filter(lambda x: x % 2 == 0, [1, 2, 3, 4])\n  sorted(users, key=lambda u: u[\'name\'])' },
  { id: 5, question: 'Генератор', answer: '**Генератор** — объект, возвращающий значения по одному по запросу (**ленивые вычисления**). Реализует протокол итератора (__iter__, __next__), при исчерпании выбрасывает **StopIteration**.\n\n**Создание:** функция с **yield** или **generator comprehension** (x for x in ...). Экономят память — не хранят всю последовательность сразу.\n\n**Методы:**\n**next(g)** / **g.__next__()** — следующее значение.\n**g.send(value)** — отправить значение в генератор (оно подставляется в выражение yield). Перед первым **send(value)** нужно «прогнать» генератор до первого yield — вызвать **send(None)** или **next(g)**; иначе некуда подставлять value.\n**g.throw(exc)** — выбросить исключение внутри генератора.\n**g.close()** — завершить генератор.\n\n**return** в теле генератора: завершает генератор; в Python 3.3+ значение после return попадает в атрибут **StopIteration.value** (при переборе через for не видно, только при ручном next).\n\nПример с yield:\n  def count_to(n):\n    for i in range(n):\n      yield i\n  g = count_to(3)\n  next(g)  # 0\n  next(g)  # 1\n\nПример generator comprehension:\n  squares = (x ** 2 for x in range(5))\n  list(squares)  # [0, 1, 4, 9, 16]' },
  { id: 6, question: 'Итератор', answer: '**Итератор** — объект, поддерживающий **протокол итерации** (__iter__, __next__).\n\nХранит текущее состояние перебора и выбрасывает **StopIteration**, когда элементы заканчиваются.\n\nПример итератора на уровне класса:\n  class CountDown:\n    def __init__(self, start):\n      self.current = start\n    def __iter__(self):\n      return self\n    def __next__(self):\n      if self.current <= 0:\n        raise StopIteration\n      value = self.current\n      self.current -= 1\n      return value\n  for x in CountDown(3):\n    print(x)  # 3, 2, 1' },
  { id: 7, question: 'List/dict comprehension', answer: '**Comprehension** — синтаксический сахар для компактного создания коллекций (list, dict, set). Повышает читаемость и часто быстрее эквивалентных циклов for.\n\n**List comprehension:**\n  [x ** 2 for x in range(5)]           # [0, 1, 4, 9, 16]\n  [x for x in nums if x % 2 == 0]     # только чётные\n  [x if x > 0 else 0 for x in nums]  # тернарный (else обязателен)\n\n**С несколькими for и if:**\n  [(i, j) for i in range(2) for j in range(2) if i != j]  # [(0,1), (1,0)]\n  [x for row in matrix for x in row]  # «развернуть» матрицу в список\n\n**Dict comprehension:**\n  {k: v * 2 for k, v in d.items()}\n  {x: x ** 2 for x in range(5) if x % 2 == 0}  # {0: 0, 2: 4, 4: 16}\n\n**Set comprehension:**\n  {abs(x) for x in [-1, 1, -2, 2]}  # {1, 2}' },
  { id: 8, question: 'Аргументы *args и **kwargs', answer: 'Используются для передачи **переменного количества аргументов**.\n\n***args** — собирает позиционные аргументы в **кортеж**.\n\n****kwargs** — именованные аргументы в **словарь**. Часто применяются в декораторах и обёртках.\n\nПримеры в функции:\n  def f(*args):\n    print(args)  # кортеж\n  f(1, 2, 3)   # (1, 2, 3)\n\n  def g(**kwargs):\n    print(kwargs)  # словарь\n  g(a=1, b=2)     # {\'a\': 1, \'b\': 2}\n\n  def h(*args, **kwargs):\n    print(args, kwargs)\n  h(1, 2, x=3)   # (1, 2) {\'x\': 3}' },
  { id: 9, question: 'Основные принципы ООП', answer: '**Абстракция** — выделение существенных свойств объекта и сокрытие деталей. Модель описывает «что» объект делает, а не «как». В коде: абстрактные классы, интерфейсы, минимальный публичный контракт.\n\n**Инкапсуляция** — скрытие внутреннего состояния и реализации; доступ только через методы (или свойства). Защита от некорректного изменения данных, возможность менять реализацию без слома клиентов. В Python: соглашение об именовании (_protected, __private), property, дескрипторы.\n\n**Наследование** — подкласс получает поля и методы базового класса, может переопределять и дополнять. Повторное использование кода и выражение иерархии «является» (is-a).\n\n**Полиморфизм** — один интерфейс (имя метода, сигнатура), разное поведение у разных типов. Вызывающий код работает с абстракцией, не зная конкретный класс. В Python — утиная типизация: важна поддержка нужных методов, а не явное наследование.\n\n**Типы атрибутов (по именованию):** **public** — без подчёркивания, открытый интерфейс. **Protected** — одно подчёркивание **_name**: соглашение «внутренний, не для внешнего кода»; доступ не запрещён, но не рекомендуется. **Private** — два подчёркивания **__name**: имя манглится в **_Class__name**, чтобы уменьшить коллизии при наследовании; извне класса обращаться неудобно (но технически возможно). Один trailing underscore (**name_**) — чтобы не конфликтовать с ключевыми словами. В Python нет жёсткой блокировки доступа, только соглашения и name mangling.' },
  { id: 10, question: 'Разница между __new__(), __init__(), __call__()', answer: '**__new__** — создаёт объект в памяти (возвращает экземпляр).\n\n**__init__** — инициализирует уже созданный объект (self уже есть).\n\n**__call__** — позволяет вызывать экземпляр класса как функцию.\n\nПример (import не нужен — всё встроено):\n  class A:\n    def __new__(cls, x):\n      obj = super().__new__(cls)\n      return obj\n    def __init__(self, x):\n      self.x = x\n    def __call__(self, y):\n      return self.x + y\n  a = A(10)   # 1) __new__(A, 10) создаёт объект, 2) __init__(a, 10) задаёт a.x = 10\n  a(5)       # 15 — вызывается __call__(a, 5), возвращает a.x + 5' },
  { id: 11, question: 'Декоратор', answer: '**Декоратор** — функция высшего порядка: принимает функцию (или класс) и возвращает новую, оборачивая исходную и расширяя её поведение. Не меняет код самой функции.\n\nСинтаксис **@decorator** над определением функции эквивалентен присваиванию: `func = decorator(func)`.\n\nЧасто используется для **логирования**, **авторизации**, **кэширования**, замеров времени, повторных попыток.\n\nПример (логирование вызова):\n  def log(f):\n    def wrap(*args, **kwargs):\n      print(\'call\', f.__name__)\n      return f(*args, **kwargs)\n    return wrap\n  @log\n  def add(a, b):\n    return a + b\n  add(1, 2)   # print \"call add\", затем 3\n\nПример (декоратор с аргументами — фабрика декораторов):\n  def repeat(n):\n    def dec(f):\n      def wrap(*a, **k):\n        for _ in range(n): f(*a, **k)\n      return wrap\n    return dec\n  @repeat(2)\n  def say(): print(\'hi\')\n  say()   # hi hi' },
  { id: 12, question: 'Дескрипторы', answer: '**Дескрипторы** — классы, управляющие доступом к атрибутам других классов. Реализуют **__get__**, **__set__** (опционально), **__delete__** (опционально). Используются в **property**, ORM и системах валидации.\n\nПример:\n  class NonNegative:\n    def __init__(self, name):\n      self.name = name\n    def __get__(self, obj, type=None):\n      return obj.__dict__.get(self.name, 0)\n    def __set__(self, obj, value):\n      if value < 0:\n        raise ValueError(\'must be >= 0\')\n      obj.__dict__[self.name] = value\n  class Product:\n    price = NonNegative(\'price\')\n  p = Product()\n  p.price = 10   # ok\n  p.price = -1   # ValueError' },
  { id: 13, question: '@staticmethod / @classmethod / @property', answer: '**@staticmethod** — метод без доступа к self и cls; вызывается как **Class.method()** или **obj.method()**. Удобен для утилит, логически привязанных к классу (валидация, форматирование).\n\n**@classmethod** — первым аргументом получает **cls** (сам класс). Может создавать экземпляры, альтернативные конструкторы; доступ к атрибутам класса и наследованию.\n\n**@property** — когда обращаешься к атрибуту как к полю (**obj.x**), вызывается метод (чтение). Можно возвращать вычисленное значение. Если добавить **@x.setter** — тот же метод вызывается при присваивании (**obj.x = value**). Без setter атрибут только для чтения.\n\nПример:\n  class C:\n    x = 0\n    @staticmethod\n    def check(v): return v > 0\n    @classmethod\n    def from_pair(cls, a, b): return cls(a + b)\n    def __init__(self, val): self.val = val\n    @property\n    def double(self): return self.val * 2\n  C.check(1)       # True\n  c = C.from_pair(1, 2)  # c.val == 3\n  c.double         # 6 (без скобок)' },
  { id: 14, question: 'Атрибут __slots__', answer: '**__slots__** — кортеж или список имён разрешённых атрибутов экземпляра. Ограничивает динамическое добавление атрибутов (только перечисленные в __slots__) и убирает **__dict__** у экземпляров, что снижает потребление памяти. Важно при большом количестве объектов.\n\n**Наследники:** если подкласс **не задаёт** свой __slots__, у его экземпляров появляется **__dict__** (можно добавлять атрибуты). Если подкласс задаёт **__slots__**, он обычно перечисляет и свои новые имена; слоты родителя наследуются, у экземпляров подкласса снова нет __dict__ (только слоты родителя + свои). Пустой **__slots__ = ()** в подклассе сохраняет слоты родителя без добавления своих и без __dict__.' },
  { id: 15, question: 'MRO', answer: '**MRO** (Method Resolution Order) — порядок, в котором Python ищет метод (или атрибут) при **множественном наследовании**: обход базовых классов слева направо по списку наследования, без повторного посещения одного класса.\n\nЗачем нужен: при «ромбе» (A → B, C → D(B, C)) однозначно решить, какой метод вызвать. Алгоритм **C3** строит линейный порядок так, что: порядок в объявлении класса сохраняется; если класс X наследует от Y, то в MRO X идёт перед Y. Гарантирует предсказуемый и устойчивый к изменениям порядок.\n\nПример:\n  class A: pass\n  class B(A): pass\n  class C(A): pass\n  class D(B, C): pass\n  print(D.__mro__)\n  # (D, B, C, A, object)\n  # поиск метода: сначала D, потом B, потом C, потом A, потом object' },
  { id: 16, question: 'Метаклассы', answer: '**Метакласс** — класс класса: объект класса является экземпляром своего метакласса. По умолчанию метакласс — **type**. При определении класса вызываются **__new__** и **__init__** метакласса (а не обычного класса). Чтобы изменить пространство имён класса (dct) до создания класса — важно переопределить **__new__**; **__init__** получает уже созданный класс и подходит для постобработки.\n\nИспользуются для **валидации** (проверка атрибутов/наследования при создании класса), **регистрации** классов (реестры, плагины), построения фреймворков (ORM, API), автоматического добавления методов или атрибутов.\n\nПример (метакласс добавляет атрибут):\n  class Meta(type):\n    def __new__(mcs, name, bases, dct):\n      dct[\'created_by\'] = \'Meta\'\n      return super().__new__(mcs, name, bases, dct)\n  class A(metaclass=Meta): pass\n  print(A.created_by)   # Meta' },
  { id: 35, question: 'Основные магические методы класса', answer: '**Дандеры** (double underscore) — специальные методы, которые вызываются операторами и встроенными функциями.\n\n**Создание и инициализация:**\n**__new__(cls, ...)** — создаёт объект в памяти; **__init__(self, ...)** — инициализирует уже созданный экземпляр.\n\n**Строковое представление:**\n**__str__(self)** — вызывается **str(obj)** и **print(obj)**; для пользователя. **__repr__(self)** — **repr(obj)** и отображение в интерпретаторе; желательно однозначное представление для отладки.\n\n**Сравнение и хэш:**\n**__eq__(self, other)** — **==**. **__ne__(self, other)** — **!=** (по умолчанию возвращает не __eq__).\n\n**__lt__(self, other)** — **<**, **__le__(self, other)** — **<=**, **__gt__(self, other)** — **>**, **__ge__(self, other)** — **>=**; используются **sorted()**, **min()**, **max()** и сравнения.\n\nДостаточно реализовать **__lt__** и **__eq__**, остальное можно получить через **functools.total_ordering**.\n\n**__hash__(self)** — **hash(obj)**; нужен для **set** и ключа **dict**; при переопределении __eq__ у неизменяемых типов обычно переопределяют и __hash__.\n\n**Коллекции и доступ:**\n**__len__(self)** — вызывается **len(obj)**; должен возвращать неотрицательное целое (размер коллекции).\n\n**__getitem__(self, key)** — **obj[key]**; чтение по ключу/индексу; для **in** и итерации по индексу используется, если нет __iter__.\n\n**__setitem__(self, key, value)** — **obj[key] = value**; запись по ключу/индексу (для изменяемых коллекций).\n\n**__iter__(self)** — вызывается **iter(obj)** и в **for**; должен возвращать итератор (объект с **__next__**). **__next__(self)** — следующий элемент; вызывается **next(iterator)**; в конце выбрасывает **StopIteration**.\n\n**Доступ к атрибутам:**\n**__getattr__(self, name)** — вызывается, когда атрибут **не найден** в обычном поиске (self.name, getattr); удобен для «ленивых» атрибутов и прокси.\n\n**__getattribute__(self, name)** — вызывается **при каждом** обращении к атрибуту (до поиска в __dict__); легко зациклить (обращение к self внутри), обычно используют **object.__getattribute__(self, name)**.\n\n**__setattr__(self, name, value)** — вызывается при **присваивании** атрибута **obj.name = value**; внутри избегать прямого self.name = ... (вызовет рекурсию), использовать **object.__setattr__(self, name, value)** или **self.__dict__[name] = value**.\n\n**Вызов и контекст:**\n**__call__(self, ...)** — вызов экземпляра как функции **obj(...)**. **__enter__(self)**, **__exit__(self, ...)** — контекстный менеджер **with obj:**.' },
  { id: 36, question: 'Геттеры, сеттеры и делитеры', answer: '**Геттер** — метод для чтения атрибута; **сеттер** — для записи; **делитер** — для удаления (del obj.attr). В Python их реализуют через **@property** и опционально **@имя.setter**, **@имя.deleter** — обращение к атрибуту выглядит как к полю (obj.x), но вызываются методы.\n\n**@property** — метод вызывается при **чтении** obj.x; можно вычислять значение, кэшировать, проверять доступ.\n\n**@x.setter** — вызывается при **присваивании** obj.x = value; удобно для валидации или побочных эффектов.\n\n**@x.deleter** — вызывается при **del obj.x**; освобождение ресурсов или сброс состояния.\n\nПример:\n  class C:\n    def __init__(self):\n      self._x = 0\n    @property\n    def x(self):\n      return self._x\n    @x.setter\n    def x(self, v):\n      if v < 0: raise ValueError(\'x >= 0\')\n      self._x = v\n    @x.deleter\n    def x(self):\n      self._x = 0\n  c = C()\n  c.x = 10\n  print(c.x)   # 10\n  del c.x\n  print(c.x)   # 0' },
  { id: 17, question: 'GIL', answer: '**GIL** (Global Interpreter Lock) — блокировка, ограничивающая одновременное выполнение байт-кода **одним потоком** в CPython.\n\n**Для чего:** избежание **race conditions** (гонок). Race condition — когда два потока одновременно читают или меняют одни и те же данные и результат зависит от порядка выполнения (данные могут испортиться). В CPython используется **подсчёт ссылок** — без GIL два потока могли бы менять счётчик одного объекта одновременно. GIL гарантирует, что байт-код выполняется только одним потоком в момент времени, защищая внутренние структуры и C-расширения.\n\nМинус: снижает эффективность **CPU-bound** задач в потоках; для параллелизма по CPU — процессы (multiprocessing) или альтернативы (PyPy, Jython).' },
  { id: 18, question: 'Поверхностная и глубокая копия', answer: '**Shallow copy** — копирует только верхний уровень (вложенные объекты — по ссылке). **Deep copy** — рекурсивно копирует все вложенные объекты.\n\nПримеры:\n  import copy\n  a = [1, [2, 3]]\n  s = copy.copy(a)      # или a.copy(), a[:]\n  d = copy.deepcopy(a)\n  s[1][0] = 99\n  print(a[1][0])       # 99 — вложенный список общий у a и s\n  d[1][0] = 100\n  print(a[1][0])       # 99 — у d свой вложенный список' },
  { id: 48, question: 'Контекстный менеджер', answer: '**Контекстный менеджер** — объект, который гарантирует **«вход»** и **«выход»** из блока кода: выделение и освобождение ресурса (файл, соединение, замок). Синтаксис **with** вызывает при входе **__enter__**, при выходе (нормальном или по исключению) — **__exit__**. Даже если внутри блока произошло исключение, **__exit__** всё равно вызывается — ресурс не «зависнет».\n\n**Использование:**\n  with open(\'file.txt\') as f:\n    data = f.read()\n  # файл закрыт после блока\n\n  with lock:\n    # только один поток здесь\n    do_work()\n  # lock отпущен\n\n**Вложенный with (несколько ресурсов):**\n  with open(\'a.txt\') as a, open(\'b.txt\') as b:\n    # оба файла открыты\n  # оба закрыты\n\n**Варианты создания:**\n\n**1. Класс с __enter__ и __exit__:**\n**__enter__(self)** — вызывается при входе в **with**; возвращаемое значение попадает в **as x**. **__exit__(self, exc_type, exc_val, exc_tb)** — вызывается при выходе из блока (нормальном или по исключению). Аргументы заполняются только если внутри **with** произошло исключение; иначе все три — **None**.\n\n**exc_type** — класс исключения (тип; то, что в **except E as e** — это E). **exc_val** — экземпляр исключения (аргумент из **raise ValueError(\'msg\')** — само исключение с сообщением). **exc_tb** — объект **traceback** (стек вызовов; полезен для логирования или повторного raise). По ним можно понять, было ли исключение и какое, и решить — логировать, подавить или пробросить дальше. Если **__exit__** возвращает **True**, исключение считается обработанным и не пробрасывается; **False** или отсутствие **return** — исключение пробрасывается дальше.\n  class Timer:\n    def __enter__(self):\n      self.start = time.perf_counter()\n      return self\n    def __exit__(self, et, ev, tb):\n      self.elapsed = time.perf_counter() - self.start\n      return False\n  with Timer() as t:\n    do_work()\n  print(t.elapsed)\n\n**2. contextlib.contextmanager (генератор):** декоратор **@contextmanager** превращает генератор в контекстный менеджер. Всё до **yield** — код «входа» (аналог __enter__); всё после **yield** — код «выхода» (аналог __exit__). Значение после **yield** попадает в **as x**.\n  from contextlib import contextmanager\n  @contextmanager\n  def managed_resource():\n    resource = acquire()   # вход\n    try:\n      yield resource\n    finally:\n      release(resource)   # выход всегда\n  with managed_resource() as r:\n    use(r)\n\n**3. contextlib.ContextDecorator:** базовый класс для контекстного менеджера, который можно использовать и как **with**, и как **декоратор** функции (весь вызов функции оборачивается в with).\n  from contextlib import ContextDecorator\n  class mycontext(ContextDecorator):\n    def __enter__(self): ...\n    def __exit__(self, *a): ...\n  @mycontext()\n  def foo(): ...\n  foo()   # как будто with mycontext(): foo()\n\n**Кратко:** контекстный менеджер — **with**; гарантия вызова **__exit__** при любом исходе; создание — класс (**__enter__**/__exit__) или **@contextmanager** (генератор с yield).' },
  { id: 49, question: 'Пространства имён в Python', answer: '**Пространство имён (namespace)** — отображение **имён на объекты**: словарь «имя переменной → ссылка на объект». В Python нет «голых» переменных — имя всегда связано с объектом в каком-то пространстве имён.\n\n**Где бывают пространства имён:** у модуля (глобальные имена модуля), у функции (локальные имена при вызове), у класса (атрибуты класса), у экземпляра (атрибуты экземпляра). Встроенные имена (**len**, **print**, **dict**) живут в пространстве **builtins**.\n\n**Порядок поиска имени (LEGB):** при обращении к имени Python ищет его в таком порядке:\n**L** — **Local** (локальное: внутри текущей функции).\n**E** — **Enclosing** (охватывающее: в объёмлющих функциях, замыкания).\n**G** — **Global** (глобальное: модуль, верхний уровень).\n**B** — **Built-in** (встроенное: len, open, Exception и т.д.).\n\nПоиск останавливается на первом совпадении. Присваивание (**x = ...**) создаёт или меняет имя в **локальном** пространстве (если нет **global**/ **nonlocal**).\n\n**global** — объявляет, что имя в функции относится к **глобальному** пространству модуля. Без **global** присваивание создало бы локальную переменную; с **global** мы меняем глобальную.\n  x = 1\n  def f():\n    global x\n    x = 2\n  f(); print(x)   # 2\n\n**nonlocal** — объявляет, что имя берётся из **ближайшего объёмлющего** пространства (не глобального). Нужен, когда во вложенной функции хотим изменить переменную внешней функции, а не создать новую локальную.\n  def outer():\n    n = 0\n    def inner():\n      nonlocal n\n      n += 1\n      return n\n    return inner\n  inc = outer(); inc(); inc()   # 1, 2\n\n**Жизненный цикл:** локальное пространство функции создаётся при **вызове** и исчезает при выходе из функции. Глобальное пространство модуля живёт пока загружен модуль. Класс и экземпляр — пока существуют объекты.\n\n**Кратко:** пространство имён — «имя → объект»; поиск по LEGB; **global** — писать в модуль, **nonlocal** — в объёмлющую функцию.' },
  { id: 19, question: 'O-нотация и сложность операций (list, dict, set)', answer: '**O-нотация** описывает **асимптотическую сложность** алгоритма по времени или памяти при росте n (размера данных). Позволяет сравнивать решения независимо от железа.\n\n**Часто встречающиеся классы сложности:**\n**Постоянное время:** O(1) — число операций не зависит от n.\n**Линейное время:** O(n) — пропорционально размеру данных.\n**Логарифмическое время:** O(log n) — при каждом шаге объём уменьшается (например, бинарный поиск).\n**Линейно-логарифмическое время:** O(n log n) — типично для эффективной сортировки.\n**Квадратичное время:** O(n²) — вложенные проходы по данным.\n\n**list:**\nдоступ по индексу — O(1); добавление в конец append — O(1); вставка/удаление по индексу — O(n); поиск in / index (при указании значения) — O(n); сортировка — O(n log n); срез [i:j] — O(j−i).\n\n**tuple / str:**\nдоступ по индексу — O(1); поиск in — O(n); неизменяемы (создание копии при «изменении» — O(n)).\n\n**dict:**\nвставка, доступ по ключу, удаление — в среднем O(1); в худшем (плохой хэш, коллизии) — O(n); итерация — O(n).\n\n**set:**\nadd, in, remove — в среднем O(1); в худшем O(n); операции над множествами (объединение, пересечение) — до O(n+m).\n\n**deque** (collections):\nappend/popleft с обоих концов — O(1); доступ по индексу в середине — O(n).' },
  { id: 20, question: 'Рекурсия', answer: '**Рекурсия** — подход, при котором функция вызывает саму себя для решения подзадачи того же типа.\n\n**Базовый случай** — условие, при котором функция возвращает результат без вызова себя (останавливает цепочку). Без него — бесконечные вызовы и **RecursionError** (в Python лимит стека вызовов).\n\n**Рекурсивный случай** — вызов себя с упрощёнными аргументами (шаг к базовому случаю).\n\nКаждый вызов кладётся в **стек вызовов**; при большой глубине возможен переполнение стека.\n\nУдобна для обхода деревьев/графов, разбиения задачи (divide and conquer), рекурсивных структур данных.\n\nПример (факториал):\n  def fact(n):\n    if n <= 1:\n      return 1\n    return n * fact(n - 1)\n  fact(4)   # 24' },
  { id: 21, question: 'ORM', answer: '**ORM** (Object Relational Mapping) связывает **объектную модель** приложения с **реляционной моделью** БД.\n\nСкрывает SQL-логику за Python-объектами: модели (таблицы), запросы, связи (FK, many-to-many).\n\n**Популярные ORM в Python:**\n**Django ORM** (в составе Django), **SQLAlchemy** (универсальная, часто с Flask/FastAPI), **Peewee** (лёгкая), **Tortoise ORM** (async), **Pony ORM**, **SQLObject**.' },
  { id: 22, question: 'Миграции', answer: '**Миграции** — механизм **версионирования схемы БД**, позволяющий безопасно изменять структуру таблиц (создание, изменение, удаление). Файлы миграций хранят историю изменений; применяются по порядку (вверх/откат).\n\n**Инструменты:** **Django** (встроенные миграции, `manage.py migrate`), **Alembic** (для SQLAlchemy), **Flask-Migrate** (Alembic под Flask), **Tortoise ORM** (aerich), **Peewee** (встроенный migrator).' },
  { id: 23, question: 'Транзакция', answer: '**Транзакция** — последовательность операций с БД, которая выполняется как **единое целое**: либо все операции применяются (**COMMIT**), либо все отменяются (**ROLLBACK**). Гарантирует **атомарность**: при ошибке или явном откате изменения не частично сохраняются.\n\nОбычный цикл: **BEGIN** (начало транзакции) → операции (INSERT, UPDATE, DELETE, SELECT) → **COMMIT** (подтвердить) или **ROLLBACK** (отменить). В многих драйверах и ORM транзакция начинается неявно при первом запросе; autocommit может быть включён по умолчанию (каждый запрос — отдельная транзакция).\n\nИспользуют, когда несколько операций должны быть выполнены вместе: перевод между счетами, создание заказа с позициями, обновление связанных таблиц. Без транзакции сбой посередине оставит БД в несогласованном состоянии.' },
  { id: 24, question: 'ACID', answer: '**ACID** — набор гарантий корректности транзакций в БД.\n\n**Атомарность (Atomicity):** транзакция выполняется целиком или не выполняется вовсе. Пример: перевод денег A→B — списание с A и зачисление на B либо оба шага, либо откат обоих; нельзя «списали с A, упало до зачисления на B».\n\n**Согласованность (Consistency):** после транзакции БД остаётся в допустимом состоянии: соблюдаются ограничения, ключи, инварианты и **связи между таблицами** (FK, CHECK). Пример: сумма на счетах до и после перевода не меняется.\n\n**Изолированность (Isolation):** параллельные транзакции не «видят» незакоммиченные изменения друг друга; результат как при некотором порядке выполнения.\n\n**Уровни изоляции** (от слабого к сильному):\n**READ UNCOMMITTED** — видны даже незакоммиченные данные (грязное чтение).\n\n**READ COMMITTED** — видны только закоммиченные; повторное чтение той же строки может дать другое значение (неповторяемое чтение).\n\n**REPEATABLE READ** — в рамках транзакции повторный запрос возвращает те же строки; возможны фантомы (новые строки, появившиеся в другой транзакции).\n\n**SERIALIZABLE** — строгая изоляция, как будто транзакции выполняются по одной; фантомов нет. Чем выше уровень, тем строже изоляция и обычно ниже параллелизм.\n\n**По умолчанию в популярных БД:** **PostgreSQL** — READ COMMITTED. **MySQL** (InnoDB) — REPEATABLE READ. **SQL Server**, **Oracle** — READ COMMITTED.\n\n**Надёжность (Durability):** закоммиченные данные сохраняются при сбое (журнал, WAL). Пример: после COMMIT данные не пропадут при отключении питания.' },
  { id: 25, question: 'Индексирование БД', answer: '**Индексирование** — создание дополнительных структур данных (**индексов**) для ускорения **поиска**, **фильтрации** и **сортировки** по столбцам. Индекс хранит значения столбца(ов) и ссылки на строки таблицы; **хранится в той же БД на диске** — в отдельных файлах/структурах, которыми управляет СУБД (таблица с данными не дублируется). Запросы по индексированным полям выполняются быстрее (часто без полного скана таблицы). Плата: замедление вставки/обновления/удаления и дополнительное место на диске.\n\n**Типы индексов:**\n\n**B-tree** — сбалансированное дерево; **по умолчанию** в PostgreSQL, MySQL, SQLite. Поддерживает **диапазоны** (<, <=, =, >=, >, BETWEEN) и **ORDER BY** по индексированным столбцам. Универсальный выбор для фильтрации и сортировки. Составной индекс (несколько столбцов) полезен, когда запросы фильтруют/сортируют по ним в одном порядке.\n\n**Hash** — индекс по **хэшу** значения. Подходит только для **точечного поиска** (WHERE col = value); не поддерживает диапазоны и сортировку. В PostgreSQL с версии 10; в MySQL — для движка MEMORY. Обычно B-tree не хуже, Hash имеет смысл при очень частом поиске по равенству.\n\n**GiST** (Generalized Search Tree) — обобщённое дерево поиска. Подходит для **геоданных** (точки, прямоугольники, «ближайшие N»), **полнотекстового поиска**, диапазонов типов. Гибкий, но для простого равенства по числу/строке чаще берут B-tree.\n\n**GIN** (Generalized Inverted Index) — **инвертированный** индекс: по «элементу» хранятся ссылки на строки. Подходит для **полнотекста**, **массивов** (WHERE arr содержит элемент), **JSONB** (содержит ключ/значение). Много записей на один ключ — типично для «содержит» / «входит в».\n\n**BRIN** (Block Range Index) — хранит **min/max** значений по **блокам** таблицы (а не по каждой строке). Занимает мало места; удобен для **очень больших** таблиц с **естественным порядком** по столбцу (время, монотонный id). Запрос по диапазону такого столбца отсекает целые блоки без их чтения. Не заменяет B-tree, если нужна точная выборка по разбросанным значениям.\n\n**Кратко по типам:** B-tree — основной универсальный; Hash — только =; GiST/GIN — полнотекст, гео, массивы, JSONB; BRIN — большие таблицы с упорядоченными данными.\n\n**Реализация в БД:** **PostgreSQL** — B-tree по умолчанию, hash, GiST, GIN, BRIN, частичные и составные индексы. **MySQL** — B-tree (InnoDB), hash для MEMORY. **SQLite** — B-tree. **MongoDB** — B-tree по умолчанию, hash, гео, полнотекст. Конкретный синтаксис (CREATE INDEX, опции) зависит от СУБД.' },
  { id: 37, question: 'Шардирование', answer: '**Шардирование** — когда одну большую таблицу **разносят по разным серверам (БД)**. Каждый сервер хранит свою часть строк — это и есть **шард**. По какой строке куда попадёт — решают по правилу: например, по **user_id** (все заказы пользователя на одном шарде), по региону или по хэшу от ключа.\n\n**Какое бывает (по способу выбора шарда):**\n**По диапазону (range)** — ключ попадает в диапазон (user_id 1–1M → шард 1, 1M–2M → шард 2). Просто, но возможен дисбаланс.\n**По хэшу (hash)** — шард = hash(key) % N. Равномерное распределение; минус — добавление шарда ведёт к ребалансировке.\n**По справочнику (directory)** — отдельная таблица/сервис «ключ → шард». Гибко, но лишний запрос и единая точка.\n**По региону (geo)** — шард по стране/дата-центру. Удобно для локалитета и регуляторики; возможен дисбаланс по регионам.\n\n**Зачем:** одна машина не тянет ни объём данных, ни нагрузку. Разнесли по шардам — каждый сервер обрабатывает меньше данных и запросов.\n\n**Минусы:** запрос «посчитать по всем пользователям» или JOIN по данным с разных шардов — сложно: нужно ходить на несколько серверов и потом склеивать результат. Добавить новый шард и переразложить данные (ребалансировка) — тоже нетривиально. Транзакции и внешние ключи между разными шардами из коробки не работают. Обычно шардируют по полю, которое чаще всего в запросах (например, user_id), чтобы максимум запросов шло в один шард.' },
  { id: 38, question: 'Партиционирование', answer: '**Партиционирование** — когда одну таблицу **делят на части (партиции)** по правилу, но все части остаются **в одной и той же БД** на одном сервере. Для приложения это по-прежнему одна таблица — просто внутри СУБД данные лежат кусками: например, по месяцам (январь — одна партиция, февраль — другая), по списку регионов или по хэшу.\n\n**Зачем:** запрос «данные за март» — БД открывает только партицию марта, а не сканирует всю таблицу. Удалить старые данные — просто отбросить партицию (DROP), без тяжёлого DELETE по гигантской таблице.\n\n**Чем отличается от шардирования:** партиции — это **всё ещё один сервер, одна БД**; шарды — это **разные серверы**. Партиционирование есть в PostgreSQL (RANGE, LIST, HASH), MySQL, Oracle и др.' },
  { id: 39, question: 'Репликация БД', answer: '**Репликация** — когда **одни и те же данные** хранятся на **нескольких серверах (репликах)**. Изменения с одного сервера копируются на остальные, чтобы везде была актуальная копия.\n\n**Зачем:** **отказоустойчивость** — если один сервер упал, можно переключиться на реплику. **Масштабирование чтения** — запросы на чтение раздают по репликам, основная БД разгружается. **Геораспределение** — копия ближе к пользователям, меньше задержка.\n\n**Как устроено:** обычно один сервер — **primary (master)** — принимает запись; остальные — **реплики (replicas)** — получают изменения и обслуживают чтение. Репликация бывает **синхронная** (запись подтверждается только когда данные попали на реплику — надёжнее, но медленнее) и **асинхронная** (реплика догоняет позже — быстрее, но при падении primary можно потерять последние изменения).\n\n**Отличие от шардирования и партиционирования:** при репликации на всех узлах **одни и те же данные**; при шардировании и партиционировании данные **разделены** между узлами или партициями.' },
  { id: 26, question: 'REST', answer: '**REST** (Representational State Transfer) — **архитектурный стиль** построения API поверх **HTTP**. Идея: всё — **ресурсы**, доступные по **URI**; клиент работает с ними через стандартные **HTTP-методы** и получает **представление** (JSON, XML и т.д.).\n\n**Принципы:**\n**Без состояния (stateless)** — сервер не хранит состояние клиента между запросами. Каждый запрос самодостаточен (все нужные данные в заголовках, URI, теле). Сессии и контекст — на стороне клиента или в токене.\n\n**Единообразный интерфейс** — один и тот же набор операций (GET, POST, PUT, PATCH, DELETE) для разных ресурсов. **GET** — получить ресурс (идемпотентный). **POST** — создать или действие (не идемпотентный). **PUT** — заменить целиком (идемпотентный). **PATCH** — частичное обновление. **DELETE** — удалить (идемпотентный).\n\n**Ресурсы по URI** — каждый объект имеет адрес, например `/users/1`, `/orders`. Иерархия и имя не обязаны совпадать с внутренней структурой БД — это контракт API. **URI и URL:** **URI** — общий идентификатор ресурса (имя или адрес). **URL** — подмножество URI: идентификатор, по которому можно **получить** ресурс (схема, хост, путь, например https://api.example.com/users/1). Каждый URL является URI; не каждый URI — URL (например, urn:isbn:0-393-04002-X — URI, но не URL).\n\n**Коды ответа** — сервер сообщает результат числом: **2xx** — успех (200 OK, 201 Created), **3xx** — перенаправление, **4xx** — ошибка клиента (400, 404, 401), **5xx** — ошибка сервера.' },
  { id: 27, question: 'Этапы работы HTTP', answer: '**1. DNS-запрос** — браузер или клиент по имени хоста (например, example.com) запрашивает у DNS **IP-адрес** сервера. Ответ кэшируется на разных уровнях (ОС, роутер, DNS-сервер).\n\n**2. Установка соединения** — по полученному IP открывается **TCP-**соединение с портом (обычно 80 для HTTP, 443 для HTTPS). **Трёхстороннее рукопожатие** (SYN, SYN-ACK, ACK) устанавливает надёжный канал.\n\n**3. TLS (если HTTPS)** — **handshake** между клиентом и сервером: согласование версии и шифров, проверка сертификата, обмен ключами. Дальше трафик шифруется.\n\n**4. HTTP-запрос** — клиент отправляет **строку запроса** (метод, URI, версия HTTP), **заголовки** (Host, User-Agent, Cookie, Content-Type и др.) и при необходимости **тело** (body) — например, JSON для POST.\n\n**5. Обработка на сервере** — веб-сервер принимает запрос, приложение (бэкенд) формирует ответ: читает БД, выполняет логику, собирает данные.\n\n**6. HTTP-ответ** — сервер возвращает **статус-код** (200, 404, 500 и т.д.), **заголовки** (Content-Type, Set-Cookie, Cache-Control и др.) и **тело ответа** (HTML, JSON, файл).\n\n**7. Закрытие или повторное использование** — соединение закрывается (HTTP/1.0) или остаётся открытым для следующих запросов (**keep-alive**, HTTP/1.1). Клиент разбирает ответ (рендер страницы, разбор JSON) и при необходимости делает новые запросы.' },
  { id: 28, question: 'Сериализация и десериализация', answer: '**Сериализация** — преобразование объектов в памяти в **формат для передачи или хранения** (строка, байты): JSON, XML, pickle и т.д.\n\n**Десериализация** — обратный процесс: из строки или байт снова получают объект в памяти.\n\n**Пример (JSON в Python):**\n  import json\n  data = {"name": "Alice", "age": 30}\n  json_str = json.dumps(data)   # сериализация: объект → строка\n  restored = json.loads(json_str)  # десериализация: строка → объект\n\n**Другие форматы:** **pickle** — сериализация любых Python-объектов в байты (использовать только для доверенных данных). **XML** — текстовый формат с тегами. В веб-API чаще всего **JSON**.' },
  { id: 29, question: 'Популярные веб-протоколы и их применение', answer: '**HTTP/1.1** — запрос–ответ по одному соединению, текст. **Применение:** обычные страницы, REST API.\n\n**HTTPS** — HTTP поверх **TLS**: шифрование и проверка сервера. **Применение:** любой трафик, где нужна конфиденциальность.\n\n**FTP** — протокол **передачи файлов**; отдельные каналы для управления (порт 21) и данных. **Применение:** загрузка и скачивание файлов на сервер (хостинг, бэкапы), публичные файловые архивы. Часто заменяют на **SFTP** (поверх SSH) или передачу по **HTTPS** из соображений безопасности (FTP передаёт пароль открытым текстом).\n\n**HTTP/2** — мультиплексирование потоков в одном TCP-соединении, сжатие заголовков. **Применение:** ускорение загрузки сайтов и API.\n\n**HTTP/3 (QUIC)** — поверх **UDP**, встроенное шифрование, быстрый handshake. **Применение:** низкая задержка, нестабильные сети, стриминг.\n\n**WebSocket** — постоянное **двустороннее** соединение (сначала HTTP-upgrade). **Применение:** чаты, уведомления в реальном времени, онлайн-игры.\n\n**gRPC** — RPC поверх HTTP/2, бинарный формат (часто **Protobuf**). **Применение:** микросервисы, стриминг, внутренние API.\n\n**BitTorrent** — **P2P**-протокол обмена файлами: участники (пиры) обмениваются **чанками** по TCP. Найти пиров можно через **трекер** (центральный сервер «раздача → список пиров») или через **DHT** (Distributed Hash Table) — распределённая сеть узлов без центра: каждый узел хранит часть соответствий «раздача → пиры», запрос рассылается по узлам и возвращает список пиров. **Применение:** распределённая раздача больших файлов (образы ОС, обновления, медиа).\n\n**TCP (транспорт):** надёжная доставка и порядок пакетов; под капотом у HTTP/1, HTTP/2, WebSocket, gRPC.\n\n**UDP (транспорт):** без гарантий доставки, быстрее; используется в QUIC (HTTP/3), стриминге, DNS.' },
  { id: 30, question: 'Библиотека VS фреймворк', answer: '**Библиотека** — набор функций или классов, которые **вы вызываете**, когда нужно. Поток выполнения определяет ваш код: вы решаете, когда вызвать библиотеку и что делать с результатом. Библиотека — **инструмент** в ваших руках.\n\n**Фреймворк** — задаёт **каркас приложения**: точки входа, жизненный цикл, структуру. Ваш код **подключается** в нужные места (обработчики, хуки, конфигурация), а **фреймворк вызывает** ваш код в нужный момент. Управление потоком у фреймворка — это **инверсия управления** (IoC): не вы вызываете фреймворк, а он вас («Don\'t call us, we\'ll call you»).\n\n**Аналогия:** библиотека — ящик с инструментами, вы берёте отвёртку, когда она нужна. Фреймворк — каркас дома: вы заполняете комнаты (пишете обработчики), но когда открывать дверь или включать свет — решает каркас (события, запросы).\n\n**Примеры:** **библиотеки** — requests, lodash, json, pytest (как набор утилит). **Фреймворки** — Django, Flask (для веба), React/Vue (каркас UI), Spring (для Java).' },
  { id: 31, question: 'SOLID', answer: '**SOLID** — пять принципов проектирования, которые повышают гибкость и поддерживаемость кода.\n\n**S — Single Responsibility (единственная ответственность):** класс должен иметь **одну причину для изменения**. Одна задача, одна зона ответственности. Если класс делает и отчёты, и рассылку, и сохранение в БД — при изменении одного из аспектов придётся трогать один и тот же класс; лучше разнести по разным классам.\n\n**O — Open/Closed (открыт для расширения, закрыт для модификации):** поведение расширяют **новым кодом** (наследование, композиция), а не правкой существующего. Добавляем новый тип — новый класс/модуль; старый код остаётся без изменений. Снижает риск поломать уже работающее.\n\n**L — Liskov Substitution (подстановка Лисков):** подкласс должен быть **заменяем** на базовый класс без нарушения контракта. Клиент, работающий с базовым типом, не должен «удивляться», если подставят наследника: пред- и постусловия, инварианты сохраняются. Нарушение: наследник бросает исключения, которые базовый не бросает, или сужает допустимое поведение.\n\n**I — Interface Segregation (разделение интерфейсов):** клиент не должен зависеть от методов, которые не использует. Лучше **несколько узких интерфейсов**, чем один «толстый». Иначе классы вынуждены реализовывать пустые или лишние методы.\n\n**D — Dependency Inversion (инверсия зависимостей):** зависимости должны быть от **абстракций**, а не от конкретных реализаций. Высокоуровневый модуль не должен импортировать низкоуровневый напрямую; оба зависят от интерфейса (абстрактного класса, протокола). Упрощает подмену реализаций, тестирование, смену инфраструктуры.' },
  { id: 32, question: 'GOF23: Порождающие паттерны (Creational)', answer: '**Порождающие паттерны** отвечают за создание объектов и снижают зависимость кода от конкретных классов.\n\n**Singleton** — один экземпляр класса на всё приложение; глобальная точка доступа.\n  class Singleton:\n    _instance = None\n    def __new__(cls):\n      if cls._instance is None:\n        cls._instance = super().__new__(cls)\n      return cls._instance\n\n**Factory Method** — создание объекта делегируется подклассам; клиент работает с абстрактным типом.\n  class Creator:\n    def factory_method(self): raise NotImplementedError\n    def use(self): return self.factory_method().do()\n  class ConcreteCreator(Creator):\n    def factory_method(self): return ConcreteProduct()\n\n**Abstract Factory** — создание семейства связанных продуктов без привязки к конкретным классам.\n  class GUIFactory:\n    def create_button(self): raise NotImplementedError\n    def create_checkbox(self): raise NotImplementedError\n  class WinFactory(GUIFactory): ...  # WinButton, WinCheckbox\n\n**Builder** — пошаговая сборка сложного объекта; один процесс — разные представления.\n  class Builder:\n    def set_a(self, x): self.a = x; return self\n    def set_b(self, x): self.b = x; return self\n    def build(self): return Product(self.a, self.b)\n  p = Builder().set_a(1).set_b(2).build()\n\n**Prototype** — копирование существующего объекта вместо создания через конструктор.\n  import copy\n  class Prototype:\n    def clone(self): return copy.deepcopy(self)' },
  { id: 33, question: 'GOF23: Структурные паттерны (Structural)', answer: '**Структурные паттерны** показывают, как собирать объекты и классы в более крупные структуры.\n\n**Adapter** — превращает интерфейс одного класса в другой, ожидаемый клиентом; интеграция несовместимого API.\n  class OldAPI: def specific_request(self): return "data"\n  class Adapter:\n    def __init__(self): self.old = OldAPI()\n    def request(self): return self.old.specific_request()\n\n**Decorator** — обёртка добавляет поведение без изменения класса; динамическое расширение.\n  def decorator(func):\n    def wrap(*a, **k): print("before"); r = func(*a,**k); print("after"); return r\n    return wrap\n  @decorator\ndef foo(): pass\n\n**Facade** — единый упрощённый интерфейс к подсистеме; скрывает сложность.\n  class SubsystemA: def run(self): ...\n  class Facade:\n    def __init__(self): self.a, self.b = SubsystemA(), SubsystemB()\n    def do_all(self): self.a.run(); self.b.run()\n\n**Proxy** — объект-заместитель контролирует доступ к реальному (ленивая инициализация, кэш, защита).\n  class Proxy:\n    def __init__(self): self._real = None\n    def request(self):\n      if self._real is None: self._real = RealSubject()\n      return self._real.request()\n\n**Composite** — композиция в древовидную структуру; к узлам и группам обращаются одинаково.\n  class Component: def operation(self): raise NotImplementedError\n  class Leaf(Component): def operation(self): return "Leaf"\n  class Composite(Component):\n    def __init__(self): self.children = []\n    def add(self, c): self.children.append(c)\n    def operation(self): return [c.operation() for c in self.children]\n\n**Bridge** — разделение абстракции и реализации, чтобы они могли меняться независимо.\n  class Implementor: def op(self): raise NotImplementedError\n  class Abstraction: def __init__(self, impl): self.impl = impl\n  def run(self): return self.impl.op()\n\n**Flyweight** — общее состояние вынесено; множество объектов делят его — экономия памяти.\n  class Flyweight:\n    _pool = {}\n    def __new__(cls, key): return cls._pool.setdefault(key, super().__new__(cls))' },
  { id: 40, question: 'Методы сортировки', answer: '**Bubble Sort (пузырьковая):** попарное сравнение соседних элементов, больший «всплывает» в конец. **O(n²)**. Стабильная, in-place. На практике почти не используют.\n  def bubble_sorting(arr: list[int]) -> list[int]:\n    is_changed = True\n    while is_changed:\n      is_changed = False\n      for n in range(len(arr) - 1):\n        if arr[n] > arr[n + 1]:\n          arr[n], arr[n + 1] = arr[n + 1], arr[n]\n          is_changed = True\n    return arr\n\n**Selection Sort (выбором):** на каждом шаге ищем минимум в неотсортированной части и ставим на текущую позицию. **O(n²)**. Не стабильная, in-place.\n  def selection(a):\n    for i in range(len(a)):\n      m = min(range(i, len(a)), key=lambda k: a[k])\n      a[i], a[m] = a[m], a[i]\n    return a\n\n**Insertion Sort (вставками):** по одному элементу вставляем в уже отсортированную часть на нужное место. **O(n²)** в общем, **O(n)** для почти отсортированных. Стабильная, in-place.\n  def insertion(a):\n    for i in range(1, len(a)):\n      j = i\n      while j > 0 and a[j - 1] > a[j]:\n        a[j], a[j - 1] = a[j - 1], a[j]\n        j -= 1\n    return a\n\n**Quick Sort (быстрая):** pivot, делим на «меньше» и «больше», рекурсия. **O(n log n)** в среднем, **O(n²)** в худшем. Не стабильная, in-place.\n  def quick(a):\n    if len(a) <= 1: return a\n    p = a[len(a) // 2]\n    left = [x for x in a if x < p]\n    mid = [x for x in a if x == p]\n    right = [x for x in a if x > p]\n    return quick(left) + mid + quick(right)\n\n**Merge Sort (слиянием):** делим пополам, рекурсия, сливаем два отсортированных подмассива. **O(n log n)**. Стабильная. **O(n)** доп. памяти.\n  def merge_sort(a):\n    if len(a) <= 1: return a\n    m = len(a) // 2\n    L, R = merge_sort(a[:m]), merge_sort(a[m:])\n    out, i, j = [], 0, 0\n    while i < len(L) and j < len(R):\n      if L[i] <= R[j]: out.append(L[i]); i += 1\n      else: out.append(R[j]); j += 1\n    return out + L[i:] + R[j:]\n\n**Heap Sort (пирамидальная):** строим кучу, извлекаем максимум, перестраиваем. **O(n log n)**. Не стабильная, in-place.\n  import heapq\n  def heap_sort(a):\n    heapq.heapify(a)\n    return [heapq.heappop(a) for _ in range(len(a))]' },
  { id: 42, question: 'Многопоточность и многопроцессорность', answer: '**Многопоточность (threading)** — несколько **потоков** в рамках **одного процесса**. Потоки делят общую память; переключение между ними легче, чем между процессами.\n\nВ **CPython** потоки ограничены **GIL**: в каждый момент выполняется байт-код только одного потока. Поэтому многопоточность даёт выигрыш в основном для **I/O-bound** задач (сеть, диск, ожидание ответа), где поток отдаёт GIL во время ожидания. Для **CPU-bound** (тяжёлые вычисления) потоки не ускоряют выполнение.\n\n**Многопроцессорность (multiprocessing)** — несколько **процессов**, у каждого свой интерпретатор и своя память. GIL действует только внутри одного процесса, поэтому процессы реально выполняют код параллельно на разных ядрах. Подходит для **CPU-bound** задач.\n\n**Плата за процессы:** больше потребление памяти; данные между процессами нужно передавать явно (сериализация, очереди, разделяемая память).\n\n**Когда что использовать:**\n**I/O-bound** (запросы к API, чтение файлов) — **threading** или **asyncio** (асинхронность в одном потоке).\n**CPU-bound** (обработка данных, расчёты) — **multiprocessing**.\n\n**Примеры в Python:**\n  import threading\n  t = threading.Thread(target=func, args=(a, b))\n  t.start(); t.join()\n\n  from multiprocessing import Process\n  p = Process(target=func, args=(a, b))\n  p.start(); p.join()' },
  { id: 43, question: 'Asyncio VS Threading VS Multiprocessing', answer: '**Асинхронность (asyncio)** — один поток, **кооперативная** многозадачность: корутины по очереди выполняют код и явно отдают управление (**await**). Пока одна корутина ждёт I/O, другие работают. Нет переключения контекста ОС и нет GIL-конфликтов между «потоками» — всё в одном потоке.\n\n**Многопоточность (threading)** — несколько потоков ОС в одном процессе; ОС переключает их. В CPython ограничены GIL, но при I/O поток отпускает GIL, поэтому для I/O-bound threading тоже полезен.\n\n**Когда выбирать asyncio:**\nМного **одновременных I/O-операций** (сотни/тысячи соединений, сокеты, HTTP-клиенты, очереди). Один поток, мало памяти на «поток», один event loop. Нужна поддержка **async/await** в коде и библиотеках (**aiohttp**, **asyncpg** и т.д.).\n\n**Когда выбирать threading:**\nУмеренное число I/O-задач; код или библиотеки **не асинхронные** (синхронные API). Проще внедрить без переписывания на async. Подходит, когда блокирующие вызовы уже есть и их не хочется менять.\n\n**Когда multiprocessing:**\n**CPU-bound** задачи (расчёты, обработка данных) — ни asyncio, ни threading не дадут прироста по CPU; только отдельные процессы.\n\n**Кратко:** I/O-bound, много соединений, готовы писать async — **asyncio**. I/O-bound, синхронный код, немного потоков — **threading**. CPU-bound — **multiprocessing**.' },
  { id: 44, question: 'Как устроено асинхронное программирование?', answer: '**Асинхронное программирование** — выполнение кода в **одном потоке** с **кооперативной** многозадачностью: задачи сами отдают управление в точках ожидания, вместо того чтобы поток блокировался.\n\n**Event loop (цикл событий)** — ядро: бесконечный цикл, который держит очередь готовых к выполнению **корутин** и обрабатывает события I/O (сокеты, таймеры). Когда корутина делает **await** на операции ввода-вывода, она «засыпает», event loop переключается на другую корутину; когда I/O завершён, первая снова попадает в очередь.\n\n**Корутина vs таска:**\n**Корутина** — объект, который возвращается при **вызове** функции **async def** (выполнение ещё не началось). Это «обещание» результата; чтобы корутина пошла в event loop, её нужно либо **await**-ить, либо обернуть в **таск**.\n\n**Таска (asyncio.Task)** — корутина, **уже запланированная** в event loop. Создаётся через **asyncio.create_task(coro)**. Таска начинает выполняться «в фоне»: loop переключается на неё без явного await в этом месте. **await task** — дождаться результата. Несколько тасок позволяют выполнять корутины **параллельно** (конкурентно) в одном потоке.\n\n**Футура (asyncio.Future)** — низкоуровневый объект-«**обещание**» результата: результат будет позже, пока Future в состоянии «ожидание». Когда операция завершена, в Future кладут результат (**set_result**) или исключение (**set_exception**); все, кто ждёт эту Future (**await future**), просыпаются и получают результат. **Таска** — подкласс Future: обёртка над корутиной, которая сама «заполняет» Future по завершении корутины. В коде чаще используют **create_task** и **await**; саму **Future** создают редко (например, при интеграции callback-библиотек с event loop).\n\n**Кратко:** корутина — это «что выполнять»; таска — «запущенная» корутина в loop, по которой можно ждать и отменять.\n\n**Простой пример:**\n  import asyncio\n  async def say_after(delay, text):\n    await asyncio.sleep(delay)\n    print(text)\n  async def main():\n    await say_after(1, \"hello\")\n    await say_after(1, \"world\")\n  asyncio.run(main())   # через 1 с hello, ещё через 1 с world\n\n**Параллельный запуск (таски):**\n  async def main():\n    t1 = asyncio.create_task(say_after(1, \"hello\"))\n    t2 = asyncio.create_task(say_after(1, \"world\"))\n    await t1\n    await t2\n  asyncio.run(main())   # через ~1 с оба сообщения\n\n**С gather():**\n  async def main():\n    await asyncio.gather(say_after(1, \"hello\"), say_after(1, \"world\"))\n  asyncio.run(main())   # через ~1 с оба сообщения; gather ждёт все корутины и возвращает список результатов\n\n**Неблокирующий I/O** — сокеты, HTTP-клиенты в asyncio отдают управление loop во время ожидания. Блокирующий код в корутине (обычный **time.sleep**, синхронные файлы) задерживает весь loop — используют **run_in_executor()** или async-аналоги (**asyncio.sleep**, aiofiles).' },
  { id: 45, question: 'Примитивы asyncio: Lock, Event, Semaphore, Queue', answer: '**Примитивы** — объекты для **координации** корутин: кто-то ждёт, кто-то сигналит или отпускает замок. Все операции **async** — не блокируют поток, отдают управление в event loop.\n\n**Lock (замок)** — **мьютекс**: в один момент замок держит только **одна** корутина. Остальные ждут **lock.acquire()** (или **async with lock**). Нужен, когда несколько корутин обращаются к **общему ресурсу** (файл, переменная) и важно, чтобы кусок кода выполнялся без вклинивания других.\n  lock = asyncio.Lock()\n  async def safe_update():\n    async with lock:\n      # только одна корутина здесь одновременно\n      shared_data.append(1)\n\n**Event (событие)** — **флаг**: изначально «не поднят». Одна корутина вызывает **event.set()** — «готово»; все, кто ждёт **event.wait()**, просыпаются. Удобно, когда одна задача что-то подготовила (загрузка, инициализация), а остальные должны подождать этого момента.\n  ready = asyncio.Event()\n  async def loader():\n    await load_config()\n    ready.set()\n  async def worker():\n    await ready.wait()\n    # конфиг уже загружен\n\n**Semaphore (семафор)** — **счётчик** одновременных «входов». Создаётся с лимитом: **Semaphore(3)** — не больше трёх корутин одновременно в защищённом участке. Остальные ждут **sem.acquire()** (или **async with sem**). Используют, чтобы **ограничить** нагрузку: не больше N запросов к API, не больше N соединений к БД.\n  sem = asyncio.Semaphore(2)\n  async def limited_request():\n    async with sem:\n      await do_http_request()\n  # максимум 2 запроса одновременно\n\n**Queue (очередь)** — **очередь сообщений** между корутинами. Одни кладут **await queue.put(item)**, другие забирают **item = await queue.get()**. Если очередь пуста, **get()** ждёт; если полна (при maxsize), **put()** ждёт. Классическая схема **производитель–потребитель**: воркеры обрабатывают задачи из общей очереди без явных замков.\n  q = asyncio.Queue(maxsize=10)\n  async def producer():\n    for i in range(5):\n      await q.put(i)\n  async def consumer():\n    while True:\n      x = await q.get()\n      if x is None: break\n      await process(x)\n  async def main():\n    await asyncio.gather(producer(), consumer())\n\n**Кратко:** **Lock** — один владелец ресурса. **Event** — «сигнал готовности» для многих. **Semaphore** — не больше N одновременно. **Queue** — передача данных между корутинами с ожиданием.' },
  { id: 46, question: 'Полезные методы asyncio', answer: '**asyncio.run(coro)** — точка входа: создаёт event loop, запускает переданную корутину, по завершении закрывает loop. Один вызов на программу (или на «островок» asyncio). Не использовать внутри уже запущенного loop.\n  async def main():\n    await asyncio.sleep(1)\n  asyncio.run(main())\n\n**asyncio.create_task(coro)** — планирует корутину в текущем loop и возвращает **Task**. Задача начинает выполняться «сразу» (конкурентно). **await task** — дождаться результата. Без create_task корутина не пойдёт параллельно с другими.\n  t = asyncio.create_task(fetch(url))\n  result = await t\n\n**asyncio.gather(*aws, return_exceptions=False)** — запускает несколько корутин **параллельно** и ждёт все. Возвращает **список результатов** в порядке аргументов. Если **return_exceptions=True**, исключения возвращаются как значения, а не пробрасываются.\n  results = await asyncio.gather(fetch(u1), fetch(u2), fetch(u3))\n  # results = [r1, r2, r3]\n\n**asyncio.sleep(delay)** — неблокирующая пауза: отдаёт управление в loop на указанное время. В отличие от **time.sleep** не блокирует поток.\n  await asyncio.sleep(2)\n\n**asyncio.wait_for(aw, timeout)** — ждёт одну корутину/таску, но не дольше **timeout** секунд. При превышении — **asyncio.TimeoutError**; сама задача при этом отменяется (**cancel**). Удобно для «запрос с таймаутом».\n  try:\n    result = await asyncio.wait_for(slow_request(), timeout=5.0)\n  except asyncio.TimeoutError:\n    print(\"таймаут\")\n\n**asyncio.wait(aws, return_when=...)** — ждёт набор задач; возвращает два множества: **(done, pending)**. **return_when**: **ALL_COMPLETED** (все), **FIRST_COMPLETED** (хотя бы одна), **FIRST_EXCEPTION** (одна завершилась исключением). Pending-задачи нужно при желании отменить.\n  done, pending = await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)\n  for t in pending:\n    t.cancel()\n\n**asyncio.to_thread(func, *args)** — выполняет **синхронную** функцию в отдельном потоке (пуле по умолчанию), не блокируя event loop. Возвращает результат. Python 3.9+.\n  result = await asyncio.to_thread(blocking_io, arg)\n\n**loop.run_in_executor(executor, func, *args)** — то же по смыслу: выполнить func в executor (например **None** — пул потоков по умолчанию). Возвращает Future, которую можно **await**.\n  loop = asyncio.get_event_loop()\n  result = await loop.run_in_executor(None, heavy_calc, data)\n\n**asyncio.shield(aw)** — «защита» от отмены: если отменяют внешнюю задачу (например gather), то **shield**-обёртка отменяется, а внутренняя задача продолжает выполняться. Нужно, когда одну задачу не должны отменить вместе с остальными.\n  await asyncio.gather(asyncio.shield(critical_task()), other_task())\n  # отмена gather не отменит critical_task\n\n**task.cancel()** — запрос на отмену таски. Таска получит **CancelledError** в точке следующего await. **await** отменённой таски пробрасывает **CancelledError**.\n  t = asyncio.create_task(long_running())\n  t.cancel()\n  try:\n    await t\n  except asyncio.CancelledError:\n    pass' },
  { id: 47, question: 'Async for и async with', answer: '**async for** — асинхронная итерация: перебираем объект, у которого **каждый следующий элемент** получается через **await** (например, чтение из потока по кускам, строки из async-файла). Обычный **for** ждёт синхронно; **async for** отдаёт управление в event loop на каждом шаге.\n\nОбъект должен быть **асинхронным итератором**: реализовать **__aiter__** (возвращает self или другой async iterator) и **__anext__** (async-метод: возвращает следующее значение или выбрасывает **StopAsyncIteration**). Встроенные **aiter()** и **anext()** работают с такими объектами.\n\n**Пример (async for по асинхронному итератору):**\n  class AsyncRange:\n    def __init__(self, n): self.n = n; self.i = 0\n    def __aiter__(self): return self\n    async def __anext__(self):\n      if self.i >= self.n: raise StopAsyncIteration\n      i = self.i; self.i += 1\n      await asyncio.sleep(0)\n      return i\n  async def main():\n    async for x in AsyncRange(3):\n      print(x)  # 0, 1, 2\n  asyncio.run(main())\n\n**Типичное применение:** чтение из **StreamReader** (asyncio), построчное чтение через **aiofiles**, перебор страниц API с пагинацией.\n\n**async with** — асинхронный контекстный менеджер: **вход** и **выход** из контекста — корутины. При входе вызывается **await obj.__aenter__()**, при выходе (нормальном или по исключению) — **await obj.__aexit__(...)**. Используют для ресурсов, которые нужно **асинхронно** открывать и закрывать: соединение к БД, сокет, **Lock**, транзакция.\n\n**Пример (async with Lock):**\n  lock = asyncio.Lock()\n  async def safe_work():\n    async with lock:\n      # только одна корутина здесь\n      await do_work()\n  # при выходе lock автоматически отпускается\n\n**Пример (async with соединение):**\n  async with aiohttp.ClientSession() as session:\n    async with session.get(url) as resp:\n      data = await resp.json()\n  # сессия и ответ закрываются после блока\n\n**Кратко:** **async for** — перебор по одному элементу с **await** на каждом шаге; объект с **__aiter__** и **__anext__**. **async with** — асинхронное «вход/выход» по **__aenter__** и **__aexit__**; для соединений, замков, транзакций.' },
  { id: 41, question: 'Бинарный поиск', answer: '**Бинарный поиск** — поиск в **отсортированном** массиве за **O(log n)** сравнений. На каждом шаге сравниваем искомое значение с элементом в середине диапазона: если меньше — ищем в левой половине, если больше — в правой. Размер области поиска каждый раз уменьшается вдвое.\n\n**Когда применять:** массив (или диапазон) отсортирован; нужно найти элемент, границу (первый ≥ x, последний ≤ x) или «бинарный поиск по ответу» (проверяем значение mid, сужаем диапазон).\n\n**Сложность:** **O(log n)** по времени, **O(1)** по памяти (итеративная реализация).\n\n**Пример (поиск индекса или -1):**\n  def binary_search(arr: list[int], target: int) -> int:\n    left, right = 0, len(arr) - 1\n    while left <= right:\n      mid = (left + right) // 2\n      if arr[mid] == target:\n        return mid\n      if arr[mid] < target:\n        left = mid + 1\n      else:\n        right = mid - 1\n    return -1\n\n**Важно:** границы **left/right** и условие **left <= right** должны быть согласованы, иначе возможен бесконечный цикл или пропуск элемента. Для «первый ≥ target» (lower_bound) возвращаем **left** после цикла (при right = mid - 1 и left = mid + 1).' },
  { id: 34, question: 'GOF23: Поведенческие паттерны (Behavioral)', answer: '**Поведенческие паттерны** решают задачи взаимодействия объектов и распределения ответственности.\n\n**Command** — запрос инкапсулирован в объект; отложенное выполнение, очереди, отмена.\n  class Command:\n    def __init__(self, receiver): self.receiver = receiver\n    def execute(self): self.receiver.action()\n  class Invoker: def set_command(self, c): self.cmd = c\n  def run(self): self.cmd.execute()\n\n**Chain of Responsibility** — запрос передаётся по цепочке обработчиков, пока кто-то не обработает.\n  class Handler:\n    def __init__(self): self.next = None\n    def handle(self, req):\n      if self.can_handle(req): return self.process(req)\n      return self.next.handle(req) if self.next else None\n\n**Observer** — подписчики уведомляются об изменениях субъекта; слабая связь.\n  class Subject:\n    def __init__(self): self._observers = []\n    def attach(self, o): self._observers.append(o)\n    def notify(self): [o.update(self) for o in self._observers]\n  class Observer: def update(self, subj): print("notified")\n\n**Strategy** — алгоритмы вынесены в отдельные классы; выбор в runtime, взаимозаменяемость.\n  class Strategy: def algo(self, data): raise NotImplementedError\n  class Context:\n    def __init__(self, strategy): self.strategy = strategy\n    def do(self, data): return self.strategy.algo(data)\n  ctx = Context(ConcreteStrategyA()); ctx.do(data)\n\n**Unit of Work** — накопление изменений и один коммит; согласованность транзакции.\n  class UnitOfWork:\n    def __init__(self): self.new, self.dirty, self.deleted = [], [], []\n    def register_new(self, e): self.new.append(e)\n    def commit(self): [repo.insert(e) for e in self.new]; ...\n\n**State** — поведение объекта зависит от внутреннего состояния; замена условных переходов на классы состояний.\n  class State: def handle(self, ctx): raise NotImplementedError\n  class Context: def __init__(self): self.state = StateA()\n  def request(self): self.state.handle(self)  # state может сменить self.state\n\n**Template Method** — скелет алгоритма в базовом классе; подклассы переопределяют шаги.\n  class Abstract:\n    def template(self): self.step1(); self.step2()  # step2 — переопределяют\n    def step1(self): ...\n    def step2(self): raise NotImplementedError' },
  { id: 50, question: 'Функция высшего порядка', answer: '**Функция высшего порядка** — функция, которая принимает одну или несколько **функций как аргументы** и/или **возвращает функцию**. В Python функции — объекты первого класса: их можно передавать, возвращать и хранить в переменных.\n\n**Принимает функцию как аргумент:** типичный случай — обобщённая логика (обход коллекции, фильтрация), а конкретное действие задаётся переданной функцией.\n  def apply_twice(f, x):\n    return f(f(x))\n  apply_twice(lambda n: n * 2, 5)   # 20\n\n**Встроенные функции высшего порядка:**\n**map(f, iterable)** — применяет **f** к каждому элементу, возвращает итератор результатов.\n  list(map(str.upper, [\'a\', \'b\']))   # [\'A\', \'B\']\n\n**filter(predicate, iterable)** — оставляет только элементы, для которых **predicate(x)** истинно.\n  list(filter(lambda x: x > 0, [-1, 2, -3, 4]))   # [2, 4]\n\n**sorted(iterable, key=f)** — сортирует по ключу **key**: для каждого элемента вызывается **f(x)**.\n  sorted([\'ab\', \'a\', \'abc\'], key=len)   # [\'a\', \'ab\', \'abc\']\n\n**functools.reduce(f, iterable, initial)** — сводит последовательность к одному значению, попарно применяя **f** (например, сумма, произведение).\n  from functools import reduce\n  reduce(lambda a, b: a + b, [1, 2, 3])   # 6\n\n**Возвращает функцию:** фабрика функций, замыкания, декораторы без вызова.\n  def make_multiplier(n):\n    def mul(x):\n      return x * n\n    return mul\n  double = make_multiplier(2)\n  double(5)   # 10\n\n**Кратко:** функция высшего порядка — принимает и/или возвращает функции; **map**, **filter**, **sorted**, **reduce** и свои обёртки (декораторы, фабрики).' },
  { id: 51, question: 'Работа с памятью в Python', answer: '**Иерархия памяти:** **арена (256 КБ)** → **пулы (4 КБ)** → **блоки (8–512 байт)**. Мелкие объекты живут в блоках; крупные выделяются напрямую у ОС.\n\n**Счётчик ссылок:** каждый объект хранит число ссылок на себя. **=** увеличивает, **del** или переприсваивание — уменьшает. Счётчик = 0 → объект удаляется.\n\n**Циклические ссылки:** если A → B → A, счётчики не обнулятся сами. Их находит **Garbage Collector (gc)**. **gc.collect()** — запустить вручную.\n\n**Полезные функции:**\n  sys.getrefcount(obj)  # счётчик ссылок\n  id(obj)               # адрес в памяти\n  sys.getsizeof(obj)    # размер объекта в байтах\n\n**weakref:** обычная ссылка «держит» объект в памяти (счётчик > 0). Слабая ссылка — как записка «где лежит объект», но она не мешает Python его удалить. Если объект удалён — weakref вернёт None. Используют в кэшах: храним данные, пока они кому-то нужны, но не мешаем их удалить, когда память нужна.\n\n**Экономия памяти:** **__slots__** убирает **__dict__** у экземпляров — меньше памяти при множестве объектов.' },
  { id: 52, question: 'Ключи словарей и коллизии', answer: '**Что такое коллизия:** ситуация, когда два разных ключа имеют **одинаковый хэш** (или одинаковый индекс ячейки после **hash(key) % размер_таблицы**).\n\n**Почему коллизии возникают:** хэш-функция не может создать уникальное число для каждого возможного ключа (бесконечное множество ключей → конечное количество хэшей). Даже хорошая хэш-функция иногда даёт одинаковые значения для разных объектов.\n\n**Как Python решает коллизии:** в каждой ячейке таблицы хранится список пар **(ключ, значение)**. При коллизии новый элемент просто добавляется в этот список. При поиске/получении значения Python: находит нужную ячейку по хэшу → перебирает все элементы в списке этой ячейки → сравнивает каждый ключ с искомым с помощью **==** → возвращает значение, когда нашёл совпадение.\n\n**Ключевые моменты:** **хэш** — это только подсказка «где примерно искать»; **==** — это то, что решает, тот ли это ключ. Если коллизий мало → поиск очень быстрый (**O(1)** в среднем). Если коллизий очень много → одна ячейка превращается в длинный список → скорость падает (в худшем случае **O(n)**).\n\n**Пример в голове:**\n  d = {\"listen\": \"слушать\", \"silent\": \"тишина\", \"bad\": 42}\n  # если все три ключа попали в одну ячейку:\n  # ячейка №7 → [(\"listen\", \"слушать\"), (\"silent\", \"тишина\"), (\"bad\", 42)]\n  # при запросе d[\"silent\"]:\n  # идём в ячейку 7\n  # \"listen\" == \"silent\"? → нет\n  # \"silent\" == \"silent\"? → да → возвращаем \"тишина\"\n\n**Вывод:** коллизии — нормальная и ожидаемая часть работы словаря. Python сделан так, чтобы они не ломали программу и не приводили к потере данных. Главное — хорошая хэш-функция и правильное определение **__eq__**, если вы создаёте свои классы как ключи. В обычном коде проблемы из-за коллизий почти не встречаются — **dict** в Python быстрый и надёжный.' },
  { id: 53, question: 'Очереди задач (Task Queues)', answer: '**Зачем нужны:** некоторые операции слишком долгие для обычного запроса (отправка email, обработка видео, генерация отчёта). Пользователь не должен ждать — задачу кладут в очередь, а отдельный воркер выполнит её в фоне.\n\n**Как работает:**\n1. Приложение кладёт задачу в **брокер** (очередь сообщений) — Redis, RabbitMQ\n2. **Воркер** (отдельный процесс) забирает задачу из очереди\n3. Воркер выполняет задачу и (опционально) сохраняет результат\n\n**Пример с Celery:**\n  # tasks.py\n  from celery import Celery\n  app = Celery(\"tasks\", broker=\"redis://localhost\")\n\n  @app.task\n  def send_email(to, subject, body):\n      # долгая операция\n      ...\n\n  # views.py\n  send_email.delay(\"user@mail.com\", \"Hi\", \"Hello!\")  # задача ушла в очередь\n  return {\"status\": \"email queued\"}  # ответ сразу\n\n**Популярные инструменты:** **Celery** (самый популярный, работает с Redis/RabbitMQ), **RQ** (Redis Queue — проще Celery), **Dramatiq** (современная альтернатива Celery), **Huey** (лёгкий, для небольших проектов).\n\n**Когда использовать:** отправка писем/SMS, обработка файлов и изображений, генерация PDF/отчётов, синхронизация с внешними API, любые операции > 1-2 секунд.\n\n**Кратко:** задача уходит в очередь → пользователь получает ответ сразу → воркер выполняет задачу в фоне.' },
  { id: 54, question: 'Объединение словарей', answer: '**1. Оператор | (Python 3.9+):** создаёт новый словарь; при совпадении ключей — значение из правого.\n  a = {\"x\": 1, \"y\": 2}\n  b = {\"y\": 3, \"z\": 4}\n  result = a | b   # {\"x\": 1, \"y\": 3, \"z\": 4}\n\n**2. Оператор |= (Python 3.9+):** обновляет словарь на месте (как update).\n  a |= b   # a теперь {\"x\": 1, \"y\": 3, \"z\": 4}\n\n**3. Распаковка ** (Python 3.5+):** создаёт новый словарь.\n  result = {**a, **b}   # {\"x\": 1, \"y\": 3, \"z\": 4}\n\n**4. Метод update():** изменяет исходный словарь на месте, ничего не возвращает.\n  a.update(b)   # a изменён\n\n**5. dict() + распаковка:**\n  result = dict(a, **b)   # работает, если ключи b — строки\n\n**6. Цикл (старый способ):**\n  result = a.copy()\n  for k, v in b.items():\n      result[k] = v\n\n**7. ChainMap (без копирования):** не создаёт новый словарь, а «смотрит» в оба; изменения отражаются в оригиналах.\n  from collections import ChainMap\n  combined = ChainMap(b, a)   # приоритет у b\n\n**Что выбрать:** **a | b** — самый читаемый (Python 3.9+). **{**a, **b}** — если нужна совместимость с 3.5+. **update()** — если не нужен новый словарь.' },
  { id: 55, question: 'Операторы and и or', answer: '**Порядок вычисления:** сначала все **and** слева направо, потом все **or** слева направо (and имеет больший приоритет).\n\n**and** — возвращает **первый False** (или falsy) элемент. Если все True — возвращает **последний**.\n  0 and 5        # 0 (первый falsy)\n  \"\" and \"hi\"    # \"\" (пустая строка — falsy)\n  3 and 5 and 7  # 7 (все truthy → последний)\n  True and 42    # 42\n\n**or** — возвращает **первый True** (или truthy) элемент. Если все False — возвращает **последний**.\n  0 or 5         # 5 (первый truthy)\n  \"\" or \"hi\"     # \"hi\"\n  None or 0 or \"\"  # \"\" (все falsy → последний)\n  \"a\" or \"b\"     # \"a\" (первый truthy)\n\n**Комбинация and и or:**\n  0 and 1 or 2   # сначала 0 and 1 → 0, потом 0 or 2 → 2\n  1 and 2 or 3   # сначала 1 and 2 → 2, потом 2 or 3 → 2\n  0 or 1 and 2   # сначала 1 and 2 → 2, потом 0 or 2 → 2\n\n**Практическое применение:**\n  name = user_name or \"Anonymous\"   # значение по умолчанию\n  x = data and data[0]              # безопасный доступ\n\n**Falsy-значения:** **False**, **None**, **0**, **\"\"**, **[]**, **{}**, **set()**. Всё остальное — truthy.' },
  { id: 56, question: 'Monkey patch', answer: '**Monkey patch** — изменение класса или модуля **в рантайме**: подмена или добавление метода/атрибута после того, как код уже определён. Возможно благодаря тому, что в Python классы и функции — объекты, их атрибуты можно переназначать.\n\n**Зачем используют:** исправить баг в сторонней библиотеке без правки её кода; добавить поведение к чужому классу; в тестах — подменить реальный вызов (сеть, БД) на заглушку.\n\n**Пример (подмена метода класса):**\n  class Dog:\n    def say(self):\n      return \"woof\"\n\n  def new_say(self):\n    return \"meow\"\n\n  Dog.say = new_say   # monkey patch\n  d = Dog()\n  d.say()   # \"meow\"\n\n**Пример (подмена функции в модуле):**\n  import requests\n  def fake_get(*args, **kwargs):\n    return type(\"Resp\", (), {\"status_code\": 200, \"json\": lambda: {}})()\n  requests.get = fake_get   # все вызовы requests.get теперь возвращают заглушку\n\n**Осторожно:** меняет поведение глобально; усложняет отладку и понимание кода. Лучше использовать только там, где нет контроля над исходным кодом (сторонние библиотеки, тесты).\n\n**Кратко:** monkey patch — переназначение атрибута/метода класса или модуля в рантайме; удобно для фиксов и тестов, но злоупотреблять не стоит.' },
  { id: 57, question: 'Создание класса через type()', answer: '**type(name, bases, dict)** — встроенная функция, которая **создаёт класс** в рантайме. Три аргумента: **name** — имя класса (строка), **bases** — кортеж базовых классов, **dict** — словарь атрибутов и методов класса (namespace). Возвращает новый тип (класс).\n\n**Зачем:** динамическое создание классов (по данным из конфига, API, фабрики классов); понимание, что **class** — это синтаксический сахар над вызовом **type** (или метакласса).\n\n**Пример (эквивалент обычного класса):**\n  def greet(self):\n    return f\"Hi, {self.name}\"\n  Person = type(\"Person\", (object,), {\"name\": \"\", \"greet\": greet})\n  p = Person()\n  p.name = \"Alice\"\n  p.greet()   # \"Hi, Alice\"\n\nТо же самое через **class**:\n  class Person:\n    name = \"\"\n    def greet(self):\n      return f\"Hi, {self.name}\"\n\n**Пример (наследование):**\n  Animal = type(\"Animal\", (object,), {\"say\": lambda self: \"...\"})\n  Dog = type(\"Dog\", (Animal,), {\"say\": lambda self: \"woof\"})\n  Dog().say()   # \"woof\"\n\n**Связь с метаклассами:** при выполнении **class Foo:** Python вызывает метакласс (по умолчанию **type**) с именем, базами и namespace; то есть создание класса — это вызов **type(...)** или **YourMeta(...)**.\n\n**Кратко:** **type(name, bases, dict)** создаёт класс в рантайме; **class** под капотом делает то же через метакласс (по умолчанию type).' },
  { id: 58, question: 'Unit of Work', answer: '**Unit of Work** — паттерн, при котором **несколько операций** с данными (добавление, изменение, удаление) объединяются в **одну транзакцию**. Либо выполняются все изменения, либо ни одно; при ошибке — откат целиком.\n\n**Зачем:** согласованность данных; не держать в голове «что уже сохранил, что ещё нет» — накапливаем изменения и один раз **commit** или **rollback**.\n\n**Идея:** объект Unit of Work **отслеживает** новые, изменённые и удалённые сущности; при вызове **commit()** применяет все изменения к БД в одной транзакции.\n\n**Пример (концептуальный):**\n  class UnitOfWork:\n    def __init__(self):\n      self.new = []      # объекты для insert\n      self.dirty = []   # изменённые\n      self.removed = [] # для delete\n    def register_new(self, obj): self.new.append(obj)\n    def register_dirty(self, obj): self.dirty.append(obj)\n    def register_removed(self, obj): self.removed.append(obj)\n    def commit(self):\n      for o in self.new: save(o)\n      for o in self.dirty: update(o)\n      for o in self.removed: delete(o)\n      # один commit транзакции\n\n**Пример (использование в сервисном слое):** созданный Unit of Work передаётся в сервис; сервис регистрирует изменения в UoW и в конце вызывает **commit()**.\n  class OrderService:\n    def __init__(self, uow: UnitOfWork):\n      self.uow = uow\n    def create_order(self, user_id, items):\n      order = Order(user_id=user_id, items=items)\n      self.uow.register_new(order)\n      for item in items:\n        self.uow.register_new(item)\n      self.uow.commit()   # одна транзакция — заказ и позиции\n  uow = UnitOfWork()\n  service = OrderService(uow)\n  service.create_order(1, [item1, item2])\n\n**В ORM:**\n- **Django:** **with transaction.atomic():** — блок внутри одной транзакции; при исключении — откат.\n  from django.db import transaction\n  with transaction.atomic():\n    User.objects.create(name=\"A\")\n    Order.objects.create(user_id=...)\n  # оба сохранены или оба откат\n\n- **SQLAlchemy:** **session** — Unit of Work: **session.add()**, **session.delete()**, изменение атрибутов; **session.commit()** — одна транзакция, **session.rollback()** — откат.\n  session.add(user)\n  session.add(order)\n  session.commit()   # всё разом\n\n**Кратко:** Unit of Work — накапливаем изменения и сохраняем одной транзакцией; в Django — **transaction.atomic()**, в SQLAlchemy — **session.commit()**.' },
  { id: 59, question: 'Слоистая архитектура (Layered)', answer: '**Слоистая архитектура** — разделение приложения на **горизонтальные слои**; каждый слой использует только слой ниже. Запрос идёт сверху вниз (UI → бизнес-логика → данные), ответ — обратно.\n\n**Типичные слои (сверху вниз):**\n- **Presentation** — API, контроллеры, формы; принимает запросы и отдаёт ответы.\n- **Business (Service)** — бизнес-правила, оркестрация; не знает про HTTP и БД.\n- **Data access (Repository)** — работа с БД, ORM, внешние сервисы.\n\n**Правило:** слой зависит только от слоя под ним; верхние слои не импортируют нижние «напрямую» в обход границ (зависимости через интерфейсы/абстракции при необходимости).\n\n**Пример (упрощённо):**\n  # Presentation — контроллер/views\n  class OrderController:\n    def __init__(self, order_service: OrderService):\n      self.service = order_service\n    def create(self, user_id, items):\n      order = self.service.create_order(user_id, items)\n      return {\"order_id\": order.id}\n\n  # Business — сервис\n  class OrderService:\n    def __init__(self, repo: OrderRepository):\n      self.repo = repo\n    def create_order(self, user_id, items):\n      order = Order(user_id=user_id, items=items)\n      self.repo.save(order)\n      return order\n\n  # Data access — репозиторий\n  class OrderRepository:\n    def save(self, order):\n      OrderModel.objects.create(...)\n\n**Плюсы:** понятное разделение, легко находить код. **Минусы:** при росте числа слоёв — «толстые» сервисы и проход через все слои.\n\n**Кратко:** слои Presentation → Service → Repository; зависимость только вниз.' },
  { id: 60, question: 'Чистая архитектура (Clean Architecture)', answer: '**Чистая архитектура** (Uncle Bob) — структура, где **ядро приложения не зависит** от фреймворков, БД и UI. Зависимости направлены **внутрь**: внешние слои зависят от внутренних, а не наоборот.\n\n**Кольца (изнутри наружу):**\n- **Entities** — сущности и правила предметной области; без зависимостей.\n- **Use cases** — сценарии приложения (один сценарий — один класс); зависят только от entities.\n- **Interface adapters** — презентеры, шлюзы к БД/API; реализуют интерфейсы, заданные use cases.\n- **Frameworks & drivers** — БД, HTTP, UI; подключают адаптеры.\n\n**Правило зависимостей:** внутренние кольца не знают о внешних. Use case объявляет интерфейс репозитория; адаптер в наружном кольце его реализует и внедряется (DI).\n\n**Пример (ядро + адаптер):**\n  # Entities (ядро)\n  class Order:\n    def __init__(self, user_id, items):\n      self.user_id = user_id\n      self.items = items\n\n  # Use case — зависит от абстракции репозитория\n  class CreateOrderUseCase:\n    def __init__(self, order_repo):  # интерфейс: save(order)\n      self.repo = order_repo\n    def execute(self, user_id, items):\n      order = Order(user_id, items)\n      self.repo.save(order)\n      return order\n\n  # Адаптер (внешний слой) — реализует репозиторий для БД\n  class DjangoOrderRepository:\n    def save(self, order):\n      OrderModel.objects.create(user_id=order.user_id, ...)\n\n  # Сборка (внешний слой)\n  repo = DjangoOrderRepository()\n  use_case = CreateOrderUseCase(repo)\n  # контроллер вызывает use_case.execute(...)\n\n**Плюсы:** ядро тестируемо без БД/HTTP; замена БД или UI не трогает use cases. **Минусы:** больше классов и абстракций.\n\n**Кратко:** зависимости внутрь; entities и use cases без фреймворков; адаптеры реализуют интерфейсы use cases.' },
  { id: 61, question: 'СУБД', answer: '**СУБД** (система управления базами данных) — программа, которая **создаёт, хранит и обрабатывает** данные в базе. Пользователь или приложение обращаются к СУБД (через SQL или API), а не к файлам напрямую.\n\n**Основные функции:**\n- **хранение** данных на диске с эффективной структурой;\n- **запросы** — выборка, вставка, обновление, удаление (SQL или аналог);\n- **транзакции** — группа операций как одна единица (commit/rollback);\n- **целостность** — ограничения, ключи, проверки;\n- **безопасность** — пользователи, права доступа;\n- **резервное копирование и восстановление**.\n\n**Типы СУБД:**\n- **Реляционные (SQL):** данные в таблицах, связи по ключам. **PostgreSQL**, **MySQL**, **SQLite**.\n- **Документные (NoSQL):** документы (JSON). **MongoDB**.\n- **Ключ–значение:** быстрый доступ по ключу. **Redis**, **Memcached**.\n- **Колоночные:** аналитика, большие объёмы. **ClickHouse**, **Cassandra**.\n\n**Пример (обращение к СУБД из приложения):** приложение подключается к СУБД драйвером/ORM и выполняет запросы — СУБД отвечает за физическое хранение и выполнение.\n  # PostgreSQL через psycopg2\n  conn = psycopg2.connect(\"dbname=mydb user=app\")\n  cur = conn.cursor()\n  cur.execute(\"SELECT * FROM users WHERE id = %s\", (1,))\n  row = cur.fetchone()\n\n**Кратко:** СУБД — программа, которая управляет базой данных: хранение, запросы, транзакции, целостность; реляционные (PostgreSQL, MySQL), документные (MongoDB), ключ–значение (Redis).' },
  { id: 62, question: 'Связь нескольких таблиц в SQL', answer: '**Связь таблиц** задаётся через **внешний ключ (FOREIGN KEY)**: в одной таблице хранится значение, ссылающееся на **первичный ключ (PRIMARY KEY)** другой таблицы. Выборка из нескольких связанных таблиц делается через **JOIN**.\n\n**Типы JOIN:**\n- **INNER JOIN** — только строки, где есть совпадение в **обеих** таблицах.\n- **LEFT JOIN** — все строки **левой** таблицы + совпадения справа; если справа нет — NULL.\n- **RIGHT JOIN** — все строки **правой** таблицы + совпадения слева.\n- **FULL OUTER JOIN** — все строки обеих таблиц; нет совпадения — NULL.\n- **CROSS JOIN** — «все со всеми»: каждую строку первой таблицы соединяем с **каждой** строкой второй. Условия ON нет. Если в первой таблице 3 строки, во второй 4 — получится 3 × 4 = 12 строк. Нужен, когда нужны все возможные пары (например, пользователи × товары).\n- **SEMI JOIN** — данные из первой таблицы, удовлетворяющие указанному условию соединения двух таблиц, **без возвращения данных второй таблицы**. В SQL выражается через **EXISTS** или **IN** (подзапрос); отдельного ключевого слова SEMI JOIN нет.\n\n**Пример таблиц (данные):**\n\n  users:\n  id | name\n  ---+------\n  1  | Alice\n  2  | Bob\n\n  orders:\n  id | user_id | total\n  ---+---------+------\n  1  | 1       | 100\n  2  | 2       | 200\n  3  | 1       | 150\n\n  Связь: orders.user_id → users.id (внешний ключ).\n\n**Примеры запросов и результаты:**\n\n  -- INNER JOIN: заказы с именем пользователя\n  SELECT o.id, o.total, u.name FROM orders o\n  INNER JOIN users u ON u.id = o.user_id;\n  Результат:\n  id | total | name\n  ---+-------+------\n  1  | 100   | Alice\n  2  | 200   | Bob\n  3  | 150   | Alice\n\n  -- LEFT JOIN: все пользователи и их заказы (без заказа — order_id, total = NULL)\n  SELECT u.name, o.id AS order_id, o.total FROM users u\n  LEFT JOIN orders o ON o.user_id = u.id;\n  Результат:\n  name  | order_id | total\n  ------+----------+------\n  Alice | 1        | 100\n  Alice | 3        | 150\n  Bob   | 2        | 200\n\n  -- CROSS JOIN: все пары пользователь × заказ (исходные таблицы users и orders)\n  SELECT u.name, o.id AS order_id, o.total FROM users u CROSS JOIN orders o;\n  Результат:\n  name  | order_id | total\n  ------+----------+------\n  Alice | 1        | 100\n  Alice | 2        | 200\n  Alice | 3        | 150\n  Bob   | 1        | 100\n  Bob   | 2        | 200\n  Bob   | 3        | 150\n\n  -- SEMI JOIN (EXISTS): пользователи, у которых есть хотя бы один заказ\n  SELECT * FROM users u\n  WHERE EXISTS (SELECT 1 FROM orders o WHERE o.user_id = u.id);\n  Результат:\n  id | name\n  ---+------\n  1  | Alice\n  2  | Bob\n  То же через IN: SELECT * FROM users WHERE id IN (SELECT user_id FROM orders);\n\n  -- FULL OUTER JOIN: все строки из обеих таблиц; нет совпадения — NULL\n  (добавим пользователя Carol без заказов)\n  SELECT u.name, o.id AS order_id, o.total FROM users u\n  FULL OUTER JOIN orders o ON o.user_id = u.id;\n  Результат:\n  name  | order_id | total\n  ------+----------+------\n  Alice | 1        | 100\n  Alice | 3        | 150\n  Bob   | 2        | 200\n  Carol | NULL     | NULL\n\n**Кратко:** связь — через **FOREIGN KEY**; **INNER** / **LEFT** / **RIGHT** / **FULL**; **CROSS** — декартово произведение; **SEMI** — «есть совпадение» через **EXISTS** или **IN**.' },
  { id: 63, question: 'Signals (Django)', answer: '**Signals** в Django — механизм **уведомлений**: при действиях с моделью (сохранение, удаление и т.д.) вызывается ваша функция **без изменения кода модели**. Приложения остаются **слабо связанными**.\n\n**Зачем:** побочные действия при событии — письмо при создании пользователя, создание профиля при первом **save**, обновление кэша, логирование.\n\n**Основные сигналы** (`django.db.models.signals`):\n- **pre_save** / **post_save** — до/после сохранения (create и update).\n- **pre_delete** / **post_delete** — до/после удаления.\n- **pre_init** / **post_init** — до/после создания экземпляра в памяти.\n- **m2m_changed** — при изменении связи многие-ко-многим (add, remove, clear); в **kwargs**: **action** (\'post_add\', \'pre_remove\' и т.д.), **pk_set**, **model**.\n\n**Подключение:** декоратор **@receiver(signal, sender=Model)** или **Signal.connect(receiver, sender=Model)**.\n\n**Регистрация в AppConfig.ready() — подробнее:**\n**Зачем:** метод **ready()** вызывается один раз при старте Django, когда все приложения и **модели уже загружены**. Если подключать сигналы при импорте модуля (на уровне файла), возможны **циклические импорты** (модель из другого приложения ещё не импортирована) или ситуация, когда код сигналов выполнится до полной инициализации приложений. В **ready()** порядок загрузки гарантирован.\n**Как:** в приложении объявляют **AppConfig** (в **apps.py**), в нём переопределяют **ready()** и там импортируют модуль с сигналами (или вызывают **connect**). Импорт модуля выполнит декораторы **@receiver** и зарегистрирует обработчики.\n**Пример:**\n  # myapp/apps.py\n  from django.apps import AppConfig\n\n  class MyAppConfig(AppConfig):\n      default_auto_field = \'django.db.models.BigAutoField\'\n      name = \'myapp\'\n\n      def ready(self):\n          import myapp.signals  # подтянет @receiver и connect\n\n  # в settings.INSTALLED_APPS указывать: \'myapp.apps.MyAppConfig\'\n\nЕсли не использовать **ready()**, а подключать при импорте **models.py**, при импорте моделей из других приложений в **sender=** можно получить ошибку «модель ещё не загружена». **dispatch_uid** в **@receiver** помогает избежать двойной регистрации при повторном вызове **ready()** (например, в тестах).\n\n**Аргументы @receiver (декоратор):**\n- **signal** — сам сигнал (post_save, post_delete, m2m_changed и т.д.).\n- **sender** — модель-источник (класс Model). Если не указать, обработчик вызывается для **любой** модели, отправившей этот сигнал.\n- **dispatch_uid** — уникальная строка (например, \'myapp.create_profile\'), чтобы один и тот же обработчик не подключался несколько раз при повторном импорте модуля (важно в тестах и при перезагрузке).\n\n**Аргументы функции-обработчика** (передаёт сигнал):\n- **post_save:** **sender** — класс модели; **instance** — сохранённый объект; **created** — True при создании новой записи, False при update; **update_fields** — множество полей при вызове save(update_fields=(...)), иначе None; **raw** — True при loaddata. Остальное в **kwargs**.\n- **post_delete:** **sender** — класс модели; **instance** — удалённый объект (запись в БД уже нет). Остальное в **kwargs**.\n- **m2m_changed:** **sender** — промежуточная модель связи (through); **instance** — объект, у которого меняли M2M-поле; **action** — \'pre_add\', \'post_add\', \'pre_remove\', \'post_remove\', \'pre_clear\', \'post_clear\'; **pk_set** — множество id добавленных/удалённых записей; **model** — класс «другой» стороны связи; **reverse** — направление (прямая/обратная). Остальное в **kwargs**.\n\n**Примеры (по одному на популярный сигнал):**\n\n**post_save** — создать профиль при создании пользователя:\n  @receiver(post_save, sender=User)\n  def create_profile(sender, instance, created, **kwargs):\n      if created:\n          UserProfile.objects.get_or_create(user=instance)\n\n**pre_save** — заполнить slug из title перед сохранением:\n  @receiver(pre_save, sender=Article)\n  def set_slug(sender, instance, **kwargs):\n      if not instance.slug:\n          instance.slug = slugify(instance.title)\n\n**post_delete** — инвалидировать кэш при удалении объекта:\n  @receiver(post_delete, sender=Product)\n  def invalidate_product_cache(sender, instance, **kwargs):\n      cache.delete(f\'product:{instance.id}\')\n\n**m2m_changed** — среагировать после добавления тегов к посту:\n  @receiver(m2m_changed, sender=Post.tags.through)\n  def on_post_tags_changed(sender, instance, action, **kwargs):\n      if action == \'post_add\' or action == \'post_remove\':\n          cache.delete(f\'post:{instance.id}:tags\')\n\n**Важно:** в **post_save** не вызывать **instance.save()** для той же модели — риск бесконечного цикла. Тяжёлую работу выносить в задачу (Celery).\n\n**Кратко:** Signals — уведомления при действиях с моделями; **post_save**, **post_delete**, **m2m_changed**; подписка через **@receiver** или **connect**; регистрация в **AppConfig.ready()**.' },
  { id: 64, question: 'Views', answer: '**Типы представлений** в Django: **FBV** (функция) и **CBV** (класс). Классы дают переиспользование через наследование, **миксины** и **дженерики**.\n\n**FBV** — функция принимает **request**, возвращает **HttpResponse**. Роутинг: path(\'url/\', views.my_view).\n\n**CBV** — класс с методами **get**, **post** и т.д.; атрибуты **model**, **template_name**, **queryset**. Роутинг: path(\'url/\', views.MyView.as_view()).\n\n**Декораторы для FBV:**\n- **@login_required** — редирект на логин, если пользователь не аутентифицирован; опционально **login_url**, **redirect_field_name**.\n- **@require_http_methods([\"GET\", \"POST\"])** — разрешить только указанные методы; иначе 405.\n- **@require_GET**, **@require_POST** — только GET или только POST.\n- **@csrf_exempt** — отключить проверку CSRF (осторожно, только для API/внешних вызовов).\n- **@cache_page(sec)** — кэшировать ответ на заданное число секунд.\n- **@user_passes_test(func)** — вызов **func(user)**; при False — редирект на логин. Для проверки прав.\n\n**request — основные атрибуты и методы:**\n- **request.method** — строка метода (\"GET\", \"POST\", \"PUT\" и т.д.).\n- **request.GET**, **request.POST** — QueryDict с параметрами запроса и данными формы.\n- **request.FILES** — загруженные файлы (мультипарт-форма).\n- **request.user** — текущий пользователь (AnonymousUser или User); доступен при включённой аутентификации.\n- **request.path**, **request.get_full_path()** — путь URL (без домена / с query string).\n- **request.META** — словарь заголовков и метаданных (HTTP_REFERER, REMOTE_ADDR, CONTENT_TYPE и т.д.).\n- **request.body** — сырое тело запроса (bytes); для JSON: **json.loads(request.body)**.\n- **request.COOKIES**, **request.session** — куки и объект сессии.\n\n**Миксины (django.views.generic / auth):**\n- **LoginRequiredMixin** — редирект на страницу входа, если пользователь не аутентифицирован; задаётся **login_url**.\n- **UserPassesTestMixin** — вызывается **test_func()**; при False — **PermissionDenied** или редирект (**permission_denied_message**, **handle_no_permission()**).\n- **PermissionRequiredMixin** — проверка **permission_required** (список прав); при отсутствии — 403.\n- **SuccessMessageMixin** — добавляет **success_message** в сообщения фреймворка после успешной операции (например, CreateView).\n\n**Дженерики (django.views.generic):**\n- **TemplateView** — отображение шаблона без модели/формы: **template_name**, контекст через **get_context_data()**. Подходит для статических страниц (о проекте, контакты).\n- **ListView** — список объектов: **model** или **queryset**, **context_object_name**, **paginate_by**. Один объект в контексте — список.\n- **DetailView** — один объект по **pk**/slug: **model**, **context_object_name**. Вызывает **get_object()**.\n- **CreateView** — форма создания: **model**, **form_class**, **fields**. Успех → **get_success_url()**.\n- **UpdateView** — форма редактирования по pk/slug.\n- **DeleteView** — подтверждение и удаление; **success_url** или **get_success_url()**.\n- **FormView** — только форма без привязки к модели: **form_class**, **template_name**, **success_url**.\n\n**Основные методы для переопределения:**\n- **get_queryset()** — вернуть QuerySet (фильтрация, аннотации). В **ListView**, **DetailView** и др.\n- **get_context_data(**kwargs)** — добавить данные в контекст шаблона; вызвать **super().get_context_data(**kwargs)** и дополнить.\n- **get_object(queryset=None)** — вернуть объект для **DetailView**/UpdateView/DeleteView (например, по slug или с проверкой прав).\n- **form_valid(form)** — после валидной формы; по умолчанию сохраняет объект (CreateView/UpdateView). Можно добавить логику и вызвать **super().form_valid(form)**.\n- **get_success_url()** — URL редиректа после успешного создания/обновления/удаления.\n- **dispatch(request, *args, **kwargs)** — точка входа перед **get/post**; проверки, логирование; вернуть **super().dispatch(...)** или **HttpResponse**.\n- **get(request, *args, **kwargs)** — обработка GET; в дженериках обычно не переопределяют, а используют **get_context_data**.\n- **post(request, *args, **kwargs)** — обработка POST; в дженериках логику чаще выносят в **form_valid**.\n\n**Кратко:** FBV vs CBV; миксины — **LoginRequiredMixin**, **UserPassesTestMixin**, **PermissionRequiredMixin**; дженерики — **TemplateView**, **ListView**, **DetailView**, **CreateView**, **UpdateView**, **DeleteView**, **FormView**; переопределять **get_queryset**, **get_context_data**, **get_object**, **form_valid**, **get_success_url**, **dispatch**.' },
  { id: 65, question: 'Models', answer: '**Модель** в Django — класс, наследующий **django.db.models.Model**. Описывает таблицу БД: поля → колонки, связи → внешние ключи. Каждый экземпляр — строка таблицы.\n\n**Основные типы полей:**\n- **CharField**, **TextField** — строка (max_length для CharField).\n- **IntegerField**, **BigIntegerField**, **SmallIntegerField** — целое.\n- **DecimalField**, **FloatField** — числа.\n- **BooleanField**, **NullBooleanField** — флаг.\n- **DateField**, **DateTimeField** — дата/время; **auto_now** (обновлять при save), **auto_now_add** (только при создании).\n- **EmailField**, **URLField**, **SlugField** — строки с валидацией.\n- **ForeignKey(Model, on_delete)** — связь «много к одному»; **on_delete**: CASCADE, PROTECT, SET_NULL, SET_DEFAULT.\n- **OneToOneField** — один к одному.\n- **ManyToManyField** — многие ко многим; опционально **through** — своя промежуточная модель.\n- **FileField**, **ImageField** — файлы (путь в медиа).\n\n**Мета (class Meta):**\n- **ordering** — порядок по умолчанию (список полей, например [\'-created_at\']).\n- **verbose_name** / **verbose_name_plural** — человекочитаемые имена.\n- **db_table** — имя таблицы в БД.\n- **constraints** — ограничения уровня таблицы (вместо устаревшего **unique_together**): **UniqueConstraint(fields=[\'a\', \'b\'], name=\'uq_ab\')** — уникальность по группе полей; **CheckConstraint(check=Q(price__gte=0), name=\'chk_price\')** — проверка по условию. Задаётся список в **Meta.constraints**.\n- **indexes** — список **Index** для индексов.\n\n**Менеджер:**\n\nПо умолчанию **objects** — экземпляр **Manager**; через него **all()**, **filter()**, **get()** и т.д.\n\nСвой менеджер: класс от **models.Manager**, переопределить **get_queryset()** или свои методы, присвоить атрибуту модели (**objects = MyManager()**).\n\nНесколько менеджеров: несколько атрибутов (**objects**, **published** и т.д.). Менеджер по умолчанию — **Meta.default_manager_name** (3.2+) или первый объявленный.\n\nНаследование: подкласс наследует менеджер родителя; свой можно задать заново.\n\nПример своих менеджеров:\n  class PublishedManager(models.Manager):\n      def get_queryset(self):\n          return super().get_queryset().filter(is_published=True)\n\n  class Article(models.Model):\n      title = models.CharField(max_length=200)\n      is_published = models.BooleanField(default=False)\n      objects = models.Manager()       # все записи\n      published = PublishedManager()   # только опубликованные\n  # Article.published.all() — только с is_published=True\n\n**Методы для переопределения:**\n- **__str__(self)** — строковое представление (админка, shell, отладка).\n- **clean(self)** — валидация на уровне модели (целиком объект). Вызывается при **full_clean()** на экземпляре модели; **ModelForm** вызывает **full_clean()** внутри **is_valid()**, поэтому **clean()** модели срабатывает при проверке формы. Используют для проверок, затрагивающих **несколько полей** (например, дата начала < дата окончания, уникальность пары полей). При ошибке — **raise ValidationError** (можно передать словарь «поле → список сообщений» для привязки ошибок к полям). Метод **save()** валидацию не вызывает — чтобы проверка выполнялась при сохранении, нужно явно вызывать **instance.full_clean()** перед **save()** или использовать форму/сериализатор.\n- **save(self, *args, **kwargs)** — логика перед/после сохранения; в конце вызвать **super().save(*args, **kwargs)**.\n- **delete(self, *args, **kwargs)** — при удалении; **super().delete()** в конце.\n- **get_absolute_url(self)** — URL объекта (используется в админке, редиректах).\n\n**Миграции:** **makemigrations** — создать файлы миграций по изменениям моделей; **migrate** — применить к БД. **Migration** хранит операции (CreateModel, AddField, AlterField и т.д.).\n\n**Кратко:** модель = класс от **Model**, поля и **Meta**; **ForeignKey**, **ManyToManyField**; менеджер **objects** и свои; **__str__**, **clean**, **save**, **delete**, **get_absolute_url**; миграции — **makemigrations**, **migrate**.' }
];

/** Блоки: id, title, questionIds */
const BLOCKS = [
  { id: 'basic', title: 'Python Core', questionIds: [1, 2, 3, 4, 50, 5, 6, 7, 8, 11, 17, 18, 48, 49, 19, 20, 42, 43, 51, 52, 54, 55, 56] },
  { id: 'oop', title: 'OOP', questionIds: [9, 10, 12, 13, 14, 15, 16, 35, 36, 57] },
  { id: 'algorithms', title: 'Algorithms', questionIds: [40, 41] },
  { id: 'db', title: 'DB', questionIds: [21, 22, 23, 24, 25, 37, 38, 39, 61, 62] },
  { id: 'web', title: 'Web / Network / REST', questionIds: [26, 27, 28, 29] },
  { id: 'asyncio', title: 'Asyncio', questionIds: [44, 45, 46, 47] },
  { id: 'django-drf', title: 'Django + DRF', questionIds: [63, 64, 65] },
  { id: 'fastapi', title: 'FastAPI', questionIds: [] },
  { id: 'architecture', title: 'Architecture / Patterns', questionIds: [30, 31, 32, 33, 34, 53, 58, 59, 60] }
];

(function () {
  const blocksEl = document.getElementById('blocks');
  const modalEl = document.getElementById('modal');
  const modalQuestion = modalEl.querySelector('.modal-question');
  const modalAnswer = modalEl.querySelector('.modal-answer');
  const modalClose = modalEl.querySelector('.modal-close');
  const modalBackdrop = modalEl.querySelector('.modal-backdrop');
  const modalContent = modalEl.querySelector('.modal-content');

  const questionsById = {};
  QUESTIONS.forEach(function (item) { questionsById[item.id] = item; });

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  /** В тексте **фраза** → жирное выделение (ключевые куски). */
  function formatKeyPhrases(rawLine) {
    const parts = rawLine.split(/\*\*(.+?)\*\*/g);
    let html = '';
    for (var i = 0; i < parts.length; i++) {
      var seg = escapeHtml(parts[i]);
      if (i % 2 === 1) html += '<strong class="answer-key">' + seg + '</strong>';
      else html += seg;
    }
    return html;
  }

  /** Строки с 2+ пробелов/таб — код; остальные — параграфы. Строки, оканчивающиеся на ":" — подзаголовки. **фраза** — ключевое. */
  function formatAnswer(text) {
    if (!text || typeof text !== 'string') return '';
    const lines = text.split('\n');
    var out = '';
    var inCode = false;
    for (var i = 0; i < lines.length; i++) {
      var line = lines[i];
      var isCodeLine = /^\s{2,}/.test(line) || /^\t/.test(line);
      if (isCodeLine) {
        if (!inCode) { out += '<pre class="answer-code"><code>'; inCode = true; }
        out += escapeHtml(line) + '\n';
      } else {
        if (inCode) { out += '</code></pre>'; inCode = false; }
        if (line.length) {
          var isHeading = line.slice(-1) === ':' && line.length < 160;
          var lineHtml = formatKeyPhrases(line);
          out += isHeading ? '<p class="answer-heading">' + lineHtml + '</p>' : '<p>' + lineHtml + '</p>';
        } else {
          out += '<p class="answer-space">&nbsp;</p>';
        }
      }
    }
    if (inCode) out += '</code></pre>';
    return out;
  }

  function openModal(item) {
    modalQuestion.textContent = item.question;
    modalAnswer.innerHTML = formatAnswer(item.answer);
    modalEl.classList.add('modal-open');
    document.body.style.overflow = 'hidden';
  }

  function closeModal() {
    modalEl.classList.remove('modal-open');
    document.body.style.overflow = '';
  }

  BLOCKS.forEach(function (block) {
    const section = document.createElement('section');
    section.className = 'block';
    section.id = block.id;
    const h2 = document.createElement('h2');
    h2.className = 'block-title';
    const toggle = document.createElement('span');
    toggle.className = 'block-title-toggle';
    toggle.setAttribute('aria-hidden', 'true');
    toggle.textContent = '\u25BE';
    h2.appendChild(toggle);
    h2.appendChild(document.createTextNode(block.title));
    h2.addEventListener('click', function () {
      section.classList.toggle('block--collapsed');
    });
    section.appendChild(h2);
    const cardsWrap = document.createElement('div');
    cardsWrap.className = 'cards';
    block.questionIds.forEach(function (qId, index) {
      const item = questionsById[qId];
      if (!item) return;
      const card = document.createElement('div');
      card.className = 'card';
      const numInBlock = index + 1;
      card.innerHTML = '<span class="card-id">' + numInBlock + '</span><span class="card-question">' + escapeHtml(item.question) + '</span>';
      card.addEventListener('click', function () { openModal(item); });
      cardsWrap.appendChild(card);
    });
    section.appendChild(cardsWrap);
    blocksEl.appendChild(section);
  });

  modalClose.addEventListener('click', closeModal);
  modalBackdrop.addEventListener('click', closeModal);
  modalContent.addEventListener('click', function (e) { e.stopPropagation(); });
  modalEl.addEventListener('click', function (e) {
    if (e.target === modalEl) closeModal();
  });
  document.addEventListener('keydown', function (e) {
    if (e.key === 'Escape' && modalEl.classList.contains('modal-open')) closeModal();
  });

  const btn500 = document.getElementById('btn-500');
  const screen500 = document.getElementById('screen-500');
  if (btn500 && screen500) {
    btn500.addEventListener('click', function () {
      document.body.classList.add('screen-500-active');
      document.body.style.overflow = 'hidden';
      screen500.classList.add('is-active');
      screen500.setAttribute('aria-hidden', 'false');
    });
    screen500.addEventListener('click', function () {
      document.body.classList.remove('screen-500-active');
      document.body.style.overflow = '';
      screen500.classList.remove('is-active');
      screen500.setAttribute('aria-hidden', 'true');
    });
  }
})();
